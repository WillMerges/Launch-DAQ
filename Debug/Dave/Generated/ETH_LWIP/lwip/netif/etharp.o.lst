   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "etharp.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .global ethbroadcast
  20              	 .section .rodata.ethbroadcast,"a",%progbits
  21              	 .align 2
  24              	ethbroadcast:
  25 0000 FF       	 .byte -1
  26 0001 FF       	 .byte -1
  27 0002 FF       	 .byte -1
  28 0003 FF       	 .byte -1
  29 0004 FF       	 .byte -1
  30 0005 FF       	 .byte -1
  31              	 .global ethzero
  32 0006 0000     	 .section .rodata.ethzero,"a",%progbits
  33              	 .align 2
  36              	ethzero:
  37 0000 00000000 	 .space 6
  37      0000
  38 0006 0000     	 .section .bss.arp_table,"aw",%nobits
  39              	 .align 2
  42              	arp_table:
  43 0000 00000000 	 .space 200
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              	 .section .bss.etharp_cached_entry,"aw",%nobits
  47              	etharp_cached_entry:
  48 0000 00       	 .space 1
  49              	 .section .text.etharp_free_entry,"ax",%progbits
  50              	 .align 2
  51              	 .thumb
  52              	 .thumb_func
  54              	etharp_free_entry:
  55              	.LFB128:
  56              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c"
   1:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Address Resolution Protocol module for IP over Ethernet
   4:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
   5:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Functionally, ARP is divided into two parts. The first maps an IP address
   6:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * to a physical address when sending a packet, and the second part answers
   7:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * requests from other machines for our physical address.
   8:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
   9:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * This implementation complies with RFC 826 (Ethernet ARP). It supports
  10:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Gratuitious ARP from RFC3220 (IP Mobility Support for IPv4) section 4.6
  11:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * if an interface calls etharp_gratuitous(our_netif) upon address change.
  12:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
  13:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  14:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /*
  15:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
  16:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
  17:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
  18:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * All rights reserved.
  19:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
  20:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  21:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * are permitted provided that the following conditions are met:
  22:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
  23:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  24:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *    this list of conditions and the following disclaimer.
  25:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  26:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *    this list of conditions and the following disclaimer in the documentation
  27:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *    and/or other materials provided with the distribution.
  28:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 3. The name of the author may not be used to endorse or promote products
  29:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *    derived from this software without specific prior written permission.
  30:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
  31:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  32:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  34:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  35:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  36:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  37:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  38:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  39:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  40:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * OF SUCH DAMAGE.
  41:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
  42:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * This file is part of the lwIP TCP/IP stack.
  43:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
  44:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
  45:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  
  46:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/lwip/opt.h"
  47:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  48:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_ARP || LWIP_ETHERNET
  49:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  50:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/ipv4/lwip/ip_addr.h"
  51:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/lwip/def.h"
  52:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/ipv4/lwip/ip.h"
  53:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/lwip/stats.h"
  54:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/lwip/snmp.h"
  55:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/lwip/dhcp.h"
  56:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/ipv4/lwip/autoip.h"
  57:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "../include/netif/etharp.h"
  58:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  59:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if PPPOE_SUPPORT
  60:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include "netif/ppp_oe.h"
  61:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* PPPOE_SUPPORT */
  62:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  63:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #include <string.h>
  64:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  65:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** const struct eth_addr ethbroadcast = {{0xff,0xff,0xff,0xff,0xff,0xff}};
  66:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** const struct eth_addr ethzero = {{0,0,0,0,0,0}};
  67:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  68:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** The 24-bit IANA multicast OUI is 01-00-5e: */
  69:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define LL_MULTICAST_ADDR_0 0x01
  70:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define LL_MULTICAST_ADDR_1 0x00
  71:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define LL_MULTICAST_ADDR_2 0x5e
  72:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  73:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_ARP /* don't build if not configured for use in lwipopts.h */
  74:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  75:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** the time an ARP entry stays valid after its last update,
  76:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  for ARP_TMR_INTERVAL = 5000, this is
  77:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  (240 * 5) seconds = 20 minutes.
  78:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
  79:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ARP_MAXAGE              240
  80:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Re-request a used ARP entry 1 minute before it would expire to prevent
  81:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  breaking a steadily used connection because the ARP entry timed out. */
  82:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ARP_AGE_REREQUEST_USED  (ARP_MAXAGE - 12)
  83:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  84:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** the time an ARP entry stays pending after first request,
  85:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  for ARP_TMR_INTERVAL = 5000, this is
  86:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  (2 * 5) seconds = 10 seconds.
  87:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
  88:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  @internal Keep this number at least 2, otherwise it might
  89:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  run out instantly if the timeout occurs directly after a request.
  90:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
  91:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ARP_MAXPENDING 2
  92:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  93:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define HWTYPE_ETHERNET 1
  94:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
  95:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** enum etharp_state {
  96:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATE_EMPTY = 0,
  97:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATE_PENDING,
  98:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATE_STABLE,
  99:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATE_STABLE_REREQUESTING
 100:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 101:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ,ETHARP_STATE_STATIC
 102:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 103:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** };
 104:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 105:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** struct etharp_entry {
 106:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ARP_QUEUEING
 107:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /** Pointer to queue of pending outgoing packets on this ARP entry. */
 108:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct etharp_q_entry *q;
 109:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else /* ARP_QUEUEING */
 110:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /** Pointer to a single pending outgoing packet on this ARP entry. */
 111:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct pbuf *q;
 112:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ARP_QUEUEING */
 113:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_t ipaddr;
 114:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct netif *netif;
 115:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_addr ethaddr;
 116:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t state;
 117:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t ctime;
 118:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** };
 119:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 120:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static struct etharp_entry arp_table[ARP_TABLE_SIZE];
 121:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 122:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if !LWIP_NETIF_HWADDRHINT
 123:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static u8_t etharp_cached_entry;
 124:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* !LWIP_NETIF_HWADDRHINT */
 125:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 126:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Try hard to create a new entry - we want the IP address to appear in
 127:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     the cache (even if this means removing an active entry or so). */
 128:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ETHARP_FLAG_TRY_HARD     1
 129:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ETHARP_FLAG_FIND_ONLY    2
 130:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 131:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ETHARP_FLAG_STATIC_ENTRY 4
 132:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 133:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 134:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 135:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ETHARP_SET_HINT(netif, hint)  if (((netif) != NULL) && ((netif)->addr_hint != NULL))  \
 136:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                                       *((netif)->addr_hint) = (hint);
 137:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else /* LWIP_NETIF_HWADDRHINT */
 138:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define ETHARP_SET_HINT(netif, hint)  (etharp_cached_entry = (hint))
 139:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 140:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 141:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 142:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /* Some checks, instead of etharp_init(): */
 143:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if (LWIP_ARP && (ARP_TABLE_SIZE > 0x7f))
 144:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   #error "ARP_TABLE_SIZE must fit in an s8_t, you have to reduce it in your lwipopts.h"
 145:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif
 146:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 147:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 148:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ARP_QUEUEING
 149:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 150:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Free a complete queue of etharp entries
 151:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 152:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param q a qeueue of etharp_q_entry's to free
 153:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 154:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static void
 155:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** free_etharp_q(struct etharp_q_entry *q)
 156:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 157:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct etharp_q_entry *r;
 158:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 159:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("q->p != NULL", q->p != NULL);
 160:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   while (q) {
 161:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     r = q;
 162:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     q = q->next;
 163:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_ASSERT("r->p != NULL", (r->p != NULL));
 164:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     pbuf_free(r->p);
 165:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     memp_free(MEMP_ARP_QUEUE, r);
 166:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 167:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 168:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else /* ARP_QUEUEING */
 169:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 170:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Compatibility define: free the queued pbuf */
 171:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #define free_etharp_q(q) pbuf_free(q)
 172:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 173:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ARP_QUEUEING */
 174:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 175:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Clean up ARP table entries */
 176:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static void
 177:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_free_entry(int i)
 178:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
  57              	 .loc 1 178 0
  58              	 .cfi_startproc
  59              	 
  60              	 
  61 0000 80B5     	 push {r7,lr}
  62              	.LCFI0:
  63              	 .cfi_def_cfa_offset 8
  64              	 .cfi_offset 7,-8
  65              	 .cfi_offset 14,-4
  66 0002 82B0     	 sub sp,sp,#8
  67              	.LCFI1:
  68              	 .cfi_def_cfa_offset 16
  69 0004 00AF     	 add r7,sp,#0
  70              	.LCFI2:
  71              	 .cfi_def_cfa_register 7
  72 0006 7860     	 str r0,[r7,#4]
 179:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* remove from SNMP ARP index tree */
 180:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
 181:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* and empty packet queue */
 182:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (arp_table[i].q != NULL) {
  73              	 .loc 1 182 0
  74 0008 1549     	 ldr r1,.L3
  75 000a 7A68     	 ldr r2,[r7,#4]
  76 000c 1346     	 mov r3,r2
  77 000e 9B00     	 lsls r3,r3,#2
  78 0010 1344     	 add r3,r3,r2
  79 0012 9B00     	 lsls r3,r3,#2
  80 0014 0B44     	 add r3,r3,r1
  81 0016 1B68     	 ldr r3,[r3]
  82 0018 002B     	 cmp r3,#0
  83 001a 13D0     	 beq .L2
 183:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* remove all queued packets */
 184:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u1
 185:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     free_etharp_q(arp_table[i].q);
  84              	 .loc 1 185 0
  85 001c 1049     	 ldr r1,.L3
  86 001e 7A68     	 ldr r2,[r7,#4]
  87 0020 1346     	 mov r3,r2
  88 0022 9B00     	 lsls r3,r3,#2
  89 0024 1344     	 add r3,r3,r2
  90 0026 9B00     	 lsls r3,r3,#2
  91 0028 0B44     	 add r3,r3,r1
  92 002a 1B68     	 ldr r3,[r3]
  93 002c 1846     	 mov r0,r3
  94 002e FFF7FEFF 	 bl pbuf_free
 186:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].q = NULL;
  95              	 .loc 1 186 0
  96 0032 0B49     	 ldr r1,.L3
  97 0034 7A68     	 ldr r2,[r7,#4]
  98 0036 1346     	 mov r3,r2
  99 0038 9B00     	 lsls r3,r3,#2
 100 003a 1344     	 add r3,r3,r2
 101 003c 9B00     	 lsls r3,r3,#2
 102 003e 0B44     	 add r3,r3,r1
 103 0040 0022     	 movs r2,#0
 104 0042 1A60     	 str r2,[r3]
 105              	.L2:
 187:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 188:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* recycle entry for re-use */
 189:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].state = ETHARP_STATE_EMPTY;
 106              	 .loc 1 189 0
 107 0044 0649     	 ldr r1,.L3
 108 0046 7A68     	 ldr r2,[r7,#4]
 109 0048 1346     	 mov r3,r2
 110 004a 9B00     	 lsls r3,r3,#2
 111 004c 1344     	 add r3,r3,r2
 112 004e 9B00     	 lsls r3,r3,#2
 113 0050 0B44     	 add r3,r3,r1
 114 0052 1033     	 adds r3,r3,#16
 115 0054 0022     	 movs r2,#0
 116 0056 9A70     	 strb r2,[r3,#2]
 190:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #ifdef LWIP_DEBUG
 191:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* for debugging, clean out the complete entry */
 192:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].ctime = 0;
 193:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].netif = NULL;
 194:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_set_zero(&arp_table[i].ipaddr);
 195:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].ethaddr = ethzero;
 196:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_DEBUG */
 197:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 117              	 .loc 1 197 0
 118 0058 0837     	 adds r7,r7,#8
 119              	.LCFI3:
 120              	 .cfi_def_cfa_offset 8
 121 005a BD46     	 mov sp,r7
 122              	.LCFI4:
 123              	 .cfi_def_cfa_register 13
 124              	 
 125 005c 80BD     	 pop {r7,pc}
 126              	.L4:
 127 005e 00BF     	 .align 2
 128              	.L3:
 129 0060 00000000 	 .word arp_table
 130              	 .cfi_endproc
 131              	.LFE128:
 133              	 .section .text.etharp_tmr,"ax",%progbits
 134              	 .align 2
 135              	 .global etharp_tmr
 136              	 .thumb
 137              	 .thumb_func
 139              	etharp_tmr:
 140              	.LFB129:
 198:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 199:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 200:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Clears expired entries in the ARP table.
 201:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 202:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 203:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * in order to expire entries in the ARP table.
 204:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 205:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** void
 206:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_tmr(void)
 207:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 141              	 .loc 1 207 0
 142              	 .cfi_startproc
 143              	 
 144              	 
 145 0000 80B5     	 push {r7,lr}
 146              	.LCFI5:
 147              	 .cfi_def_cfa_offset 8
 148              	 .cfi_offset 7,-8
 149              	 .cfi_offset 14,-4
 150 0002 82B0     	 sub sp,sp,#8
 151              	.LCFI6:
 152              	 .cfi_def_cfa_offset 16
 153 0004 00AF     	 add r7,sp,#0
 154              	.LCFI7:
 155              	 .cfi_def_cfa_register 7
 208:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t i;
 209:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 210:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
 211:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* remove expired entries from the ARP table */
 212:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 156              	 .loc 1 212 0
 157 0006 0023     	 movs r3,#0
 158 0008 FB71     	 strb r3,[r7,#7]
 159 000a 5EE0     	 b .L6
 160              	.L10:
 161              	.LBB2:
 213:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 162              	 .loc 1 213 0
 163 000c FA79     	 ldrb r2,[r7,#7]
 164 000e 3249     	 ldr r1,.L11
 165 0010 1346     	 mov r3,r2
 166 0012 9B00     	 lsls r3,r3,#2
 167 0014 1344     	 add r3,r3,r2
 168 0016 9B00     	 lsls r3,r3,#2
 169 0018 0B44     	 add r3,r3,r1
 170 001a 1033     	 adds r3,r3,#16
 171 001c 9B78     	 ldrb r3,[r3,#2]
 172 001e BB71     	 strb r3,[r7,#6]
 214:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (state != ETHARP_STATE_EMPTY
 173              	 .loc 1 214 0
 174 0020 BB79     	 ldrb r3,[r7,#6]
 175 0022 002B     	 cmp r3,#0
 176 0024 4ED0     	 beq .L7
 215:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 216:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       && (state != ETHARP_STATE_STATIC)
 217:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 218:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ) {
 219:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       arp_table[i].ctime++;
 177              	 .loc 1 219 0
 178 0026 FA79     	 ldrb r2,[r7,#7]
 179 0028 2B49     	 ldr r1,.L11
 180 002a 1346     	 mov r3,r2
 181 002c 9B00     	 lsls r3,r3,#2
 182 002e 1344     	 add r3,r3,r2
 183 0030 9B00     	 lsls r3,r3,#2
 184 0032 0B44     	 add r3,r3,r1
 185 0034 1033     	 adds r3,r3,#16
 186 0036 DB78     	 ldrb r3,[r3,#3]
 187 0038 0133     	 adds r3,r3,#1
 188 003a D8B2     	 uxtb r0,r3
 189 003c 2649     	 ldr r1,.L11
 190 003e 1346     	 mov r3,r2
 191 0040 9B00     	 lsls r3,r3,#2
 192 0042 1344     	 add r3,r3,r2
 193 0044 9B00     	 lsls r3,r3,#2
 194 0046 0B44     	 add r3,r3,r1
 195 0048 1033     	 adds r3,r3,#16
 196 004a 0246     	 mov r2,r0
 197 004c DA70     	 strb r2,[r3,#3]
 220:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 198              	 .loc 1 220 0
 199 004e FA79     	 ldrb r2,[r7,#7]
 200 0050 2149     	 ldr r1,.L11
 201 0052 1346     	 mov r3,r2
 202 0054 9B00     	 lsls r3,r3,#2
 203 0056 1344     	 add r3,r3,r2
 204 0058 9B00     	 lsls r3,r3,#2
 205 005a 0B44     	 add r3,r3,r1
 206 005c 1033     	 adds r3,r3,#16
 207 005e DB78     	 ldrb r3,[r3,#3]
 208 0060 EF2B     	 cmp r3,#239
 209 0062 15D8     	 bhi .L8
 221:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 210              	 .loc 1 221 0 discriminator 1
 211 0064 FA79     	 ldrb r2,[r7,#7]
 212 0066 1C49     	 ldr r1,.L11
 213 0068 1346     	 mov r3,r2
 214 006a 9B00     	 lsls r3,r3,#2
 215 006c 1344     	 add r3,r3,r2
 216 006e 9B00     	 lsls r3,r3,#2
 217 0070 0B44     	 add r3,r3,r1
 218 0072 1033     	 adds r3,r3,#16
 219 0074 9B78     	 ldrb r3,[r3,#2]
 220:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 220              	 .loc 1 220 0 discriminator 1
 221 0076 012B     	 cmp r3,#1
 222 0078 0FD1     	 bne .L9
 222:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            (arp_table[i].ctime >= ARP_MAXPENDING))) {
 223              	 .loc 1 222 0
 224 007a FA79     	 ldrb r2,[r7,#7]
 225 007c 1649     	 ldr r1,.L11
 226 007e 1346     	 mov r3,r2
 227 0080 9B00     	 lsls r3,r3,#2
 228 0082 1344     	 add r3,r3,r2
 229 0084 9B00     	 lsls r3,r3,#2
 230 0086 0B44     	 add r3,r3,r1
 231 0088 1033     	 adds r3,r3,#16
 232 008a DB78     	 ldrb r3,[r3,#3]
 221:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 233              	 .loc 1 221 0
 234 008c 012B     	 cmp r3,#1
 235 008e 04D9     	 bls .L9
 236              	.L8:
 223:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* pending or stable entry has become old! */
 224:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
 225:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****              arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
 226:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* clean up entries that have just been expired */
 227:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         etharp_free_entry(i);
 237              	 .loc 1 227 0
 238 0090 FB79     	 ldrb r3,[r7,#7]
 239 0092 1846     	 mov r0,r3
 240 0094 FFF7FEFF 	 bl etharp_free_entry
 241 0098 14E0     	 b .L7
 242              	.L9:
 228:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 229:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 243              	 .loc 1 229 0
 244 009a FA79     	 ldrb r2,[r7,#7]
 245 009c 0E49     	 ldr r1,.L11
 246 009e 1346     	 mov r3,r2
 247 00a0 9B00     	 lsls r3,r3,#2
 248 00a2 1344     	 add r3,r3,r2
 249 00a4 9B00     	 lsls r3,r3,#2
 250 00a6 0B44     	 add r3,r3,r1
 251 00a8 1033     	 adds r3,r3,#16
 252 00aa 9B78     	 ldrb r3,[r3,#2]
 253 00ac 032B     	 cmp r3,#3
 254 00ae 09D1     	 bne .L7
 230:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* Reset state to stable, so that the next transmitted packet will
 231:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            re-send an ARP request. */
 232:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         arp_table[i].state = ETHARP_STATE_STABLE;
 255              	 .loc 1 232 0
 256 00b0 FA79     	 ldrb r2,[r7,#7]
 257 00b2 0949     	 ldr r1,.L11
 258 00b4 1346     	 mov r3,r2
 259 00b6 9B00     	 lsls r3,r3,#2
 260 00b8 1344     	 add r3,r3,r2
 261 00ba 9B00     	 lsls r3,r3,#2
 262 00bc 0B44     	 add r3,r3,r1
 263 00be 1033     	 adds r3,r3,#16
 264 00c0 0222     	 movs r2,#2
 265 00c2 9A70     	 strb r2,[r3,#2]
 266              	.L7:
 267              	.LBE2:
 212:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 268              	 .loc 1 212 0 discriminator 2
 269 00c4 FB79     	 ldrb r3,[r7,#7]
 270 00c6 0133     	 adds r3,r3,#1
 271 00c8 FB71     	 strb r3,[r7,#7]
 272              	.L6:
 212:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 273              	 .loc 1 212 0 is_stmt 0 discriminator 1
 274 00ca FB79     	 ldrb r3,[r7,#7]
 275 00cc 092B     	 cmp r3,#9
 276 00ce 9DD9     	 bls .L10
 233:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 234:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ARP_QUEUEING
 235:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* still pending entry? (not expired) */
 236:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (arp_table[i].state == ETHARP_STATE_PENDING) {
 237:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* resend an ARP query here? */
 238:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 239:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ARP_QUEUEING */
 240:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 241:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 242:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 277              	 .loc 1 242 0 is_stmt 1
 278 00d0 0837     	 adds r7,r7,#8
 279              	.LCFI8:
 280              	 .cfi_def_cfa_offset 8
 281 00d2 BD46     	 mov sp,r7
 282              	.LCFI9:
 283              	 .cfi_def_cfa_register 13
 284              	 
 285 00d4 80BD     	 pop {r7,pc}
 286              	.L12:
 287 00d6 00BF     	 .align 2
 288              	.L11:
 289 00d8 00000000 	 .word arp_table
 290              	 .cfi_endproc
 291              	.LFE129:
 293              	 .section .text.etharp_find_entry,"ax",%progbits
 294              	 .align 2
 295              	 .thumb
 296              	 .thumb_func
 298              	etharp_find_entry:
 299              	.LFB130:
 243:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 244:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 245:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Search the ARP table for a matching or new entry.
 246:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 247:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If an IP address is given, return a pending or stable ARP entry that matches
 248:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * the address. If no match is found, create a new entry with this address set,
 249:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * but in state ETHARP_EMPTY. The caller must check and possibly change the
 250:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * state of the returned entry.
 251:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 252:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If ipaddr is NULL, return a initialized new entry in state ETHARP_EMPTY.
 253:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 254:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * In all cases, attempt to create new entries from an empty entry. If no
 255:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * empty entries are available and ETHARP_FLAG_TRY_HARD flag is set, recycle
 256:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * old entries. Heuristic choose the least important entry for recycling.
 257:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 258:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr IP address to find in ARP cache, or to add if not found.
 259:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param flags @see definition of ETHARP_FLAG_*
 260:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif netif related to this address (used for NETIF_HWADDRHINT)
 261:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *  
 262:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return The ARP entry index that matched or is created, ERR_MEM if no
 263:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * entry is found or could be recycled.
 264:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 265:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static s8_t
 266:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
 267:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 300              	 .loc 1 267 0
 301              	 .cfi_startproc
 302              	 
 303              	 
 304 0000 80B5     	 push {r7,lr}
 305              	.LCFI10:
 306              	 .cfi_def_cfa_offset 8
 307              	 .cfi_offset 7,-8
 308              	 .cfi_offset 14,-4
 309 0002 86B0     	 sub sp,sp,#24
 310              	.LCFI11:
 311              	 .cfi_def_cfa_offset 32
 312 0004 00AF     	 add r7,sp,#0
 313              	.LCFI12:
 314              	 .cfi_def_cfa_register 7
 315 0006 7860     	 str r0,[r7,#4]
 316 0008 0B46     	 mov r3,r1
 317 000a FB70     	 strb r3,[r7,#3]
 268:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 318              	 .loc 1 268 0
 319 000c 0A23     	 movs r3,#10
 320 000e FB75     	 strb r3,[r7,#23]
 321 0010 0A23     	 movs r3,#10
 322 0012 BB75     	 strb r3,[r7,#22]
 269:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t empty = ARP_TABLE_SIZE;
 323              	 .loc 1 269 0
 324 0014 0A23     	 movs r3,#10
 325 0016 7B75     	 strb r3,[r7,#21]
 270:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t i = 0, age_pending = 0, age_stable = 0;
 326              	 .loc 1 270 0
 327 0018 0023     	 movs r3,#0
 328 001a 3B75     	 strb r3,[r7,#20]
 329 001c 0023     	 movs r3,#0
 330 001e FB74     	 strb r3,[r7,#19]
 331 0020 0023     	 movs r3,#0
 332 0022 BB74     	 strb r3,[r7,#18]
 271:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* oldest entry with packets on queue */
 272:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t old_queue = ARP_TABLE_SIZE;
 333              	 .loc 1 272 0
 334 0024 0A23     	 movs r3,#10
 335 0026 7B74     	 strb r3,[r7,#17]
 273:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* its age */
 274:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t age_queue = 0;
 336              	 .loc 1 274 0
 337 0028 0023     	 movs r3,#0
 338 002a 3B74     	 strb r3,[r7,#16]
 275:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 276:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /**
 277:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * a) do a search through the cache, remember candidates
 278:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * b) select candidate entry
 279:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * c) create new entry
 280:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    */
 281:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 282:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* a) in a single search sweep, do all of this
 283:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 1) remember the first empty entry (if any)
 284:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 2) remember the oldest stable entry (if any)
 285:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 3) remember the oldest pending entry without queued packets (if any)
 286:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 4) remember the oldest pending entry with queued packets (if any)
 287:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 5) search for a matching IP entry, either pending or stable
 288:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    *    until 5 matches, or all entries are searched for.
 289:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    */
 290:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 291:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 339              	 .loc 1 291 0
 340 002c 0023     	 movs r3,#0
 341 002e 3B75     	 strb r3,[r7,#20]
 342 0030 84E0     	 b .L14
 343              	.L23:
 344              	.LBB3:
 292:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 345              	 .loc 1 292 0
 346 0032 3A7D     	 ldrb r2,[r7,#20]
 347 0034 6B49     	 ldr r1,.L33
 348 0036 1346     	 mov r3,r2
 349 0038 9B00     	 lsls r3,r3,#2
 350 003a 1344     	 add r3,r3,r2
 351 003c 9B00     	 lsls r3,r3,#2
 352 003e 0B44     	 add r3,r3,r1
 353 0040 1033     	 adds r3,r3,#16
 354 0042 9B78     	 ldrb r3,[r3,#2]
 355 0044 FB73     	 strb r3,[r7,#15]
 293:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* no empty entry found yet and now we do find one? */
 294:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 356              	 .loc 1 294 0
 357 0046 97F91530 	 ldrsb r3,[r7,#21]
 358 004a 0A2B     	 cmp r3,#10
 359 004c 05D1     	 bne .L15
 360              	 .loc 1 294 0 is_stmt 0 discriminator 1
 361 004e FB7B     	 ldrb r3,[r7,#15]
 362 0050 002B     	 cmp r3,#0
 363 0052 02D1     	 bne .L15
 295:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
 296:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* remember first empty entry */
 297:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       empty = i;
 364              	 .loc 1 297 0 is_stmt 1
 365 0054 3B7D     	 ldrb r3,[r7,#20]
 366 0056 7B75     	 strb r3,[r7,#21]
 367 0058 6DE0     	 b .L16
 368              	.L15:
 298:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else if (state != ETHARP_STATE_EMPTY) {
 369              	 .loc 1 298 0
 370 005a FB7B     	 ldrb r3,[r7,#15]
 371 005c 002B     	 cmp r3,#0
 372 005e 6AD0     	 beq .L16
 299:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 300:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 301:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* if given, does IP address match IP address in ARP entry? */
 302:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 373              	 .loc 1 302 0
 374 0060 7B68     	 ldr r3,[r7,#4]
 375 0062 002B     	 cmp r3,#0
 376 0064 0DD0     	 beq .L17
 377              	 .loc 1 302 0 is_stmt 0 discriminator 1
 378 0066 7B68     	 ldr r3,[r7,#4]
 379 0068 1968     	 ldr r1,[r3]
 380 006a 3A7D     	 ldrb r2,[r7,#20]
 381 006c 5D48     	 ldr r0,.L33
 382 006e 1346     	 mov r3,r2
 383 0070 9B00     	 lsls r3,r3,#2
 384 0072 1344     	 add r3,r3,r2
 385 0074 9B00     	 lsls r3,r3,#2
 386 0076 0344     	 add r3,r3,r0
 387 0078 5B68     	 ldr r3,[r3,#4]
 388 007a 9942     	 cmp r1,r3
 389 007c 01D1     	 bne .L17
 303:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_
 304:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* found exact IP address match, simply bail out */
 305:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         return i;
 390              	 .loc 1 305 0 is_stmt 1
 391 007e 3B7D     	 ldrb r3,[r7,#20]
 392 0080 AAE0     	 b .L18
 393              	.L17:
 306:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 307:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* pending entry? */
 308:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (state == ETHARP_STATE_PENDING) {
 394              	 .loc 1 308 0
 395 0082 FB7B     	 ldrb r3,[r7,#15]
 396 0084 012B     	 cmp r3,#1
 397 0086 3BD1     	 bne .L19
 309:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* pending with queued packets? */
 310:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if (arp_table[i].q != NULL) {
 398              	 .loc 1 310 0
 399 0088 3A7D     	 ldrb r2,[r7,#20]
 400 008a 5649     	 ldr r1,.L33
 401 008c 1346     	 mov r3,r2
 402 008e 9B00     	 lsls r3,r3,#2
 403 0090 1344     	 add r3,r3,r2
 404 0092 9B00     	 lsls r3,r3,#2
 405 0094 0B44     	 add r3,r3,r1
 406 0096 1B68     	 ldr r3,[r3]
 407 0098 002B     	 cmp r3,#0
 408 009a 18D0     	 beq .L20
 311:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 409              	 .loc 1 311 0
 410 009c 3A7D     	 ldrb r2,[r7,#20]
 411 009e 5149     	 ldr r1,.L33
 412 00a0 1346     	 mov r3,r2
 413 00a2 9B00     	 lsls r3,r3,#2
 414 00a4 1344     	 add r3,r3,r2
 415 00a6 9B00     	 lsls r3,r3,#2
 416 00a8 0B44     	 add r3,r3,r1
 417 00aa 1033     	 adds r3,r3,#16
 418 00ac DB78     	 ldrb r3,[r3,#3]
 419 00ae 3A7C     	 ldrb r2,[r7,#16]
 420 00b0 9A42     	 cmp r2,r3
 421 00b2 40D8     	 bhi .L16
 312:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             old_queue = i;
 422              	 .loc 1 312 0
 423 00b4 3B7D     	 ldrb r3,[r7,#20]
 424 00b6 7B74     	 strb r3,[r7,#17]
 313:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             age_queue = arp_table[i].ctime;
 425              	 .loc 1 313 0
 426 00b8 3A7D     	 ldrb r2,[r7,#20]
 427 00ba 4A49     	 ldr r1,.L33
 428 00bc 1346     	 mov r3,r2
 429 00be 9B00     	 lsls r3,r3,#2
 430 00c0 1344     	 add r3,r3,r2
 431 00c2 9B00     	 lsls r3,r3,#2
 432 00c4 0B44     	 add r3,r3,r1
 433 00c6 1033     	 adds r3,r3,#16
 434 00c8 DB78     	 ldrb r3,[r3,#3]
 435 00ca 3B74     	 strb r3,[r7,#16]
 436 00cc 33E0     	 b .L16
 437              	.L20:
 314:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           }
 315:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         } else
 316:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* pending without queued packets? */
 317:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         {
 318:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           if (arp_table[i].ctime >= age_pending) {
 438              	 .loc 1 318 0
 439 00ce 3A7D     	 ldrb r2,[r7,#20]
 440 00d0 4449     	 ldr r1,.L33
 441 00d2 1346     	 mov r3,r2
 442 00d4 9B00     	 lsls r3,r3,#2
 443 00d6 1344     	 add r3,r3,r2
 444 00d8 9B00     	 lsls r3,r3,#2
 445 00da 0B44     	 add r3,r3,r1
 446 00dc 1033     	 adds r3,r3,#16
 447 00de DB78     	 ldrb r3,[r3,#3]
 448 00e0 FA7C     	 ldrb r2,[r7,#19]
 449 00e2 9A42     	 cmp r2,r3
 450 00e4 27D8     	 bhi .L16
 319:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             old_pending = i;
 451              	 .loc 1 319 0
 452 00e6 3B7D     	 ldrb r3,[r7,#20]
 453 00e8 FB75     	 strb r3,[r7,#23]
 320:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             age_pending = arp_table[i].ctime;
 454              	 .loc 1 320 0
 455 00ea 3A7D     	 ldrb r2,[r7,#20]
 456 00ec 3D49     	 ldr r1,.L33
 457 00ee 1346     	 mov r3,r2
 458 00f0 9B00     	 lsls r3,r3,#2
 459 00f2 1344     	 add r3,r3,r2
 460 00f4 9B00     	 lsls r3,r3,#2
 461 00f6 0B44     	 add r3,r3,r1
 462 00f8 1033     	 adds r3,r3,#16
 463 00fa DB78     	 ldrb r3,[r3,#3]
 464 00fc FB74     	 strb r3,[r7,#19]
 465 00fe 1AE0     	 b .L16
 466              	.L19:
 321:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           }
 322:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
 323:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* stable entry? */
 324:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       } else if (state >= ETHARP_STATE_STABLE) {
 467              	 .loc 1 324 0
 468 0100 FB7B     	 ldrb r3,[r7,#15]
 469 0102 012B     	 cmp r3,#1
 470 0104 17D9     	 bls .L16
 325:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 326:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* don't record old_stable for static entries since they never expire */
 327:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if (state < ETHARP_STATE_STATIC)
 328:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 329:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         {
 330:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* remember entry with oldest stable entry in oldest, its age in maxtime */
 331:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           if (arp_table[i].ctime >= age_stable) {
 471              	 .loc 1 331 0
 472 0106 3A7D     	 ldrb r2,[r7,#20]
 473 0108 3649     	 ldr r1,.L33
 474 010a 1346     	 mov r3,r2
 475 010c 9B00     	 lsls r3,r3,#2
 476 010e 1344     	 add r3,r3,r2
 477 0110 9B00     	 lsls r3,r3,#2
 478 0112 0B44     	 add r3,r3,r1
 479 0114 1033     	 adds r3,r3,#16
 480 0116 DB78     	 ldrb r3,[r3,#3]
 481 0118 BA7C     	 ldrb r2,[r7,#18]
 482 011a 9A42     	 cmp r2,r3
 483 011c 0BD8     	 bhi .L16
 332:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             old_stable = i;
 484              	 .loc 1 332 0
 485 011e 3B7D     	 ldrb r3,[r7,#20]
 486 0120 BB75     	 strb r3,[r7,#22]
 333:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             age_stable = arp_table[i].ctime;
 487              	 .loc 1 333 0
 488 0122 3A7D     	 ldrb r2,[r7,#20]
 489 0124 2F49     	 ldr r1,.L33
 490 0126 1346     	 mov r3,r2
 491 0128 9B00     	 lsls r3,r3,#2
 492 012a 1344     	 add r3,r3,r2
 493 012c 9B00     	 lsls r3,r3,#2
 494 012e 0B44     	 add r3,r3,r1
 495 0130 1033     	 adds r3,r3,#16
 496 0132 DB78     	 ldrb r3,[r3,#3]
 497 0134 BB74     	 strb r3,[r7,#18]
 498              	.L16:
 499              	.LBE3:
 291:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 500              	 .loc 1 291 0 discriminator 2
 501 0136 3B7D     	 ldrb r3,[r7,#20]
 502 0138 0133     	 adds r3,r3,#1
 503 013a 3B75     	 strb r3,[r7,#20]
 504              	.L14:
 291:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 505              	 .loc 1 291 0 is_stmt 0 discriminator 1
 506 013c 3B7D     	 ldrb r3,[r7,#20]
 507 013e 092B     	 cmp r3,#9
 508 0140 7FF677AF 	 bls .L23
 334:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           }
 335:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
 336:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 337:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 338:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 339:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* { we have no match } => try to create a new entry */
 340:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    
 341:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* don't create new entry, only search? */
 342:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 509              	 .loc 1 342 0 is_stmt 1
 510 0144 FB78     	 ldrb r3,[r7,#3]
 511 0146 03F00203 	 and r3,r3,#2
 512 014a 002B     	 cmp r3,#0
 513 014c 08D1     	 bne .L24
 514              	 .loc 1 342 0 is_stmt 0 discriminator 1
 515 014e 97F91530 	 ldrsb r3,[r7,#21]
 516 0152 0A2B     	 cmp r3,#10
 517 0154 06D1     	 bne .L25
 343:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 344:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 518              	 .loc 1 344 0 is_stmt 1
 519 0156 FB78     	 ldrb r3,[r7,#3]
 520 0158 03F00103 	 and r3,r3,#1
 521 015c 002B     	 cmp r3,#0
 522 015e 01D1     	 bne .L25
 523              	.L24:
 345:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not al
 346:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return (s8_t)ERR_MEM;
 524              	 .loc 1 346 0
 525 0160 FF23     	 movs r3,#255
 526 0162 39E0     	 b .L18
 527              	.L25:
 347:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 348:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   
 349:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* b) choose the least destructive entry to recycle:
 350:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 1) empty entry
 351:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 2) oldest stable entry
 352:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 3) oldest pending entry without queued packets
 353:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 4) oldest pending entry with queued packets
 354:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 
 355:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * { ETHARP_FLAG_TRY_HARD is set at this point }
 356:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    */ 
 357:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 358:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* 1) empty entry available? */
 359:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (empty < ARP_TABLE_SIZE) {
 528              	 .loc 1 359 0
 529 0164 97F91530 	 ldrsb r3,[r7,#21]
 530 0168 092B     	 cmp r3,#9
 531 016a 02DC     	 bgt .L26
 360:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     i = empty;
 532              	 .loc 1 360 0
 533 016c 7B7D     	 ldrb r3,[r7,#21]
 534 016e 3B75     	 strb r3,[r7,#20]
 535 0170 1AE0     	 b .L27
 536              	.L26:
 361:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\
 362:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else {
 363:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* 2) found recyclable stable entry? */
 364:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (old_stable < ARP_TABLE_SIZE) {
 537              	 .loc 1 364 0
 538 0172 97F91630 	 ldrsb r3,[r7,#22]
 539 0176 092B     	 cmp r3,#9
 540 0178 02DC     	 bgt .L28
 365:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* recycle oldest stable*/
 366:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       i = old_stable;
 541              	 .loc 1 366 0
 542 017a BB7D     	 ldrb r3,[r7,#22]
 543 017c 3B75     	 strb r3,[r7,#20]
 544 017e 0FE0     	 b .L29
 545              	.L28:
 367:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry
 368:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* no queued packets should exist on stable entries */
 369:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 370:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* 3) found recyclable pending entry without queued packets? */
 371:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else if (old_pending < ARP_TABLE_SIZE) {
 546              	 .loc 1 371 0
 547 0180 97F91730 	 ldrsb r3,[r7,#23]
 548 0184 092B     	 cmp r3,#9
 549 0186 02DC     	 bgt .L30
 372:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* recycle oldest pending */
 373:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       i = old_pending;
 550              	 .loc 1 373 0
 551 0188 FB7D     	 ldrb r3,[r7,#23]
 552 018a 3B75     	 strb r3,[r7,#20]
 553 018c 08E0     	 b .L29
 554              	.L30:
 374:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 375:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* 4) found recyclable pending entry with queued packets? */
 376:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else if (old_queue < ARP_TABLE_SIZE) {
 555              	 .loc 1 376 0
 556 018e 97F91130 	 ldrsb r3,[r7,#17]
 557 0192 092B     	 cmp r3,#9
 558 0194 02DC     	 bgt .L31
 377:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* recycle oldest pending (queued packets are free in etharp_free_entry) */
 378:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       i = old_queue;
 559              	 .loc 1 378 0
 560 0196 7B7C     	 ldrb r3,[r7,#17]
 561 0198 3B75     	 strb r3,[r7,#20]
 562 019a 01E0     	 b .L29
 563              	.L31:
 379:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 380:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* no empty or recyclable entries found */
 381:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else {
 382:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entrie
 383:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       return (s8_t)ERR_MEM;
 564              	 .loc 1 383 0
 565 019c FF23     	 movs r3,#255
 566 019e 1BE0     	 b .L18
 567              	.L29:
 384:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 385:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 386:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* { empty or recyclable entry found } */
 387:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 388:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     etharp_free_entry(i);
 568              	 .loc 1 388 0
 569 01a0 3B7D     	 ldrb r3,[r7,#20]
 570 01a2 1846     	 mov r0,r3
 571 01a4 FFF7FEFF 	 bl etharp_free_entry
 572              	.L27:
 389:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 390:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 391:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 392:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 393:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].state == ETHARP_STATE_EMPTY);
 394:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 395:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* IP address given? */
 396:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ipaddr != NULL) {
 573              	 .loc 1 396 0
 574 01a8 7B68     	 ldr r3,[r7,#4]
 575 01aa 002B     	 cmp r3,#0
 576 01ac 09D0     	 beq .L32
 397:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* set IP address */
 398:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 577              	 .loc 1 398 0
 578 01ae 3A7D     	 ldrb r2,[r7,#20]
 579 01b0 7B68     	 ldr r3,[r7,#4]
 580 01b2 1968     	 ldr r1,[r3]
 581 01b4 0B48     	 ldr r0,.L33
 582 01b6 1346     	 mov r3,r2
 583 01b8 9B00     	 lsls r3,r3,#2
 584 01ba 1344     	 add r3,r3,r2
 585 01bc 9B00     	 lsls r3,r3,#2
 586 01be 0344     	 add r3,r3,r0
 587 01c0 5960     	 str r1,[r3,#4]
 588              	.L32:
 399:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 400:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].ctime = 0;
 589              	 .loc 1 400 0
 590 01c2 3A7D     	 ldrb r2,[r7,#20]
 591 01c4 0749     	 ldr r1,.L33
 592 01c6 1346     	 mov r3,r2
 593 01c8 9B00     	 lsls r3,r3,#2
 594 01ca 1344     	 add r3,r3,r2
 595 01cc 9B00     	 lsls r3,r3,#2
 596 01ce 0B44     	 add r3,r3,r1
 597 01d0 1033     	 adds r3,r3,#16
 598 01d2 0022     	 movs r2,#0
 599 01d4 DA70     	 strb r2,[r3,#3]
 401:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return (err_t)i;
 600              	 .loc 1 401 0
 601 01d6 3B7D     	 ldrb r3,[r7,#20]
 602              	.L18:
 603 01d8 5BB2     	 sxtb r3,r3
 402:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 604              	 .loc 1 402 0
 605 01da 1846     	 mov r0,r3
 606 01dc 1837     	 adds r7,r7,#24
 607              	.LCFI13:
 608              	 .cfi_def_cfa_offset 8
 609 01de BD46     	 mov sp,r7
 610              	.LCFI14:
 611              	 .cfi_def_cfa_register 13
 612              	 
 613 01e0 80BD     	 pop {r7,pc}
 614              	.L34:
 615 01e2 00BF     	 .align 2
 616              	.L33:
 617 01e4 00000000 	 .word arp_table
 618              	 .cfi_endproc
 619              	.LFE130:
 621              	 .section .text.etharp_send_ip,"ax",%progbits
 622              	 .align 2
 623              	 .thumb
 624              	 .thumb_func
 626              	etharp_send_ip:
 627              	.LFB131:
 403:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 404:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 405:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Send an IP packet on the network using netif->linkoutput
 406:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * The ethernet header is filled in before sending.
 407:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 408:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @params netif the lwIP network interface on which to send the packet
 409:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @params p the packet to send, p->payload pointing to the (uninitialized) ethernet header
 410:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @params src the source MAC address to be copied into the ethernet header
 411:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @params dst the destination MAC address to be copied into the ethernet header
 412:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return ERR_OK if the packet was sent, any other err_t on failure
 413:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 414:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static err_t
 415:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
 416:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 628              	 .loc 1 416 0
 629              	 .cfi_startproc
 630              	 
 631              	 
 632 0000 80B5     	 push {r7,lr}
 633              	.LCFI15:
 634              	 .cfi_def_cfa_offset 8
 635              	 .cfi_offset 7,-8
 636              	 .cfi_offset 14,-4
 637 0002 86B0     	 sub sp,sp,#24
 638              	.LCFI16:
 639              	 .cfi_def_cfa_offset 32
 640 0004 00AF     	 add r7,sp,#0
 641              	.LCFI17:
 642              	 .cfi_def_cfa_register 7
 643 0006 F860     	 str r0,[r7,#12]
 644 0008 B960     	 str r1,[r7,#8]
 645 000a 7A60     	 str r2,[r7,#4]
 646 000c 3B60     	 str r3,[r7]
 417:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 647              	 .loc 1 417 0
 648 000e BB68     	 ldr r3,[r7,#8]
 649 0010 5B68     	 ldr r3,[r3,#4]
 650 0012 7B61     	 str r3,[r7,#20]
 418:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 419:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 420:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****               (netif->hwaddr_len == ETHARP_HWADDR_LEN));
 421:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR32_COPY(&ethhdr->dest, dst);
 651              	 .loc 1 421 0
 652 0014 7B69     	 ldr r3,[r7,#20]
 653 0016 0233     	 adds r3,r3,#2
 654 0018 1846     	 mov r0,r3
 655 001a 3968     	 ldr r1,[r7]
 656 001c 0622     	 movs r2,#6
 657 001e FFF7FEFF 	 bl thumb2_memcpy
 422:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->src, src);
 658              	 .loc 1 422 0
 659 0022 7B69     	 ldr r3,[r7,#20]
 660 0024 0833     	 adds r3,r3,#8
 661 0026 1846     	 mov r0,r3
 662 0028 7968     	 ldr r1,[r7,#4]
 663 002a 0622     	 movs r2,#6
 664 002c FFF7FEFF 	 bl thumb2_memcpy
 423:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr->type = PP_HTONS(ETHTYPE_IP);
 665              	 .loc 1 423 0
 666 0030 7B69     	 ldr r3,[r7,#20]
 667 0032 0022     	 movs r2,#0
 668 0034 42F00802 	 orr r2,r2,#8
 669 0038 9A73     	 strb r2,[r3,#14]
 670 003a 0022     	 movs r2,#0
 671 003c DA73     	 strb r2,[r3,#15]
 424:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
 425:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* send the packet */
 426:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return netif->linkoutput(netif, p);
 672              	 .loc 1 426 0
 673 003e FB68     	 ldr r3,[r7,#12]
 674 0040 9B69     	 ldr r3,[r3,#24]
 675 0042 F868     	 ldr r0,[r7,#12]
 676 0044 B968     	 ldr r1,[r7,#8]
 677 0046 9847     	 blx r3
 678 0048 0346     	 mov r3,r0
 427:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 679              	 .loc 1 427 0
 680 004a 1846     	 mov r0,r3
 681 004c 1837     	 adds r7,r7,#24
 682              	.LCFI18:
 683              	 .cfi_def_cfa_offset 8
 684 004e BD46     	 mov sp,r7
 685              	.LCFI19:
 686              	 .cfi_def_cfa_register 13
 687              	 
 688 0050 80BD     	 pop {r7,pc}
 689              	 .cfi_endproc
 690              	.LFE131:
 692 0052 00BF     	 .section .text.etharp_update_arp_entry,"ax",%progbits
 693              	 .align 2
 694              	 .thumb
 695              	 .thumb_func
 697              	etharp_update_arp_entry:
 698              	.LFB132:
 428:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 429:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 430:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Update (or insert) a IP/MAC address pair in the ARP cache.
 431:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 432:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If a pending entry is resolved, any queued packets will be sent
 433:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * at this point.
 434:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 435:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif netif related to this entry (used for NETIF_ADDRHINT)
 436:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr IP address of the inserted ARP entry.
 437:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ethaddr Ethernet address of the inserted ARP entry.
 438:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param flags @see definition of ETHARP_FLAG_*
 439:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 440:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return
 441:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_OK Succesfully updated ARP cache.
 442:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_MEM If we could not add a new ARP entry when ETHARP_FLAG_TRY_HARD was set.
 443:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 444:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 445:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @see pbuf_free()
 446:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 447:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static err_t
 448:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flag
 449:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 699              	 .loc 1 449 0
 700              	 .cfi_startproc
 701              	 
 702              	 
 703 0000 80B5     	 push {r7,lr}
 704              	.LCFI20:
 705              	 .cfi_def_cfa_offset 8
 706              	 .cfi_offset 7,-8
 707              	 .cfi_offset 14,-4
 708 0002 86B0     	 sub sp,sp,#24
 709              	.LCFI21:
 710              	 .cfi_def_cfa_offset 32
 711 0004 00AF     	 add r7,sp,#0
 712              	.LCFI22:
 713              	 .cfi_def_cfa_register 7
 714 0006 F860     	 str r0,[r7,#12]
 715 0008 B960     	 str r1,[r7,#8]
 716 000a 7A60     	 str r2,[r7,#4]
 717 000c FB70     	 strb r3,[r7,#3]
 450:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t i;
 451:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 452:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 453:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
 454:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 455:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 456:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* non-unicast address? */
 457:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ip_addr_isany(ipaddr) ||
 718              	 .loc 1 457 0
 719 000e BB68     	 ldr r3,[r7,#8]
 720 0010 002B     	 cmp r3,#0
 721 0012 12D0     	 beq .L38
 722              	 .loc 1 457 0 is_stmt 0 discriminator 1
 723 0014 BB68     	 ldr r3,[r7,#8]
 724 0016 1B68     	 ldr r3,[r3]
 725 0018 002B     	 cmp r3,#0
 726 001a 0ED0     	 beq .L38
 458:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 727              	 .loc 1 458 0 is_stmt 1 discriminator 2
 728 001c BB68     	 ldr r3,[r7,#8]
 729 001e 1B68     	 ldr r3,[r3]
 730 0020 1846     	 mov r0,r3
 731 0022 F968     	 ldr r1,[r7,#12]
 732 0024 FFF7FEFF 	 bl ip4_addr_isbroadcast
 733 0028 0346     	 mov r3,r0
 457:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 734              	 .loc 1 457 0 discriminator 2
 735 002a 002B     	 cmp r3,#0
 736 002c 05D1     	 bne .L38
 459:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_ismulticast(ipaddr)) {
 737              	 .loc 1 459 0
 738 002e BB68     	 ldr r3,[r7,#8]
 739 0030 1B68     	 ldr r3,[r3]
 740 0032 03F0F003 	 and r3,r3,#240
 458:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_isbroadcast(ipaddr, netif) ||
 741              	 .loc 1 458 0
 742 0036 E02B     	 cmp r3,#224
 743 0038 01D1     	 bne .L39
 744              	.L38:
 460:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast 
 461:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_ARG;
 745              	 .loc 1 461 0
 746 003a F223     	 movs r3,#242
 747 003c 67E0     	 b .L40
 748              	.L39:
 462:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 463:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* find or create ARP entry */
 464:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   i = etharp_find_entry(ipaddr, flags);
 749              	 .loc 1 464 0
 750 003e FB78     	 ldrb r3,[r7,#3]
 751 0040 B868     	 ldr r0,[r7,#8]
 752 0042 1946     	 mov r1,r3
 753 0044 FFF7FEFF 	 bl etharp_find_entry
 754 0048 0346     	 mov r3,r0
 755 004a FB75     	 strb r3,[r7,#23]
 465:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* bail out if no entry could be found */
 466:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (i < 0) {
 756              	 .loc 1 466 0
 757 004c 97F91730 	 ldrsb r3,[r7,#23]
 758 0050 002B     	 cmp r3,#0
 759 0052 01DA     	 bge .L41
 467:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return (err_t)i;
 760              	 .loc 1 467 0
 761 0054 FB7D     	 ldrb r3,[r7,#23]
 762 0056 5AE0     	 b .L40
 763              	.L41:
 468:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 469:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 470:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 471:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 472:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* record static type */
 473:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_STATIC;
 474:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else
 475:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 476:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   {
 477:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* mark it stable */
 478:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_STABLE;
 764              	 .loc 1 478 0
 765 0058 97F91720 	 ldrsb r2,[r7,#23]
 766 005c 2E49     	 ldr r1,.L43
 767 005e 1346     	 mov r3,r2
 768 0060 9B00     	 lsls r3,r3,#2
 769 0062 1344     	 add r3,r3,r2
 770 0064 9B00     	 lsls r3,r3,#2
 771 0066 0B44     	 add r3,r3,r1
 772 0068 1033     	 adds r3,r3,#16
 773 006a 0222     	 movs r2,#2
 774 006c 9A70     	 strb r2,[r3,#2]
 479:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 480:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 481:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* record network interface */
 482:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].netif = netif;
 775              	 .loc 1 482 0
 776 006e 97F91720 	 ldrsb r2,[r7,#23]
 777 0072 2949     	 ldr r1,.L43
 778 0074 1346     	 mov r3,r2
 779 0076 9B00     	 lsls r3,r3,#2
 780 0078 1344     	 add r3,r3,r2
 781 007a 9B00     	 lsls r3,r3,#2
 782 007c 0B44     	 add r3,r3,r1
 783 007e 0833     	 adds r3,r3,#8
 784 0080 FA68     	 ldr r2,[r7,#12]
 785 0082 1A60     	 str r2,[r3]
 483:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* insert in SNMP ARP index tree */
 484:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
 485:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 486:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16
 487:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* update address */
 488:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 786              	 .loc 1 488 0
 787 0084 97F91720 	 ldrsb r2,[r7,#23]
 788 0088 1346     	 mov r3,r2
 789 008a 9B00     	 lsls r3,r3,#2
 790 008c 1344     	 add r3,r3,r2
 791 008e 9B00     	 lsls r3,r3,#2
 792 0090 0833     	 adds r3,r3,#8
 793 0092 214A     	 ldr r2,.L43
 794 0094 1344     	 add r3,r3,r2
 795 0096 0433     	 adds r3,r3,#4
 796 0098 1846     	 mov r0,r3
 797 009a 7968     	 ldr r1,[r7,#4]
 798 009c 0622     	 movs r2,#6
 799 009e FFF7FEFF 	 bl thumb2_memcpy
 489:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* reset time stamp */
 490:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   arp_table[i].ctime = 0;
 800              	 .loc 1 490 0
 801 00a2 97F91720 	 ldrsb r2,[r7,#23]
 802 00a6 1C49     	 ldr r1,.L43
 803 00a8 1346     	 mov r3,r2
 804 00aa 9B00     	 lsls r3,r3,#2
 805 00ac 1344     	 add r3,r3,r2
 806 00ae 9B00     	 lsls r3,r3,#2
 807 00b0 0B44     	 add r3,r3,r1
 808 00b2 1033     	 adds r3,r3,#16
 809 00b4 0022     	 movs r2,#0
 810 00b6 DA70     	 strb r2,[r3,#3]
 491:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* this is where we will send out queued packets! */
 492:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ARP_QUEUEING
 493:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   while (arp_table[i].q != NULL) {
 494:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     struct pbuf *p;
 495:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* remember remainder of queue */
 496:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     struct etharp_q_entry *q = arp_table[i].q;
 497:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* pop first item off the queue */
 498:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].q = q->next;
 499:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* get the packet pointer */
 500:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     p = q->p;
 501:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* now queue entry can be freed */
 502:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     memp_free(MEMP_ARP_QUEUE, q);
 503:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else /* ARP_QUEUEING */
 504:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (arp_table[i].q != NULL) {
 811              	 .loc 1 504 0
 812 00b8 97F91720 	 ldrsb r2,[r7,#23]
 813 00bc 1649     	 ldr r1,.L43
 814 00be 1346     	 mov r3,r2
 815 00c0 9B00     	 lsls r3,r3,#2
 816 00c2 1344     	 add r3,r3,r2
 817 00c4 9B00     	 lsls r3,r3,#2
 818 00c6 0B44     	 add r3,r3,r1
 819 00c8 1B68     	 ldr r3,[r3]
 820 00ca 002B     	 cmp r3,#0
 821 00cc 1ED0     	 beq .L42
 822              	.LBB4:
 505:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     struct pbuf *p = arp_table[i].q;
 823              	 .loc 1 505 0
 824 00ce 97F91720 	 ldrsb r2,[r7,#23]
 825 00d2 1149     	 ldr r1,.L43
 826 00d4 1346     	 mov r3,r2
 827 00d6 9B00     	 lsls r3,r3,#2
 828 00d8 1344     	 add r3,r3,r2
 829 00da 9B00     	 lsls r3,r3,#2
 830 00dc 0B44     	 add r3,r3,r1
 831 00de 1B68     	 ldr r3,[r3]
 832 00e0 3B61     	 str r3,[r7,#16]
 506:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].q = NULL;
 833              	 .loc 1 506 0
 834 00e2 97F91720 	 ldrsb r2,[r7,#23]
 835 00e6 0C49     	 ldr r1,.L43
 836 00e8 1346     	 mov r3,r2
 837 00ea 9B00     	 lsls r3,r3,#2
 838 00ec 1344     	 add r3,r3,r2
 839 00ee 9B00     	 lsls r3,r3,#2
 840 00f0 0B44     	 add r3,r3,r1
 841 00f2 0022     	 movs r2,#0
 842 00f4 1A60     	 str r2,[r3]
 507:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ARP_QUEUEING */
 508:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* send the queued IP packet */
 509:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 843              	 .loc 1 509 0
 844 00f6 FB68     	 ldr r3,[r7,#12]
 845 00f8 2733     	 adds r3,r3,#39
 846 00fa F868     	 ldr r0,[r7,#12]
 847 00fc 3969     	 ldr r1,[r7,#16]
 848 00fe 1A46     	 mov r2,r3
 849 0100 7B68     	 ldr r3,[r7,#4]
 850 0102 FFF7FEFF 	 bl etharp_send_ip
 510:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* free the queued IP packet */
 511:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     pbuf_free(p);
 851              	 .loc 1 511 0
 852 0106 3869     	 ldr r0,[r7,#16]
 853 0108 FFF7FEFF 	 bl pbuf_free
 854              	.L42:
 855              	.LBE4:
 512:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 513:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return ERR_OK;
 856              	 .loc 1 513 0
 857 010c 0023     	 movs r3,#0
 858              	.L40:
 859 010e 5BB2     	 sxtb r3,r3
 514:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 860              	 .loc 1 514 0
 861 0110 1846     	 mov r0,r3
 862 0112 1837     	 adds r7,r7,#24
 863              	.LCFI23:
 864              	 .cfi_def_cfa_offset 8
 865 0114 BD46     	 mov sp,r7
 866              	.LCFI24:
 867              	 .cfi_def_cfa_register 13
 868              	 
 869 0116 80BD     	 pop {r7,pc}
 870              	.L44:
 871              	 .align 2
 872              	.L43:
 873 0118 00000000 	 .word arp_table
 874              	 .cfi_endproc
 875              	.LFE132:
 877              	 .section .text.etharp_cleanup_netif,"ax",%progbits
 878              	 .align 2
 879              	 .global etharp_cleanup_netif
 880              	 .thumb
 881              	 .thumb_func
 883              	etharp_cleanup_netif:
 884              	.LFB133:
 515:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 516:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 517:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Add a new static entry to the ARP table. If an entry exists for the
 518:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * specified IP address, this entry is overwritten.
 519:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If packets are queued for the specified IP address, they are sent out.
 520:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 521:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr IP address for the new static entry
 522:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ethaddr ethernet address for the new static entry
 523:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return @see return values of etharp_add_static_entry
 524:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 525:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
 526:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_add_static_entry(ip_addr_t *ipaddr, struct eth_addr *ethaddr)
 527:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 528:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct netif *netif;
 529:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_add_static_entry: %"U16_F".%"U16_F".%"U16_F".
 530:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
 531:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 532:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 533:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 534:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   netif = ip_route(ipaddr);
 535:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (netif == NULL) {
 536:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_RTE;
 537:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 538:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 539:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return etharp_update_arp_entry(netif, ipaddr, ethaddr, ETHARP_FLAG_TRY_HARD | ETHARP_FLAG_STATIC_
 540:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 541:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 542:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Remove a static entry from the ARP table previously added with a call to
 543:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * etharp_add_static_entry.
 544:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 545:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr IP address of the static entry to remove
 546:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return ERR_OK: entry removed
 547:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         ERR_MEM: entry wasn't found
 548:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         ERR_ARG: entry wasn't a static entry but a dynamic one
 549:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 550:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
 551:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_remove_static_entry(ip_addr_t *ipaddr)
 552:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 553:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t i;
 554:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_remove_static_entry: %"U16_F".%"U16_F".%"U16_
 555:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
 556:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 557:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* find or create ARP entry */
 558:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 559:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* bail out if no entry could be found */
 560:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (i < 0) {
 561:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return (err_t)i;
 562:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 563:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 564:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (arp_table[i].state != ETHARP_STATE_STATIC) {
 565:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* entry wasn't a static entry, cannot remove it */
 566:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_ARG;
 567:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 568:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* entry found, free it */
 569:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   etharp_free_entry(i);
 570:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return ERR_OK;
 571:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 572:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 573:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 574:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 575:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Remove all ARP table entries of the specified netif.
 576:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 577:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif points to a network interface
 578:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 579:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** void etharp_cleanup_netif(struct netif *netif)
 580:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 885              	 .loc 1 580 0
 886              	 .cfi_startproc
 887              	 
 888              	 
 889 0000 80B5     	 push {r7,lr}
 890              	.LCFI25:
 891              	 .cfi_def_cfa_offset 8
 892              	 .cfi_offset 7,-8
 893              	 .cfi_offset 14,-4
 894 0002 84B0     	 sub sp,sp,#16
 895              	.LCFI26:
 896              	 .cfi_def_cfa_offset 24
 897 0004 00AF     	 add r7,sp,#0
 898              	.LCFI27:
 899              	 .cfi_def_cfa_register 7
 900 0006 7860     	 str r0,[r7,#4]
 581:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t i;
 582:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 583:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 901              	 .loc 1 583 0
 902 0008 0023     	 movs r3,#0
 903 000a FB73     	 strb r3,[r7,#15]
 904 000c 1FE0     	 b .L46
 905              	.L48:
 906              	.LBB5:
 584:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 907              	 .loc 1 584 0
 908 000e FA7B     	 ldrb r2,[r7,#15]
 909 0010 1249     	 ldr r1,.L49
 910 0012 1346     	 mov r3,r2
 911 0014 9B00     	 lsls r3,r3,#2
 912 0016 1344     	 add r3,r3,r2
 913 0018 9B00     	 lsls r3,r3,#2
 914 001a 0B44     	 add r3,r3,r1
 915 001c 1033     	 adds r3,r3,#16
 916 001e 9B78     	 ldrb r3,[r3,#2]
 917 0020 BB73     	 strb r3,[r7,#14]
 585:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 918              	 .loc 1 585 0
 919 0022 BB7B     	 ldrb r3,[r7,#14]
 920 0024 002B     	 cmp r3,#0
 921 0026 0FD0     	 beq .L47
 922              	 .loc 1 585 0 is_stmt 0 discriminator 1
 923 0028 FA7B     	 ldrb r2,[r7,#15]
 924 002a 0C49     	 ldr r1,.L49
 925 002c 1346     	 mov r3,r2
 926 002e 9B00     	 lsls r3,r3,#2
 927 0030 1344     	 add r3,r3,r2
 928 0032 9B00     	 lsls r3,r3,#2
 929 0034 0B44     	 add r3,r3,r1
 930 0036 0833     	 adds r3,r3,#8
 931 0038 1A68     	 ldr r2,[r3]
 932 003a 7B68     	 ldr r3,[r7,#4]
 933 003c 9A42     	 cmp r2,r3
 934 003e 03D1     	 bne .L47
 586:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       etharp_free_entry(i);
 935              	 .loc 1 586 0 is_stmt 1
 936 0040 FB7B     	 ldrb r3,[r7,#15]
 937 0042 1846     	 mov r0,r3
 938 0044 FFF7FEFF 	 bl etharp_free_entry
 939              	.L47:
 940              	.LBE5:
 583:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 941              	 .loc 1 583 0 discriminator 2
 942 0048 FB7B     	 ldrb r3,[r7,#15]
 943 004a 0133     	 adds r3,r3,#1
 944 004c FB73     	 strb r3,[r7,#15]
 945              	.L46:
 583:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     u8_t state = arp_table[i].state;
 946              	 .loc 1 583 0 is_stmt 0 discriminator 1
 947 004e FB7B     	 ldrb r3,[r7,#15]
 948 0050 092B     	 cmp r3,#9
 949 0052 DCD9     	 bls .L48
 587:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 588:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 589:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 950              	 .loc 1 589 0 is_stmt 1
 951 0054 1037     	 adds r7,r7,#16
 952              	.LCFI28:
 953              	 .cfi_def_cfa_offset 8
 954 0056 BD46     	 mov sp,r7
 955              	.LCFI29:
 956              	 .cfi_def_cfa_register 13
 957              	 
 958 0058 80BD     	 pop {r7,pc}
 959              	.L50:
 960 005a 00BF     	 .align 2
 961              	.L49:
 962 005c 00000000 	 .word arp_table
 963              	 .cfi_endproc
 964              	.LFE133:
 966              	 .section .text.etharp_find_addr,"ax",%progbits
 967              	 .align 2
 968              	 .global etharp_find_addr
 969              	 .thumb
 970              	 .thumb_func
 972              	etharp_find_addr:
 973              	.LFB134:
 590:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 591:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 592:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Finds (stable) ethernet/IP address pair from ARP table
 593:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * using interface and IP address index.
 594:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @note the addresses in the ARP table are in network order!
 595:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 596:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif points to interface index
 597:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr points to the (network order) IP address index
 598:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param eth_ret points to return pointer
 599:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ip_ret points to return pointer
 600:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return table index if found, -1 otherwise
 601:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 602:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** s8_t
 603:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
 604:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          struct eth_addr **eth_ret, ip_addr_t **ip_ret)
 605:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 974              	 .loc 1 605 0
 975              	 .cfi_startproc
 976              	 
 977              	 
 978 0000 80B5     	 push {r7,lr}
 979              	.LCFI30:
 980              	 .cfi_def_cfa_offset 8
 981              	 .cfi_offset 7,-8
 982              	 .cfi_offset 14,-4
 983 0002 86B0     	 sub sp,sp,#24
 984              	.LCFI31:
 985              	 .cfi_def_cfa_offset 32
 986 0004 00AF     	 add r7,sp,#0
 987              	.LCFI32:
 988              	 .cfi_def_cfa_register 7
 989 0006 F860     	 str r0,[r7,#12]
 990 0008 B960     	 str r1,[r7,#8]
 991 000a 7A60     	 str r2,[r7,#4]
 992 000c 3B60     	 str r3,[r7]
 606:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t i;
 607:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 608:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
 609:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     eth_ret != NULL && ip_ret != NULL);
 610:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 611:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_UNUSED_ARG(netif);
 612:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 613:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 993              	 .loc 1 613 0
 994 000e B868     	 ldr r0,[r7,#8]
 995 0010 0221     	 movs r1,#2
 996 0012 FFF7FEFF 	 bl etharp_find_entry
 997 0016 0346     	 mov r3,r0
 998 0018 FB75     	 strb r3,[r7,#23]
 614:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 999              	 .loc 1 614 0
 1000 001a 97F91730 	 ldrsb r3,[r7,#23]
 1001 001e 002B     	 cmp r3,#0
 1002 0020 24DB     	 blt .L52
 1003              	 .loc 1 614 0 is_stmt 0 discriminator 1
 1004 0022 97F91720 	 ldrsb r2,[r7,#23]
 1005 0026 1449     	 ldr r1,.L54
 1006 0028 1346     	 mov r3,r2
 1007 002a 9B00     	 lsls r3,r3,#2
 1008 002c 1344     	 add r3,r3,r2
 1009 002e 9B00     	 lsls r3,r3,#2
 1010 0030 0B44     	 add r3,r3,r1
 1011 0032 1033     	 adds r3,r3,#16
 1012 0034 9B78     	 ldrb r3,[r3,#2]
 1013 0036 012B     	 cmp r3,#1
 1014 0038 18D9     	 bls .L52
 615:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       *eth_ret = &arp_table[i].ethaddr;
 1015              	 .loc 1 615 0 is_stmt 1
 1016 003a 97F91720 	 ldrsb r2,[r7,#23]
 1017 003e 1346     	 mov r3,r2
 1018 0040 9B00     	 lsls r3,r3,#2
 1019 0042 1344     	 add r3,r3,r2
 1020 0044 9B00     	 lsls r3,r3,#2
 1021 0046 0833     	 adds r3,r3,#8
 1022 0048 0B4A     	 ldr r2,.L54
 1023 004a 1344     	 add r3,r3,r2
 1024 004c 1A1D     	 adds r2,r3,#4
 1025 004e 7B68     	 ldr r3,[r7,#4]
 1026 0050 1A60     	 str r2,[r3]
 616:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       *ip_ret = &arp_table[i].ipaddr;
 1027              	 .loc 1 616 0
 1028 0052 97F91720 	 ldrsb r2,[r7,#23]
 1029 0056 1346     	 mov r3,r2
 1030 0058 9B00     	 lsls r3,r3,#2
 1031 005a 1344     	 add r3,r3,r2
 1032 005c 9B00     	 lsls r3,r3,#2
 1033 005e 064A     	 ldr r2,.L54
 1034 0060 1344     	 add r3,r3,r2
 1035 0062 1A1D     	 adds r2,r3,#4
 1036 0064 3B68     	 ldr r3,[r7]
 1037 0066 1A60     	 str r2,[r3]
 617:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       return i;
 1038              	 .loc 1 617 0
 1039 0068 FB7D     	 ldrb r3,[r7,#23]
 1040 006a 00E0     	 b .L53
 1041              	.L52:
 618:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 619:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return -1;
 1042              	 .loc 1 619 0
 1043 006c FF23     	 movs r3,#255
 1044              	.L53:
 1045 006e 5BB2     	 sxtb r3,r3
 620:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 1046              	 .loc 1 620 0
 1047 0070 1846     	 mov r0,r3
 1048 0072 1837     	 adds r7,r7,#24
 1049              	.LCFI33:
 1050              	 .cfi_def_cfa_offset 8
 1051 0074 BD46     	 mov sp,r7
 1052              	.LCFI34:
 1053              	 .cfi_def_cfa_register 13
 1054              	 
 1055 0076 80BD     	 pop {r7,pc}
 1056              	.L55:
 1057              	 .align 2
 1058              	.L54:
 1059 0078 00000000 	 .word arp_table
 1060              	 .cfi_endproc
 1061              	.LFE134:
 1063              	 .section .text.etharp_arp_input,"ax",%progbits
 1064              	 .align 2
 1065              	 .thumb
 1066              	 .thumb_func
 1068              	etharp_arp_input:
 1069              	.LFB135:
 621:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 622:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_TRUST_IP_MAC
 623:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 624:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Updates the ARP table using the given IP packet.
 625:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 626:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Uses the incoming IP packet's source address to update the
 627:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * ARP cache for the local network. The function does not alter
 628:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * or free the packet. This function must be called before the
 629:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * packet p is passed to the IP layer.
 630:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 631:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif The lwIP network interface on which the IP packet pbuf arrived.
 632:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param p The IP packet that arrived on netif.
 633:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 634:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return NULL
 635:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 636:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @see pbuf_free()
 637:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 638:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static void
 639:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_ip_input(struct netif *netif, struct pbuf *p)
 640:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 641:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_hdr *ethhdr;
 642:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct ip_hdr *iphdr;
 643:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_t iphdr_src;
 644:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 645:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 646:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Only insert an entry if the source IP address of the
 647:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      incoming IP packet comes from a host on the local network. */
 648:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 649:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 650:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
 651:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
 652:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
 653:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 654:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
 655:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 656:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_copy(iphdr_src, iphdr->src);
 657:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 658:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* source is not on the local network? */
 659:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 660:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* do nothing */
 661:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return;
 662:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 663:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 664:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
 665:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* update the source IP address in the cache, if present */
 666:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
 667:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * back soon (for example, if the destination IP address is ours. */
 668:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
 669:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 670:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_TRUST_IP_MAC */
 671:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 672:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 673:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache  
 674:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * send out queued IP packets. Updates cache with snooped address pairs.
 675:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 676:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Should be called for incoming ARP packets. The pbuf in the argument
 677:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * is freed by this function.
 678:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 679:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 680:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ethaddr Ethernet address of netif.
 681:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param p The ARP packet that arrived on netif. Is freed by this function.
 682:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 683:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return NULL
 684:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 685:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @see pbuf_free()
 686:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 687:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static void
 688:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
 689:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 1070              	 .loc 1 689 0
 1071              	 .cfi_startproc
 1072              	 
 1073              	 
 1074 0000 80B5     	 push {r7,lr}
 1075              	.LCFI35:
 1076              	 .cfi_def_cfa_offset 8
 1077              	 .cfi_offset 7,-8
 1078              	 .cfi_offset 14,-4
 1079 0002 8AB0     	 sub sp,sp,#40
 1080              	.LCFI36:
 1081              	 .cfi_def_cfa_offset 48
 1082 0004 00AF     	 add r7,sp,#0
 1083              	.LCFI37:
 1084              	 .cfi_def_cfa_register 7
 1085 0006 F860     	 str r0,[r7,#12]
 1086 0008 B960     	 str r1,[r7,#8]
 1087 000a 7A60     	 str r2,[r7,#4]
 690:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct etharp_hdr *hdr;
 691:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_hdr *ethhdr;
 692:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* these are aligned properly, whereas the ARP header fields might not be */
 693:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_t sipaddr, dipaddr;
 694:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u8_t for_us;
 695:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 696:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   const u8_t * ethdst_hwaddr;
 697:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 698:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 699:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 1088              	 .loc 1 699 0
 1089 000c FB68     	 ldr r3,[r7,#12]
 1090 000e 002B     	 cmp r3,#0
 1091 0010 01D1     	 bne .L57
 1092              	 .loc 1 699 0 is_stmt 0 discriminator 1
 1093              	
 1094 0012 00BE     	 bkpt 0
 1095              	
 1096              	 .thumb
 1097 0014 B3E0     	 b .L56
 1098              	.L57:
 700:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 701:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
 702:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
 703:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (p->len < SIZEOF_ETHARP_PACKET) {
 1099              	 .loc 1 703 0 is_stmt 1
 1100 0016 7B68     	 ldr r3,[r7,#4]
 1101 0018 5B89     	 ldrh r3,[r3,#10]
 1102 001a 2B2B     	 cmp r3,#43
 1103 001c 03D8     	 bhi .L59
 704:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
 705:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
 706:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (s16_t)SIZEOF_ETHARP_PACKET));
 707:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.lenerr);
 708:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 709:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     pbuf_free(p);
 1104              	 .loc 1 709 0
 1105 001e 7868     	 ldr r0,[r7,#4]
 1106 0020 FFF7FEFF 	 bl pbuf_free
 710:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return;
 1107              	 .loc 1 710 0
 1108 0024 ABE0     	 b .L56
 1109              	.L59:
 711:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 712:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 713:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 1110              	 .loc 1 713 0
 1111 0026 7B68     	 ldr r3,[r7,#4]
 1112 0028 5B68     	 ldr r3,[r3,#4]
 1113 002a 3B62     	 str r3,[r7,#32]
 714:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 1114              	 .loc 1 714 0
 1115 002c 3B6A     	 ldr r3,[r7,#32]
 1116 002e 1033     	 adds r3,r3,#16
 1117 0030 FB61     	 str r3,[r7,#28]
 715:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
 716:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
 717:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
 718:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 719:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
 720:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 721:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* RFC 826 "Packet Reception": */
 722:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 1118              	 .loc 1 722 0
 1119 0032 FB69     	 ldr r3,[r7,#28]
 1120 0034 1B88     	 ldrh r3,[r3]
 1121 0036 9BB2     	 uxth r3,r3
 1122 0038 B3F5807F 	 cmp r3,#256
 1123 003c 0CD1     	 bne .L60
 723:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1124              	 .loc 1 723 0 discriminator 1
 1125 003e FB69     	 ldr r3,[r7,#28]
 1126 0040 1B79     	 ldrb r3,[r3,#4]
 722:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1127              	 .loc 1 722 0 discriminator 1
 1128 0042 062B     	 cmp r3,#6
 1129 0044 08D1     	 bne .L60
 724:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->protolen != sizeof(ip_addr_t)) ||
 1130              	 .loc 1 724 0
 1131 0046 FB69     	 ldr r3,[r7,#28]
 1132 0048 5B79     	 ldrb r3,[r3,#5]
 723:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 1133              	 .loc 1 723 0
 1134 004a 042B     	 cmp r3,#4
 1135 004c 04D1     	 bne .L60
 725:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 1136              	 .loc 1 725 0
 1137 004e FB69     	 ldr r3,[r7,#28]
 1138 0050 5B88     	 ldrh r3,[r3,#2]
 1139 0052 9BB2     	 uxth r3,r3
 724:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (hdr->protolen != sizeof(ip_addr_t)) ||
 1140              	 .loc 1 724 0
 1141 0054 082B     	 cmp r3,#8
 1142 0056 03D0     	 beq .L61
 1143              	.L60:
 726:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
 727:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%
 728:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
 729:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.proterr);
 730:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 731:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     pbuf_free(p);
 1144              	 .loc 1 731 0
 1145 0058 7868     	 ldr r0,[r7,#4]
 1146 005a FFF7FEFF 	 bl pbuf_free
 732:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return;
 1147              	 .loc 1 732 0
 1148 005e 8EE0     	 b .L56
 1149              	.L61:
 733:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 734:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATS_INC(etharp.recv);
 735:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 736:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 737:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* We have to check if a host already has configured our random
 738:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * created link local address and continously check if there is
 739:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * a host with this IP-address so we can detect collisions */
 740:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   autoip_arp_reply(netif, hdr);
 741:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 742:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 743:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
 744:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * structure packing (not using structure copy which breaks strict-aliasing rules). */
 745:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 1150              	 .loc 1 745 0
 1151 0060 FB69     	 ldr r3,[r7,#28]
 1152 0062 0E33     	 adds r3,r3,#14
 1153 0064 07F11802 	 add r2,r7,#24
 1154 0068 1046     	 mov r0,r2
 1155 006a 1946     	 mov r1,r3
 1156 006c 0422     	 movs r2,#4
 1157 006e FFF7FEFF 	 bl thumb2_memcpy
 746:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 1158              	 .loc 1 746 0
 1159 0072 FB69     	 ldr r3,[r7,#28]
 1160 0074 1833     	 adds r3,r3,#24
 1161 0076 07F11402 	 add r2,r7,#20
 1162 007a 1046     	 mov r0,r2
 1163 007c 1946     	 mov r1,r3
 1164 007e 0422     	 movs r2,#4
 1165 0080 FFF7FEFF 	 bl thumb2_memcpy
 747:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 748:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* this interface is not configured? */
 749:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ip_addr_isany(&netif->ip_addr)) {
 1166              	 .loc 1 749 0
 1167 0084 FB68     	 ldr r3,[r7,#12]
 1168 0086 0433     	 adds r3,r3,#4
 1169 0088 002B     	 cmp r3,#0
 1170 008a 03D0     	 beq .L62
 1171              	 .loc 1 749 0 is_stmt 0 discriminator 1
 1172 008c FB68     	 ldr r3,[r7,#12]
 1173 008e 5B68     	 ldr r3,[r3,#4]
 1174 0090 002B     	 cmp r3,#0
 1175 0092 03D1     	 bne .L63
 1176              	.L62:
 750:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     for_us = 0;
 1177              	 .loc 1 750 0 is_stmt 1
 1178 0094 0023     	 movs r3,#0
 1179 0096 87F82730 	 strb r3,[r7,#39]
 1180 009a 09E0     	 b .L64
 1181              	.L63:
 751:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else {
 752:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* ARP packet directed to us? */
 753:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 1182              	 .loc 1 753 0
 1183 009c 7A69     	 ldr r2,[r7,#20]
 1184 009e FB68     	 ldr r3,[r7,#12]
 1185 00a0 5B68     	 ldr r3,[r3,#4]
 1186 00a2 9A42     	 cmp r2,r3
 1187 00a4 0CBF     	 ite eq
 1188 00a6 0123     	 moveq r3,#1
 1189 00a8 0023     	 movne r3,#0
 1190 00aa DBB2     	 uxtb r3,r3
 1191 00ac 87F82730 	 strb r3,[r7,#39]
 1192              	.L64:
 754:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 755:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 756:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* ARP message directed to us?
 757:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       -> add IP address in ARP cache; assume requester wants to talk to us,
 758:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          can result in directly sending the queued packets for this host.
 759:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      ARP message not directed to us?
 760:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ->  update the source IP address in the cache, if present */
 761:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 1193              	 .loc 1 761 0
 1194 00b0 FB69     	 ldr r3,[r7,#28]
 1195 00b2 03F10802 	 add r2,r3,#8
 1196 00b6 97F82730 	 ldrb r3,[r7,#39]
 1197 00ba 002B     	 cmp r3,#0
 1198 00bc 01D0     	 beq .L65
 1199              	 .loc 1 761 0 is_stmt 0 discriminator 1
 1200 00be 0123     	 movs r3,#1
 1201 00c0 00E0     	 b .L66
 1202              	.L65:
 1203              	 .loc 1 761 0 discriminator 2
 1204 00c2 0223     	 movs r3,#2
 1205              	.L66:
 1206              	 .loc 1 761 0 discriminator 4
 1207 00c4 07F11801 	 add r1,r7,#24
 1208 00c8 F868     	 ldr r0,[r7,#12]
 1209 00ca FFF7FEFF 	 bl etharp_update_arp_entry
 762:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                    for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
 763:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 764:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* now act on the message itself */
 765:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   switch (hdr->opcode) {
 1210              	 .loc 1 765 0 is_stmt 1 discriminator 4
 1211 00ce FB69     	 ldr r3,[r7,#28]
 1212 00d0 DB88     	 ldrh r3,[r3,#6]
 1213 00d2 9BB2     	 uxth r3,r3
 1214 00d4 B3F5807F 	 cmp r3,#256
 1215 00d8 03D0     	 beq .L68
 1216 00da B3F5007F 	 cmp r3,#512
 1217 00de 4AD0     	 beq .L74
 766:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* ARP request? */
 767:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   case PP_HTONS(ARP_REQUEST):
 768:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* ARP request. If it asked for our address, we send out a
 769:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * reply. In any case, we time-stamp any existing ARP entry,
 770:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * and possiby send out an IP packet that was queued on it. */
 771:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 772:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
 773:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* ARP request for our address? */
 774:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (for_us) {
 775:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 776:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for ou
 777:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* Re-use pbuf to send ARP reply.
 778:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          Since we are re-using an existing pbuf, we can't call etharp_raw since
 779:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          that would allocate a new pbuf. */
 780:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       hdr->opcode = htons(ARP_REPLY);
 781:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 782:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 783:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 784:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 785:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 786:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                   (netif->hwaddr_len == ETHARP_HWADDR_LEN));
 787:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 788:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* If we are using Link-Local, all ARP packets that contain a Link-Local
 789:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****        * 'sender IP address' MUST be sent using link-layer broadcast instead of
 790:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****        * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
 791:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwa
 792:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 793:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 794:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 795:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 796:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
 797:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else  /* LWIP_AUTOIP */
 798:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 799:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 800:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 801:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->src, ethaddr);
 802:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 803:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
 804:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          are already correct, we tested that before */
 805:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 806:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* return ARP reply */
 807:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       netif->linkoutput(netif, p);
 808:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* we are not configured? */
 809:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else if (ip_addr_isany(&netif->ip_addr)) {
 810:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* { for_us == 0 and netif->ip_addr.addr == 0 } */
 811:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP reque
 812:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* request was not directed to us */
 813:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else {
 814:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* { for_us == 0 and netif->ip_addr.addr != 0 } */
 815:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"
 816:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 817:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     break;
 818:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   case PP_HTONS(ARP_REPLY):
 819:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* ARP reply. We already updated the ARP cache earlier. */
 820:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
 821:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
 822:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* DHCP wants to know about ARP replies from any host with an
 823:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * IP address also offered to us by the DHCP server. We do not
 824:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * want to take a duplicate IP address on a single network.
 825:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * @todo How should we handle redundant (fail-over) interfaces? */
 826:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     dhcp_arp_reply(netif, &sipaddr);
 827:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
 828:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     break;
 829:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   default:
 830:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"
 831:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.err);
 832:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     break;
 1218              	 .loc 1 832 0 discriminator 4
 1219 00e0 4AE0     	 b .L72
 1220              	.L68:
 774:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 1221              	 .loc 1 774 0
 1222 00e2 97F82730 	 ldrb r3,[r7,#39]
 1223 00e6 002B     	 cmp r3,#0
 1224 00e8 41D0     	 beq .L70
 780:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 1225              	 .loc 1 780 0
 1226 00ea 0220     	 movs r0,#2
 1227 00ec FFF7FEFF 	 bl lwip_htons
 1228 00f0 0346     	 mov r3,r0
 1229 00f2 1A46     	 mov r2,r3
 1230 00f4 FB69     	 ldr r3,[r7,#28]
 1231 00f6 DA80     	 strh r2,[r3,#6]
 782:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 1232              	 .loc 1 782 0
 1233 00f8 FB69     	 ldr r3,[r7,#28]
 1234 00fa 03F11802 	 add r2,r3,#24
 1235 00fe FB69     	 ldr r3,[r7,#28]
 1236 0100 0E33     	 adds r3,r3,#14
 1237 0102 1046     	 mov r0,r2
 1238 0104 1946     	 mov r1,r3
 1239 0106 0422     	 movs r2,#4
 1240 0108 FFF7FEFF 	 bl thumb2_memcpy
 783:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 1241              	 .loc 1 783 0
 1242 010c FB69     	 ldr r3,[r7,#28]
 1243 010e 03F10E02 	 add r2,r3,#14
 1244 0112 FB68     	 ldr r3,[r7,#12]
 1245 0114 0433     	 adds r3,r3,#4
 1246 0116 1046     	 mov r0,r2
 1247 0118 1946     	 mov r1,r3
 1248 011a 0422     	 movs r2,#4
 1249 011c FFF7FEFF 	 bl thumb2_memcpy
 794:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 1250              	 .loc 1 794 0
 1251 0120 FB69     	 ldr r3,[r7,#28]
 1252 0122 03F11202 	 add r2,r3,#18
 1253 0126 FB69     	 ldr r3,[r7,#28]
 1254 0128 0833     	 adds r3,r3,#8
 1255 012a 1046     	 mov r0,r2
 1256 012c 1946     	 mov r1,r3
 1257 012e 0622     	 movs r2,#6
 1258 0130 FFF7FEFF 	 bl thumb2_memcpy
 798:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 1259              	 .loc 1 798 0
 1260 0134 3B6A     	 ldr r3,[r7,#32]
 1261 0136 9A1C     	 adds r2,r3,#2
 1262 0138 FB69     	 ldr r3,[r7,#28]
 1263 013a 0833     	 adds r3,r3,#8
 1264 013c 1046     	 mov r0,r2
 1265 013e 1946     	 mov r1,r3
 1266 0140 0622     	 movs r2,#6
 1267 0142 FFF7FEFF 	 bl thumb2_memcpy
 800:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHADDR16_COPY(&ethhdr->src, ethaddr);
 1268              	 .loc 1 800 0
 1269 0146 FB69     	 ldr r3,[r7,#28]
 1270 0148 0833     	 adds r3,r3,#8
 1271 014a 1846     	 mov r0,r3
 1272 014c B968     	 ldr r1,[r7,#8]
 1273 014e 0622     	 movs r2,#6
 1274 0150 FFF7FEFF 	 bl thumb2_memcpy
 801:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 1275              	 .loc 1 801 0
 1276 0154 3B6A     	 ldr r3,[r7,#32]
 1277 0156 0833     	 adds r3,r3,#8
 1278 0158 1846     	 mov r0,r3
 1279 015a B968     	 ldr r1,[r7,#8]
 1280 015c 0622     	 movs r2,#6
 1281 015e FFF7FEFF 	 bl thumb2_memcpy
 807:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* we are not configured? */
 1282              	 .loc 1 807 0
 1283 0162 FB68     	 ldr r3,[r7,#12]
 1284 0164 9B69     	 ldr r3,[r3,#24]
 1285 0166 F868     	 ldr r0,[r7,#12]
 1286 0168 7968     	 ldr r1,[r7,#4]
 1287 016a 9847     	 blx r3
 1288 016c 02E0     	 b .L71
 1289              	.L70:
 809:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* { for_us == 0 and netif->ip_addr.addr == 0 } */
 1290              	 .loc 1 809 0
 1291 016e FB68     	 ldr r3,[r7,#12]
 1292 0170 0433     	 adds r3,r3,#4
 1293 0172 002B     	 cmp r3,#0
 1294              	.L71:
 817:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   case PP_HTONS(ARP_REPLY):
 1295              	 .loc 1 817 0 discriminator 1
 1296 0174 00E0     	 b .L72
 1297              	.L74:
 828:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   default:
 1298              	 .loc 1 828 0
 1299 0176 00BF     	 nop
 1300              	.L72:
 833:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 834:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* free ARP packet */
 835:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   pbuf_free(p);
 1301              	 .loc 1 835 0 discriminator 2
 1302 0178 7868     	 ldr r0,[r7,#4]
 1303 017a FFF7FEFF 	 bl pbuf_free
 1304              	.L56:
 836:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 1305              	 .loc 1 836 0
 1306 017e 2837     	 adds r7,r7,#40
 1307              	.LCFI38:
 1308              	 .cfi_def_cfa_offset 8
 1309 0180 BD46     	 mov sp,r7
 1310              	.LCFI39:
 1311              	 .cfi_def_cfa_register 13
 1312              	 
 1313 0182 80BD     	 pop {r7,pc}
 1314              	 .cfi_endproc
 1315              	.LFE135:
 1317              	 .section .text.etharp_output_to_arp_index,"ax",%progbits
 1318              	 .align 2
 1319              	 .thumb
 1320              	 .thumb_func
 1322              	etharp_output_to_arp_index:
 1323              	.LFB136:
 837:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 838:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /** Just a small helper function that sends a pbuf to an ethernet address
 839:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * in the arp_table specified by the index 'arp_idx'.
 840:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 841:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static err_t
 842:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
 843:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 1324              	 .loc 1 843 0
 1325              	 .cfi_startproc
 1326              	 
 1327              	 
 1328 0000 90B5     	 push {r4,r7,lr}
 1329              	.LCFI40:
 1330              	 .cfi_def_cfa_offset 12
 1331              	 .cfi_offset 4,-12
 1332              	 .cfi_offset 7,-8
 1333              	 .cfi_offset 14,-4
 1334 0002 85B0     	 sub sp,sp,#20
 1335              	.LCFI41:
 1336              	 .cfi_def_cfa_offset 32
 1337 0004 00AF     	 add r7,sp,#0
 1338              	.LCFI42:
 1339              	 .cfi_def_cfa_register 7
 1340 0006 F860     	 str r0,[r7,#12]
 1341 0008 B960     	 str r1,[r7,#8]
 1342 000a 1346     	 mov r3,r2
 1343 000c FB71     	 strb r3,[r7,#7]
 844:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 845:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 846:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* if arp table entry is about to expire: re-request it,
 847:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      but only if its state is ETHARP_STATE_STABLE to prevent flooding the
 848:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      network with ARP requests if this address is used frequently. */
 849:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 1344              	 .loc 1 849 0
 1345 000e FA79     	 ldrb r2,[r7,#7]
 1346 0010 2149     	 ldr r1,.L78
 1347 0012 1346     	 mov r3,r2
 1348 0014 9B00     	 lsls r3,r3,#2
 1349 0016 1344     	 add r3,r3,r2
 1350 0018 9B00     	 lsls r3,r3,#2
 1351 001a 0B44     	 add r3,r3,r1
 1352 001c 1033     	 adds r3,r3,#16
 1353 001e 9B78     	 ldrb r3,[r3,#2]
 1354 0020 022B     	 cmp r3,#2
 1355 0022 23D1     	 bne .L76
 850:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 1356              	 .loc 1 850 0 discriminator 1
 1357 0024 FA79     	 ldrb r2,[r7,#7]
 1358 0026 1C49     	 ldr r1,.L78
 1359 0028 1346     	 mov r3,r2
 1360 002a 9B00     	 lsls r3,r3,#2
 1361 002c 1344     	 add r3,r3,r2
 1362 002e 9B00     	 lsls r3,r3,#2
 1363 0030 0B44     	 add r3,r3,r1
 1364 0032 1033     	 adds r3,r3,#16
 1365 0034 DB78     	 ldrb r3,[r3,#3]
 849:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 1366              	 .loc 1 849 0 discriminator 1
 1367 0036 E32B     	 cmp r3,#227
 1368 0038 18D9     	 bls .L76
 851:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 1369              	 .loc 1 851 0
 1370 003a FA79     	 ldrb r2,[r7,#7]
 1371 003c 1346     	 mov r3,r2
 1372 003e 9B00     	 lsls r3,r3,#2
 1373 0040 1344     	 add r3,r3,r2
 1374 0042 9B00     	 lsls r3,r3,#2
 1375 0044 144A     	 ldr r2,.L78
 1376 0046 1344     	 add r3,r3,r2
 1377 0048 0433     	 adds r3,r3,#4
 1378 004a F868     	 ldr r0,[r7,#12]
 1379 004c 1946     	 mov r1,r3
 1380 004e FFF7FEFF 	 bl etharp_request
 1381 0052 0346     	 mov r3,r0
 1382 0054 002B     	 cmp r3,#0
 1383 0056 09D1     	 bne .L76
 852:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 1384              	 .loc 1 852 0
 1385 0058 FA79     	 ldrb r2,[r7,#7]
 1386 005a 0F49     	 ldr r1,.L78
 1387 005c 1346     	 mov r3,r2
 1388 005e 9B00     	 lsls r3,r3,#2
 1389 0060 1344     	 add r3,r3,r2
 1390 0062 9B00     	 lsls r3,r3,#2
 1391 0064 0B44     	 add r3,r3,r1
 1392 0066 1033     	 adds r3,r3,#16
 1393 0068 0322     	 movs r2,#3
 1394 006a 9A70     	 strb r2,[r3,#2]
 1395              	.L76:
 853:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 854:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 855:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   
 856:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 1396              	 .loc 1 856 0
 1397 006c FB68     	 ldr r3,[r7,#12]
 1398 006e 03F12704 	 add r4,r3,#39
 857:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     &arp_table[arp_idx].ethaddr);
 1399              	 .loc 1 857 0
 1400 0072 FA79     	 ldrb r2,[r7,#7]
 856:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     &arp_table[arp_idx].ethaddr);
 1401              	 .loc 1 856 0
 1402 0074 1346     	 mov r3,r2
 1403 0076 9B00     	 lsls r3,r3,#2
 1404 0078 1344     	 add r3,r3,r2
 1405 007a 9B00     	 lsls r3,r3,#2
 1406 007c 0833     	 adds r3,r3,#8
 1407 007e 064A     	 ldr r2,.L78
 1408 0080 1344     	 add r3,r3,r2
 1409 0082 0433     	 adds r3,r3,#4
 1410 0084 F868     	 ldr r0,[r7,#12]
 1411 0086 B968     	 ldr r1,[r7,#8]
 1412 0088 2246     	 mov r2,r4
 1413 008a FFF7FEFF 	 bl etharp_send_ip
 1414 008e 0346     	 mov r3,r0
 858:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 1415              	 .loc 1 858 0
 1416 0090 1846     	 mov r0,r3
 1417 0092 1437     	 adds r7,r7,#20
 1418              	.LCFI43:
 1419              	 .cfi_def_cfa_offset 12
 1420 0094 BD46     	 mov sp,r7
 1421              	.LCFI44:
 1422              	 .cfi_def_cfa_register 13
 1423              	 
 1424 0096 90BD     	 pop {r4,r7,pc}
 1425              	.L79:
 1426              	 .align 2
 1427              	.L78:
 1428 0098 00000000 	 .word arp_table
 1429              	 .cfi_endproc
 1430              	.LFE136:
 1432              	 .section .text.etharp_output,"ax",%progbits
 1433              	 .align 2
 1434              	 .global etharp_output
 1435              	 .thumb
 1436              	 .thumb_func
 1438              	etharp_output:
 1439              	.LFB137:
 859:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 860:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 861:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Resolve and fill-in Ethernet address header for outgoing IP packet.
 862:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 863:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * For IP multicast and broadcast, corresponding Ethernet addresses
 864:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * are selected and the packet is transmitted on the link.
 865:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 866:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * For unicast addresses, the packet is submitted to etharp_query(). In
 867:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * case the IP address is outside the local network, the IP address of
 868:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * the gateway is used.
 869:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 870:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif The lwIP network interface which the IP packet will be sent on.
 871:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param q The pbuf(s) containing the IP packet to be sent.
 872:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr The IP address of the packet destination.
 873:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 874:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return
 875:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks),
 876:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * or the return type of either etharp_query() or etharp_send_ip().
 877:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
 878:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
 879:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
 880:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 1440              	 .loc 1 880 0
 1441              	 .cfi_startproc
 1442              	 
 1443              	 
 1444 0000 80B5     	 push {r7,lr}
 1445              	.LCFI45:
 1446              	 .cfi_def_cfa_offset 8
 1447              	 .cfi_offset 7,-8
 1448              	 .cfi_offset 14,-4
 1449 0002 88B0     	 sub sp,sp,#32
 1450              	.LCFI46:
 1451              	 .cfi_def_cfa_offset 40
 1452 0004 00AF     	 add r7,sp,#0
 1453              	.LCFI47:
 1454              	 .cfi_def_cfa_register 7
 1455 0006 F860     	 str r0,[r7,#12]
 1456 0008 B960     	 str r1,[r7,#8]
 1457 000a 7A60     	 str r2,[r7,#4]
 881:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_addr *dest;
 882:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_addr mcastaddr;
 883:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ip_addr_t *dst_addr = ipaddr;
 1458              	 .loc 1 883 0
 1459 000c 7B68     	 ldr r3,[r7,#4]
 1460 000e BB61     	 str r3,[r7,#24]
 884:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 885:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 886:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 887:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 888:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 889:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* make room for Ethernet header - should not fail */
 890:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 1461              	 .loc 1 890 0
 1462 0010 B868     	 ldr r0,[r7,#8]
 1463 0012 1021     	 movs r1,#16
 1464 0014 FFF7FEFF 	 bl pbuf_header
 1465 0018 0346     	 mov r3,r0
 1466 001a 002B     	 cmp r3,#0
 1467 001c 01D0     	 beq .L81
 891:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* bail out */
 892:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
 893:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ("etharp_output: could not allocate room for header.\n"));
 894:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LINK_STATS_INC(link.lenerr);
 895:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_BUF;
 1468              	 .loc 1 895 0
 1469 001e FE23     	 movs r3,#254
 1470 0020 ABE0     	 b .L92
 1471              	.L81:
 896:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 897:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 898:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Determine on destination hardware address. Broadcasts and multicasts
 899:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * are special, other IP addresses are looked up in the ARP table. */
 900:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 901:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* broadcast destination IP address? */
 902:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ip_addr_isbroadcast(ipaddr, netif)) {
 1472              	 .loc 1 902 0
 1473 0022 7B68     	 ldr r3,[r7,#4]
 1474 0024 1B68     	 ldr r3,[r3]
 1475 0026 1846     	 mov r0,r3
 1476 0028 F968     	 ldr r1,[r7,#12]
 1477 002a FFF7FEFF 	 bl ip4_addr_isbroadcast
 1478 002e 0346     	 mov r3,r0
 1479 0030 002B     	 cmp r3,#0
 1480 0032 02D0     	 beq .L83
 903:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* broadcast on Ethernet also */
 904:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     dest = (struct eth_addr *)&ethbroadcast;
 1481              	 .loc 1 904 0
 1482 0034 534B     	 ldr r3,.L93
 1483 0036 FB61     	 str r3,[r7,#28]
 1484 0038 96E0     	 b .L84
 1485              	.L83:
 905:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* multicast destination IP address? */
 906:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else if (ip_addr_ismulticast(ipaddr)) {
 1486              	 .loc 1 906 0
 1487 003a 7B68     	 ldr r3,[r7,#4]
 1488 003c 1B68     	 ldr r3,[r3]
 1489 003e 03F0F003 	 and r3,r3,#240
 1490 0042 E02B     	 cmp r3,#224
 1491 0044 16D1     	 bne .L85
 907:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 908:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 1492              	 .loc 1 908 0
 1493 0046 0123     	 movs r3,#1
 1494 0048 3B74     	 strb r3,[r7,#16]
 909:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 1495              	 .loc 1 909 0
 1496 004a 0023     	 movs r3,#0
 1497 004c 7B74     	 strb r3,[r7,#17]
 910:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 1498              	 .loc 1 910 0
 1499 004e 5E23     	 movs r3,#94
 1500 0050 BB74     	 strb r3,[r7,#18]
 911:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 1501              	 .loc 1 911 0
 1502 0052 7B68     	 ldr r3,[r7,#4]
 1503 0054 0133     	 adds r3,r3,#1
 1504 0056 1B78     	 ldrb r3,[r3]
 1505 0058 03F07F03 	 and r3,r3,#127
 1506 005c DBB2     	 uxtb r3,r3
 1507 005e FB74     	 strb r3,[r7,#19]
 912:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 1508              	 .loc 1 912 0
 1509 0060 7B68     	 ldr r3,[r7,#4]
 1510 0062 9B78     	 ldrb r3,[r3,#2]
 1511 0064 3B75     	 strb r3,[r7,#20]
 913:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
 1512              	 .loc 1 913 0
 1513 0066 7B68     	 ldr r3,[r7,#4]
 1514 0068 DB78     	 ldrb r3,[r3,#3]
 1515 006a 7B75     	 strb r3,[r7,#21]
 914:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* destination Ethernet address is multicast */
 915:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     dest = &mcastaddr;
 1516              	 .loc 1 915 0
 1517 006c 07F11003 	 add r3,r7,#16
 1518 0070 FB61     	 str r3,[r7,#28]
 1519 0072 79E0     	 b .L84
 1520              	.L85:
 1521              	.LBB6:
 916:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* unicast destination IP address? */
 917:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else {
 918:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     s8_t i;
 919:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* outside local network? if so, this can neither be a global broadcast nor
 920:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****        a subnet broadcast. */
 921:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 1522              	 .loc 1 921 0
 1523 0074 7B68     	 ldr r3,[r7,#4]
 1524 0076 1A68     	 ldr r2,[r3]
 1525 0078 FB68     	 ldr r3,[r7,#12]
 1526 007a 5B68     	 ldr r3,[r3,#4]
 1527 007c 5A40     	 eors r2,r2,r3
 1528 007e FB68     	 ldr r3,[r7,#12]
 1529 0080 9B68     	 ldr r3,[r3,#8]
 1530 0082 1340     	 ands r3,r3,r2
 1531 0084 002B     	 cmp r3,#0
 1532 0086 14D0     	 beq .L86
 922:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         !ip_addr_islinklocal(ipaddr)) {
 1533              	 .loc 1 922 0 discriminator 1
 1534 0088 7B68     	 ldr r3,[r7,#4]
 1535 008a 1B68     	 ldr r3,[r3]
 1536 008c 9BB2     	 uxth r3,r3
 921:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         !ip_addr_islinklocal(ipaddr)) {
 1537              	 .loc 1 921 0 discriminator 1
 1538 008e 4FF6A962 	 movw r2,#65193
 1539 0092 9342     	 cmp r3,r2
 1540 0094 0DD0     	 beq .L86
 923:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
 924:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
 925:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         sizeof(struct eth_hdr));
 926:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
 927:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          a link-local source address must always be "directly to its destination
 928:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          on the same physical link. The host MUST NOT send the packet to any
 929:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          router for forwarding". */
 930:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (!ip_addr_islinklocal(&iphdr->src))
 931:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
 932:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       {
 933:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* interface has default gateway? */
 934:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if (!ip_addr_isany(&netif->gw)) {
 1541              	 .loc 1 934 0
 1542 0096 FB68     	 ldr r3,[r7,#12]
 1543 0098 0C33     	 adds r3,r3,#12
 1544 009a 002B     	 cmp r3,#0
 1545 009c 07D0     	 beq .L87
 1546              	 .loc 1 934 0 is_stmt 0 discriminator 1
 1547 009e FB68     	 ldr r3,[r7,#12]
 1548 00a0 DB68     	 ldr r3,[r3,#12]
 1549 00a2 002B     	 cmp r3,#0
 1550 00a4 03D0     	 beq .L87
 935:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* send to hardware address of default gateway IP address */
 936:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           dst_addr = &(netif->gw);
 1551              	 .loc 1 936 0 is_stmt 1
 1552 00a6 FB68     	 ldr r3,[r7,#12]
 1553 00a8 0C33     	 adds r3,r3,#12
 1554 00aa BB61     	 str r3,[r7,#24]
 1555 00ac 01E0     	 b .L86
 1556              	.L87:
 937:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* no default gateway available */
 938:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         } else {
 939:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* no route to destination error (default gateway missing) */
 940:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           return ERR_RTE;
 1557              	 .loc 1 940 0
 1558 00ae FC23     	 movs r3,#252
 1559 00b0 63E0     	 b .L92
 1560              	.L86:
 941:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
 942:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 943:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 944:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 945:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (netif->addr_hint != NULL) {
 946:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* per-pcb cached entry was given */
 947:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       u8_t etharp_cached_entry = *(netif->addr_hint);
 948:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (etharp_cached_entry < ARP_TABLE_SIZE) {
 949:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 950:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 1561              	 .loc 1 950 0
 1562 00b2 354B     	 ldr r3,.L93+4
 1563 00b4 1B78     	 ldrb r3,[r3]
 1564 00b6 1946     	 mov r1,r3
 1565 00b8 344A     	 ldr r2,.L93+8
 1566 00ba 0B46     	 mov r3,r1
 1567 00bc 9B00     	 lsls r3,r3,#2
 1568 00be 0B44     	 add r3,r3,r1
 1569 00c0 9B00     	 lsls r3,r3,#2
 1570 00c2 1344     	 add r3,r3,r2
 1571 00c4 1033     	 adds r3,r3,#16
 1572 00c6 9B78     	 ldrb r3,[r3,#2]
 1573 00c8 012B     	 cmp r3,#1
 1574 00ca 16D9     	 bls .L88
 951:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 1575              	 .loc 1 951 0 discriminator 1
 1576 00cc BB69     	 ldr r3,[r7,#24]
 1577 00ce 1A68     	 ldr r2,[r3]
 1578 00d0 2D4B     	 ldr r3,.L93+4
 1579 00d2 1B78     	 ldrb r3,[r3]
 1580 00d4 1846     	 mov r0,r3
 1581 00d6 2D49     	 ldr r1,.L93+8
 1582 00d8 0346     	 mov r3,r0
 1583 00da 9B00     	 lsls r3,r3,#2
 1584 00dc 0344     	 add r3,r3,r0
 1585 00de 9B00     	 lsls r3,r3,#2
 1586 00e0 0B44     	 add r3,r3,r1
 1587 00e2 5B68     	 ldr r3,[r3,#4]
 950:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 1588              	 .loc 1 950 0 discriminator 1
 1589 00e4 9A42     	 cmp r2,r3
 1590 00e6 08D1     	 bne .L88
 952:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* the per-pcb-cached entry is stable and the right one! */
 953:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           ETHARP_STATS_INC(etharp.cachehit);
 954:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 1591              	 .loc 1 954 0
 1592 00e8 274B     	 ldr r3,.L93+4
 1593 00ea 1B78     	 ldrb r3,[r3]
 1594 00ec F868     	 ldr r0,[r7,#12]
 1595 00ee B968     	 ldr r1,[r7,#8]
 1596 00f0 1A46     	 mov r2,r3
 1597 00f2 FFF7FEFF 	 bl etharp_output_to_arp_index
 1598 00f6 0346     	 mov r3,r0
 1599 00f8 3FE0     	 b .L92
 1600              	.L88:
 955:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
 956:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 957:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 958:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 959:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 960:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 961:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* find stable entry: do this here since this is a critical path for
 962:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****        throughput and etharp_find_entry() is kind of slow */
 963:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     for (i = 0; i < ARP_TABLE_SIZE; i++) {
 1601              	 .loc 1 963 0
 1602 00fa 0023     	 movs r3,#0
 1603 00fc FB75     	 strb r3,[r7,#23]
 1604 00fe 28E0     	 b .L89
 1605              	.L91:
 964:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1606              	 .loc 1 964 0
 1607 0100 97F91720 	 ldrsb r2,[r7,#23]
 1608 0104 2149     	 ldr r1,.L93+8
 1609 0106 1346     	 mov r3,r2
 1610 0108 9B00     	 lsls r3,r3,#2
 1611 010a 1344     	 add r3,r3,r2
 1612 010c 9B00     	 lsls r3,r3,#2
 1613 010e 0B44     	 add r3,r3,r1
 1614 0110 1033     	 adds r3,r3,#16
 1615 0112 9B78     	 ldrb r3,[r3,#2]
 1616 0114 012B     	 cmp r3,#1
 1617 0116 17D9     	 bls .L90
 965:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 1618              	 .loc 1 965 0 discriminator 1
 1619 0118 BB69     	 ldr r3,[r7,#24]
 1620 011a 1968     	 ldr r1,[r3]
 1621 011c 97F91720 	 ldrsb r2,[r7,#23]
 1622 0120 1A48     	 ldr r0,.L93+8
 1623 0122 1346     	 mov r3,r2
 1624 0124 9B00     	 lsls r3,r3,#2
 1625 0126 1344     	 add r3,r3,r2
 1626 0128 9B00     	 lsls r3,r3,#2
 1627 012a 0344     	 add r3,r3,r0
 1628 012c 5B68     	 ldr r3,[r3,#4]
 964:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1629              	 .loc 1 964 0 discriminator 1
 1630 012e 9942     	 cmp r1,r3
 1631 0130 0AD1     	 bne .L90
 966:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* found an existing, stable entry */
 967:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         ETHARP_SET_HINT(netif, i);
 1632              	 .loc 1 967 0
 1633 0132 FA7D     	 ldrb r2,[r7,#23]
 1634 0134 144B     	 ldr r3,.L93+4
 1635 0136 1A70     	 strb r2,[r3]
 968:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         return etharp_output_to_arp_index(netif, q, i);
 1636              	 .loc 1 968 0
 1637 0138 FB7D     	 ldrb r3,[r7,#23]
 1638 013a F868     	 ldr r0,[r7,#12]
 1639 013c B968     	 ldr r1,[r7,#8]
 1640 013e 1A46     	 mov r2,r3
 1641 0140 FFF7FEFF 	 bl etharp_output_to_arp_index
 1642 0144 0346     	 mov r3,r0
 1643 0146 18E0     	 b .L92
 1644              	.L90:
 963:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1645              	 .loc 1 963 0 discriminator 2
 1646 0148 FB7D     	 ldrb r3,[r7,#23]
 1647 014a DBB2     	 uxtb r3,r3
 1648 014c 0133     	 adds r3,r3,#1
 1649 014e DBB2     	 uxtb r3,r3
 1650 0150 FB75     	 strb r3,[r7,#23]
 1651              	.L89:
 963:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1652              	 .loc 1 963 0 is_stmt 0 discriminator 1
 1653 0152 97F91730 	 ldrsb r3,[r7,#23]
 1654 0156 092B     	 cmp r3,#9
 1655 0158 D2DD     	 ble .L91
 969:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 970:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
 971:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* no stable entry found, use the (slower) query function:
 972:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****        queue on destination Ethernet address belonging to ipaddr */
 973:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return etharp_query(netif, dst_addr, q);
 1656              	 .loc 1 973 0 is_stmt 1
 1657 015a F868     	 ldr r0,[r7,#12]
 1658 015c B969     	 ldr r1,[r7,#24]
 1659 015e BA68     	 ldr r2,[r7,#8]
 1660 0160 FFF7FEFF 	 bl etharp_query
 1661 0164 0346     	 mov r3,r0
 1662 0166 08E0     	 b .L92
 1663              	.L84:
 1664              	.LBE6:
 974:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
 975:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 976:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* continuation for multicast/broadcast destinations */
 977:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* obtain source Ethernet address of the given interface */
 978:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* send packet directly on the link */
 979:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 1665              	 .loc 1 979 0
 1666 0168 FB68     	 ldr r3,[r7,#12]
 1667 016a 2733     	 adds r3,r3,#39
 1668 016c F868     	 ldr r0,[r7,#12]
 1669 016e B968     	 ldr r1,[r7,#8]
 1670 0170 1A46     	 mov r2,r3
 1671 0172 FB69     	 ldr r3,[r7,#28]
 1672 0174 FFF7FEFF 	 bl etharp_send_ip
 1673 0178 0346     	 mov r3,r0
 1674              	.L92:
 1675 017a 5BB2     	 sxtb r3,r3
 980:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 1676              	 .loc 1 980 0 discriminator 1
 1677 017c 1846     	 mov r0,r3
 1678 017e 2037     	 adds r7,r7,#32
 1679              	.LCFI48:
 1680              	 .cfi_def_cfa_offset 8
 1681 0180 BD46     	 mov sp,r7
 1682              	.LCFI49:
 1683              	 .cfi_def_cfa_register 13
 1684              	 
 1685 0182 80BD     	 pop {r7,pc}
 1686              	.L94:
 1687              	 .align 2
 1688              	.L93:
 1689 0184 00000000 	 .word ethbroadcast
 1690 0188 00000000 	 .word etharp_cached_entry
 1691 018c 00000000 	 .word arp_table
 1692              	 .cfi_endproc
 1693              	.LFE137:
 1695              	 .section .text.etharp_query,"ax",%progbits
 1696              	 .align 2
 1697              	 .global etharp_query
 1698              	 .thumb
 1699              	 .thumb_func
 1701              	etharp_query:
 1702              	.LFB138:
 981:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
 982:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
 983:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Send an ARP request for the given IP address and/or queue a packet.
 984:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 985:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If the IP address was not yet in the cache, a pending ARP cache entry
 986:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * is added and an ARP request is sent for the given address. The packet
 987:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * is queued on this entry.
 988:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 989:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If the IP address was already pending in the cache, a new ARP request
 990:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * is sent for the given address. The packet is queued on this entry.
 991:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
 992:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If the IP address was already stable in the cache, and a packet is
 993:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * given, it is directly sent and no ARP request is sent out. 
 994:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 995:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * If the IP address was already stable in the cache, and no packet is
 996:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * given, an ARP request is sent out.
 997:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * 
 998:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif The lwIP network interface on which ipaddr
 999:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * must be queried for.
1000:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr The IP address to be resolved.
1001:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param q If non-NULL, a pbuf that must be delivered to the IP address.
1002:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * q is not freed by this function.
1003:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1004:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @note q must only be ONE packet, not a packet queue!
1005:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1006:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return
1007:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_BUF Could not make room for Ethernet header.
1008:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_MEM Hardware address unknown, and no more ARP entries available
1009:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *   to query for address or queue the packet.
1010:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_MEM Could not queue packet due to memory shortage.
1011:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks).
1012:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
1013:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1014:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
1015:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
1016:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
1017:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 1703              	 .loc 1 1017 0
 1704              	 .cfi_startproc
 1705              	 
 1706              	 
 1707 0000 80B5     	 push {r7,lr}
 1708              	.LCFI50:
 1709              	 .cfi_def_cfa_offset 8
 1710              	 .cfi_offset 7,-8
 1711              	 .cfi_offset 14,-4
 1712 0002 8AB0     	 sub sp,sp,#40
 1713              	.LCFI51:
 1714              	 .cfi_def_cfa_offset 48
 1715 0004 00AF     	 add r7,sp,#0
 1716              	.LCFI52:
 1717              	 .cfi_def_cfa_register 7
 1718 0006 F860     	 str r0,[r7,#12]
 1719 0008 B960     	 str r1,[r7,#8]
 1720 000a 7A60     	 str r2,[r7,#4]
1018:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 1721              	 .loc 1 1018 0
 1722 000c FB68     	 ldr r3,[r7,#12]
 1723 000e 2733     	 adds r3,r3,#39
 1724 0010 BB61     	 str r3,[r7,#24]
1019:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   err_t result = ERR_MEM;
 1725              	 .loc 1 1019 0
 1726 0012 FF23     	 movs r3,#255
 1727 0014 87F82730 	 strb r3,[r7,#39]
1020:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s8_t i; /* ARP entry index */
1021:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1022:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* non-unicast address? */
1023:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ip_addr_isbroadcast(ipaddr, netif) ||
 1728              	 .loc 1 1023 0
 1729 0018 BB68     	 ldr r3,[r7,#8]
 1730 001a 1B68     	 ldr r3,[r3]
 1731 001c 1846     	 mov r0,r3
 1732 001e F968     	 ldr r1,[r7,#12]
 1733 0020 FFF7FEFF 	 bl ip4_addr_isbroadcast
 1734 0024 0346     	 mov r3,r0
 1735 0026 002B     	 cmp r3,#0
 1736 0028 0CD1     	 bne .L96
1024:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_ismulticast(ipaddr) ||
 1737              	 .loc 1 1024 0 discriminator 1
 1738 002a BB68     	 ldr r3,[r7,#8]
 1739 002c 1B68     	 ldr r3,[r3]
 1740 002e 03F0F003 	 and r3,r3,#240
1023:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_ismulticast(ipaddr) ||
 1741              	 .loc 1 1023 0 discriminator 1
 1742 0032 E02B     	 cmp r3,#224
 1743 0034 06D0     	 beq .L96
 1744              	 .loc 1 1024 0
 1745 0036 BB68     	 ldr r3,[r7,#8]
 1746 0038 002B     	 cmp r3,#0
 1747 003a 03D0     	 beq .L96
1025:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ip_addr_isany(ipaddr)) {
 1748              	 .loc 1 1025 0
 1749 003c BB68     	 ldr r3,[r7,#8]
 1750 003e 1B68     	 ldr r3,[r3]
 1751 0040 002B     	 cmp r3,#0
 1752 0042 01D1     	 bne .L97
 1753              	.L96:
1026:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address 
1027:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_ARG;
 1754              	 .loc 1 1027 0
 1755 0044 F223     	 movs r3,#242
 1756 0046 CBE0     	 b .L98
 1757              	.L97:
1028:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1029:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1030:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* find entry in ARP cache, ask to create entry if queueing packet */
1031:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 1758              	 .loc 1 1031 0
 1759 0048 B868     	 ldr r0,[r7,#8]
 1760 004a 0121     	 movs r1,#1
 1761 004c FFF7FEFF 	 bl etharp_find_entry
 1762 0050 0346     	 mov r3,r0
 1763 0052 FB75     	 strb r3,[r7,#23]
1032:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1033:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* could not find or create entry? */
1034:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (i < 0) {
 1764              	 .loc 1 1034 0
 1765 0054 97F91730 	 ldrsb r3,[r7,#23]
 1766 0058 002B     	 cmp r3,#0
 1767 005a 01DA     	 bge .L99
1035:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
1036:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (q) {
1037:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
1038:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
1039:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1040:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return (err_t)i;
 1768              	 .loc 1 1040 0
 1769 005c FB7D     	 ldrb r3,[r7,#23]
 1770 005e BFE0     	 b .L98
 1771              	.L99:
1041:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1042:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1043:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* mark a fresh entry as pending (we just sent a request) */
1044:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 1772              	 .loc 1 1044 0
 1773 0060 97F91720 	 ldrsb r2,[r7,#23]
 1774 0064 6149     	 ldr r1,.L114
 1775 0066 1346     	 mov r3,r2
 1776 0068 9B00     	 lsls r3,r3,#2
 1777 006a 1344     	 add r3,r3,r2
 1778 006c 9B00     	 lsls r3,r3,#2
 1779 006e 0B44     	 add r3,r3,r1
 1780 0070 1033     	 adds r3,r3,#16
 1781 0072 9B78     	 ldrb r3,[r3,#2]
 1782 0074 002B     	 cmp r3,#0
 1783 0076 0AD1     	 bne .L100
1045:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     arp_table[i].state = ETHARP_STATE_PENDING;
 1784              	 .loc 1 1045 0
 1785 0078 97F91720 	 ldrsb r2,[r7,#23]
 1786 007c 5B49     	 ldr r1,.L114
 1787 007e 1346     	 mov r3,r2
 1788 0080 9B00     	 lsls r3,r3,#2
 1789 0082 1344     	 add r3,r3,r2
 1790 0084 9B00     	 lsls r3,r3,#2
 1791 0086 0B44     	 add r3,r3,r1
 1792 0088 1033     	 adds r3,r3,#16
 1793 008a 0122     	 movs r2,#1
 1794 008c 9A70     	 strb r2,[r3,#2]
 1795              	.L100:
1046:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1047:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1048:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* { i is either a STABLE or (new or existing) PENDING entry } */
1049:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
1050:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ((arp_table[i].state == ETHARP_STATE_PENDING) ||
1051:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    (arp_table[i].state >= ETHARP_STATE_STABLE)));
1052:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1053:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* do we have a pending entry? or an implicit query request? */
1054:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 1796              	 .loc 1 1054 0
 1797 008e 97F91720 	 ldrsb r2,[r7,#23]
 1798 0092 5649     	 ldr r1,.L114
 1799 0094 1346     	 mov r3,r2
 1800 0096 9B00     	 lsls r3,r3,#2
 1801 0098 1344     	 add r3,r3,r2
 1802 009a 9B00     	 lsls r3,r3,#2
 1803 009c 0B44     	 add r3,r3,r1
 1804 009e 1033     	 adds r3,r3,#16
 1805 00a0 9B78     	 ldrb r3,[r3,#2]
 1806 00a2 012B     	 cmp r3,#1
 1807 00a4 02D0     	 beq .L101
 1808              	 .loc 1 1054 0 is_stmt 0 discriminator 1
 1809 00a6 7B68     	 ldr r3,[r7,#4]
 1810 00a8 002B     	 cmp r3,#0
 1811 00aa 0CD1     	 bne .L102
 1812              	.L101:
1055:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* try to resolve it; send out ARP request */
1056:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     result = etharp_request(netif, ipaddr);
 1813              	 .loc 1 1056 0 is_stmt 1
 1814 00ac F868     	 ldr r0,[r7,#12]
 1815 00ae B968     	 ldr r1,[r7,#8]
 1816 00b0 FFF7FEFF 	 bl etharp_request
 1817 00b4 0346     	 mov r3,r0
 1818 00b6 87F82730 	 strb r3,[r7,#39]
1057:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (result != ERR_OK) {
1058:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* ARP request couldn't be sent */
1059:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* We don't re-send arp request in etharp_tmr, but we still queue packets,
1060:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          since this failure could be temporary, and the next packet calling
1061:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****          etharp_query again could lead to sending the queued packets. */
1062:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1063:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (q == NULL) {
 1819              	 .loc 1 1063 0
 1820 00ba 7B68     	 ldr r3,[r7,#4]
 1821 00bc 002B     	 cmp r3,#0
 1822 00be 02D1     	 bne .L102
1064:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       return result;
 1823              	 .loc 1 1064 0
 1824 00c0 97F82730 	 ldrb r3,[r7,#39]
 1825 00c4 8CE0     	 b .L98
 1826              	.L102:
1065:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1066:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1067:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1068:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* packet given? */
1069:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
1070:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* stable entry? */
1071:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 1827              	 .loc 1 1071 0
 1828 00c6 97F91720 	 ldrsb r2,[r7,#23]
 1829 00ca 4849     	 ldr r1,.L114
 1830 00cc 1346     	 mov r3,r2
 1831 00ce 9B00     	 lsls r3,r3,#2
 1832 00d0 1344     	 add r3,r3,r2
 1833 00d2 9B00     	 lsls r3,r3,#2
 1834 00d4 0B44     	 add r3,r3,r1
 1835 00d6 1033     	 adds r3,r3,#16
 1836 00d8 9B78     	 ldrb r3,[r3,#2]
 1837 00da 012B     	 cmp r3,#1
 1838 00dc 15D9     	 bls .L103
1072:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
1073:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_SET_HINT(netif, i);
 1839              	 .loc 1 1073 0
 1840 00de FA7D     	 ldrb r2,[r7,#23]
 1841 00e0 434B     	 ldr r3,.L114+4
 1842 00e2 1A70     	 strb r2,[r3]
1074:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* send the packet */
1075:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 1843              	 .loc 1 1075 0
 1844 00e4 97F91720 	 ldrsb r2,[r7,#23]
 1845 00e8 1346     	 mov r3,r2
 1846 00ea 9B00     	 lsls r3,r3,#2
 1847 00ec 1344     	 add r3,r3,r2
 1848 00ee 9B00     	 lsls r3,r3,#2
 1849 00f0 0833     	 adds r3,r3,#8
 1850 00f2 3E4A     	 ldr r2,.L114
 1851 00f4 1344     	 add r3,r3,r2
 1852 00f6 0433     	 adds r3,r3,#4
 1853 00f8 F868     	 ldr r0,[r7,#12]
 1854 00fa 7968     	 ldr r1,[r7,#4]
 1855 00fc BA69     	 ldr r2,[r7,#24]
 1856 00fe FFF7FEFF 	 bl etharp_send_ip
 1857 0102 0346     	 mov r3,r0
 1858 0104 87F82730 	 strb r3,[r7,#39]
 1859 0108 68E0     	 b .L104
 1860              	.L103:
1076:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* pending entry? (either just created or already pending */
1077:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 1861              	 .loc 1 1077 0
 1862 010a 97F91720 	 ldrsb r2,[r7,#23]
 1863 010e 3749     	 ldr r1,.L114
 1864 0110 1346     	 mov r3,r2
 1865 0112 9B00     	 lsls r3,r3,#2
 1866 0114 1344     	 add r3,r3,r2
 1867 0116 9B00     	 lsls r3,r3,#2
 1868 0118 0B44     	 add r3,r3,r1
 1869 011a 1033     	 adds r3,r3,#16
 1870 011c 9B78     	 ldrb r3,[r3,#2]
 1871 011e 012B     	 cmp r3,#1
 1872 0120 5CD1     	 bne .L104
 1873              	.LBB7:
1078:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* entry is still pending, queue the given packet 'q' */
1079:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     struct pbuf *p;
1080:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     int copy_needed = 0;
 1874              	 .loc 1 1080 0
 1875 0122 0023     	 movs r3,#0
 1876 0124 FB61     	 str r3,[r7,#28]
1081:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
1082:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
1083:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      * PBUF_ROMs can be left as they are, since ROM must not get changed. */
1084:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     p = q;
 1877              	 .loc 1 1084 0
 1878 0126 7B68     	 ldr r3,[r7,#4]
 1879 0128 3B62     	 str r3,[r7,#32]
1085:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     while (p) {
 1880              	 .loc 1 1085 0
 1881 012a 09E0     	 b .L105
 1882              	.L108:
1086:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
1087:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if(p->type != PBUF_ROM) {
 1883              	 .loc 1 1087 0
 1884 012c 3B6A     	 ldr r3,[r7,#32]
 1885 012e 1B7B     	 ldrb r3,[r3,#12]
 1886 0130 012B     	 cmp r3,#1
 1887 0132 02D0     	 beq .L106
1088:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         copy_needed = 1;
 1888              	 .loc 1 1088 0
 1889 0134 0123     	 movs r3,#1
 1890 0136 FB61     	 str r3,[r7,#28]
1089:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         break;
 1891              	 .loc 1 1089 0
 1892 0138 05E0     	 b .L107
 1893              	.L106:
1090:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1091:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       p = p->next;
 1894              	 .loc 1 1091 0
 1895 013a 3B6A     	 ldr r3,[r7,#32]
 1896 013c 1B68     	 ldr r3,[r3]
 1897 013e 3B62     	 str r3,[r7,#32]
 1898              	.L105:
1085:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 1899              	 .loc 1 1085 0
 1900 0140 3B6A     	 ldr r3,[r7,#32]
 1901 0142 002B     	 cmp r3,#0
 1902 0144 F2D1     	 bne .L108
 1903              	.L107:
1092:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1093:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if(copy_needed) {
 1904              	 .loc 1 1093 0
 1905 0146 FB69     	 ldr r3,[r7,#28]
 1906 0148 002B     	 cmp r3,#0
 1907 014a 17D0     	 beq .L109
1094:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* copy the whole packet into new pbufs */
1095:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 1908              	 .loc 1 1095 0
 1909 014c 3B6A     	 ldr r3,[r7,#32]
 1910 014e 1B89     	 ldrh r3,[r3,#8]
 1911 0150 0320     	 movs r0,#3
 1912 0152 1946     	 mov r1,r3
 1913 0154 0022     	 movs r2,#0
 1914 0156 FFF7FEFF 	 bl pbuf_alloc
 1915 015a 3862     	 str r0,[r7,#32]
1096:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if(p != NULL) {
 1916              	 .loc 1 1096 0
 1917 015c 3B6A     	 ldr r3,[r7,#32]
 1918 015e 002B     	 cmp r3,#0
 1919 0160 11D0     	 beq .L111
1097:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if (pbuf_copy(p, q) != ERR_OK) {
 1920              	 .loc 1 1097 0
 1921 0162 386A     	 ldr r0,[r7,#32]
 1922 0164 7968     	 ldr r1,[r7,#4]
 1923 0166 FFF7FEFF 	 bl pbuf_copy
 1924 016a 0346     	 mov r3,r0
 1925 016c 002B     	 cmp r3,#0
 1926 016e 0AD0     	 beq .L111
1098:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           pbuf_free(p);
 1927              	 .loc 1 1098 0
 1928 0170 386A     	 ldr r0,[r7,#32]
 1929 0172 FFF7FEFF 	 bl pbuf_free
1099:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           p = NULL;
 1930              	 .loc 1 1099 0
 1931 0176 0023     	 movs r3,#0
 1932 0178 3B62     	 str r3,[r7,#32]
 1933 017a 04E0     	 b .L111
 1934              	.L109:
1100:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
1101:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1102:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else {
1103:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* referencing the old pbuf is enough */
1104:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       p = q;
 1935              	 .loc 1 1104 0
 1936 017c 7B68     	 ldr r3,[r7,#4]
 1937 017e 3B62     	 str r3,[r7,#32]
1105:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       pbuf_ref(p);
 1938              	 .loc 1 1105 0
 1939 0180 386A     	 ldr r0,[r7,#32]
 1940 0182 FFF7FEFF 	 bl pbuf_ref
 1941              	.L111:
1106:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1107:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* packet could be taken over? */
1108:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (p != NULL) {
 1942              	 .loc 1 1108 0
 1943 0186 3B6A     	 ldr r3,[r7,#32]
 1944 0188 002B     	 cmp r3,#0
 1945 018a 24D0     	 beq .L112
1109:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* queue packet ... */
1110:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ARP_QUEUEING
1111:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       struct etharp_q_entry *new_entry;
1112:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* allocate a new arp queue entry */
1113:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
1114:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (new_entry != NULL) {
1115:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         new_entry->next = 0;
1116:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         new_entry->p = p;
1117:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         if(arp_table[i].q != NULL) {
1118:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* queue was already existent, append the new entry to the end */
1119:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           struct etharp_q_entry *r;
1120:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           r = arp_table[i].q;
1121:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           while (r->next != NULL) {
1122:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****             r = r->next;
1123:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           }
1124:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           r->next = new_entry;
1125:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         } else {
1126:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           /* queue did not exist, first item in queue */
1127:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           arp_table[i].q = new_entry;
1128:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         }
1129:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"
1130:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         result = ERR_OK;
1131:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       } else {
1132:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* the pool MEMP_ARP_QUEUE is empty */
1133:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         pbuf_free(p);
1134:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_R
1135:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         result = ERR_MEM;
1136:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1137:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else /* ARP_QUEUEING */
1138:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* always queue one packet per ARP request only, freeing a previously queued packet */
1139:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (arp_table[i].q != NULL) {
 1946              	 .loc 1 1139 0
 1947 018c 97F91720 	 ldrsb r2,[r7,#23]
 1948 0190 1649     	 ldr r1,.L114
 1949 0192 1346     	 mov r3,r2
 1950 0194 9B00     	 lsls r3,r3,#2
 1951 0196 1344     	 add r3,r3,r2
 1952 0198 9B00     	 lsls r3,r3,#2
 1953 019a 0B44     	 add r3,r3,r1
 1954 019c 1B68     	 ldr r3,[r3]
 1955 019e 002B     	 cmp r3,#0
 1956 01a0 0BD0     	 beq .L113
1140:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
1141:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         pbuf_free(arp_table[i].q);
 1957              	 .loc 1 1141 0
 1958 01a2 97F91720 	 ldrsb r2,[r7,#23]
 1959 01a6 1149     	 ldr r1,.L114
 1960 01a8 1346     	 mov r3,r2
 1961 01aa 9B00     	 lsls r3,r3,#2
 1962 01ac 1344     	 add r3,r3,r2
 1963 01ae 9B00     	 lsls r3,r3,#2
 1964 01b0 0B44     	 add r3,r3,r1
 1965 01b2 1B68     	 ldr r3,[r3]
 1966 01b4 1846     	 mov r0,r3
 1967 01b6 FFF7FEFF 	 bl pbuf_free
 1968              	.L113:
1142:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1143:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       arp_table[i].q = p;
 1969              	 .loc 1 1143 0
 1970 01ba 97F91720 	 ldrsb r2,[r7,#23]
 1971 01be 0B49     	 ldr r1,.L114
 1972 01c0 1346     	 mov r3,r2
 1973 01c2 9B00     	 lsls r3,r3,#2
 1974 01c4 1344     	 add r3,r3,r2
 1975 01c6 9B00     	 lsls r3,r3,#2
 1976 01c8 0B44     	 add r3,r3,r1
 1977 01ca 3A6A     	 ldr r2,[r7,#32]
 1978 01cc 1A60     	 str r2,[r3]
1144:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       result = ERR_OK;
 1979              	 .loc 1 1144 0
 1980 01ce 0023     	 movs r3,#0
 1981 01d0 87F82730 	 strb r3,[r7,#39]
 1982 01d4 02E0     	 b .L104
 1983              	.L112:
1145:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S1
1146:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ARP_QUEUEING */
1147:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else {
1148:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
1149:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF
1150:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       result = ERR_MEM;
 1984              	 .loc 1 1150 0
 1985 01d6 FF23     	 movs r3,#255
 1986 01d8 87F82730 	 strb r3,[r7,#39]
 1987              	.L104:
 1988              	.LBE7:
1151:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1152:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1153:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return result;
 1989              	 .loc 1 1153 0
 1990 01dc 97F82730 	 ldrb r3,[r7,#39]
 1991              	.L98:
 1992 01e0 5BB2     	 sxtb r3,r3
1154:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 1993              	 .loc 1 1154 0
 1994 01e2 1846     	 mov r0,r3
 1995 01e4 2837     	 adds r7,r7,#40
 1996              	.LCFI53:
 1997              	 .cfi_def_cfa_offset 8
 1998 01e6 BD46     	 mov sp,r7
 1999              	.LCFI54:
 2000              	 .cfi_def_cfa_register 13
 2001              	 
 2002 01e8 80BD     	 pop {r7,pc}
 2003              	.L115:
 2004 01ea 00BF     	 .align 2
 2005              	.L114:
 2006 01ec 00000000 	 .word arp_table
 2007 01f0 00000000 	 .word etharp_cached_entry
 2008              	 .cfi_endproc
 2009              	.LFE138:
 2011              	 .section .text.etharp_raw,"ax",%progbits
 2012              	 .align 2
 2013              	 .thumb
 2014              	 .thumb_func
 2016              	etharp_raw:
 2017              	.LFB139:
1155:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1156:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
1157:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Send a raw ARP packet (opcode and all addresses can be modified)
1158:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1159:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif the lwip network interface on which to send the ARP packet
1160:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ethsrc_addr the source MAC address for the ethernet header
1161:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ethdst_addr the destination MAC address for the ethernet header
1162:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param hwsrc_addr the source MAC address for the ARP protocol header
1163:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipsrc_addr the source IP address for the ARP protocol header
1164:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param hwdst_addr the destination MAC address for the ARP protocol header
1165:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipdst_addr the destination IP address for the ARP protocol header
1166:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param opcode the type of the ARP packet
1167:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return ERR_OK if the ARP packet has been sent
1168:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1169:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         any other err_t on failure
1170:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
1171:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if !LWIP_AUTOIP
1172:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** static
1173:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1174:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
1175:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
1176:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            const struct eth_addr *ethdst_addr,
1177:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
1178:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
1179:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****            const u16_t opcode)
1180:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 2018              	 .loc 1 1180 0
 2019              	 .cfi_startproc
 2020              	 
 2021              	 
 2022 0000 80B5     	 push {r7,lr}
 2023              	.LCFI55:
 2024              	 .cfi_def_cfa_offset 8
 2025              	 .cfi_offset 7,-8
 2026              	 .cfi_offset 14,-4
 2027 0002 88B0     	 sub sp,sp,#32
 2028              	.LCFI56:
 2029              	 .cfi_def_cfa_offset 40
 2030 0004 00AF     	 add r7,sp,#0
 2031              	.LCFI57:
 2032              	 .cfi_def_cfa_register 7
 2033 0006 F860     	 str r0,[r7,#12]
 2034 0008 B960     	 str r1,[r7,#8]
 2035 000a 7A60     	 str r2,[r7,#4]
 2036 000c 3B60     	 str r3,[r7]
1181:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct pbuf *p;
1182:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   err_t result = ERR_OK;
 2037              	 .loc 1 1182 0
 2038 000e 0023     	 movs r3,#0
 2039 0010 FB77     	 strb r3,[r7,#31]
1183:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_hdr *ethhdr;
1184:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct etharp_hdr *hdr;
1185:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
1186:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   const u8_t * ethdst_hwaddr;
1187:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1188:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1189:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
1190:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1191:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* allocate a pbuf for the outgoing ARP request packet */
1192:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 2040              	 .loc 1 1192 0
 2041 0012 0320     	 movs r0,#3
 2042 0014 2C21     	 movs r1,#44
 2043 0016 0022     	 movs r2,#0
 2044 0018 FFF7FEFF 	 bl pbuf_alloc
 2045 001c B861     	 str r0,[r7,#24]
1193:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* could allocate a pbuf for an ARP request? */
1194:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (p == NULL) {
 2046              	 .loc 1 1194 0
 2047 001e BB69     	 ldr r3,[r7,#24]
 2048 0020 002B     	 cmp r3,#0
 2049 0022 01D1     	 bne .L117
1195:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
1196:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ("etharp_raw: could not allocate pbuf for ARP request.\n"));
1197:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.memerr);
1198:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     return ERR_MEM;
 2050              	 .loc 1 1198 0
 2051 0024 FF23     	 movs r3,#255
 2052 0026 61E0     	 b .L118
 2053              	.L117:
1199:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1200:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
1201:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****               (p->len >= SIZEOF_ETHARP_PACKET));
1202:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1203:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 2054              	 .loc 1 1203 0
 2055 0028 BB69     	 ldr r3,[r7,#24]
 2056 002a 5B68     	 ldr r3,[r3,#4]
 2057 002c 7B61     	 str r3,[r7,#20]
1204:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 2058              	 .loc 1 1204 0
 2059 002e 7B69     	 ldr r3,[r7,#20]
 2060 0030 1033     	 adds r3,r3,#16
 2061 0032 3B61     	 str r3,[r7,#16]
1205:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
1206:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr->opcode = htons(opcode);
 2062              	 .loc 1 1206 0
 2063 0034 BB8E     	 ldrh r3,[r7,#52]
 2064 0036 1846     	 mov r0,r3
 2065 0038 FFF7FEFF 	 bl lwip_htons
 2066 003c 0346     	 mov r3,r0
 2067 003e 1A46     	 mov r2,r3
 2068 0040 3B69     	 ldr r3,[r7,#16]
 2069 0042 DA80     	 strh r2,[r3,#6]
1207:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1208:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
1209:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****               (netif->hwaddr_len == ETHARP_HWADDR_LEN));
1210:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
1211:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* If we are using Link-Local, all ARP packets that contain a Link-Local
1212:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * 'sender IP address' MUST be sent using link-layer broadcast instead of
1213:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
1214:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
1215:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1216:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Write the ARP MAC-Addresses */
1217:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 2070              	 .loc 1 1217 0
 2071 0044 3B69     	 ldr r3,[r7,#16]
 2072 0046 0833     	 adds r3,r3,#8
 2073 0048 1846     	 mov r0,r3
 2074 004a 3968     	 ldr r1,[r7]
 2075 004c 0622     	 movs r2,#6
 2076 004e FFF7FEFF 	 bl thumb2_memcpy
1218:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 2077              	 .loc 1 1218 0
 2078 0052 3B69     	 ldr r3,[r7,#16]
 2079 0054 1233     	 adds r3,r3,#18
 2080 0056 1846     	 mov r0,r3
 2081 0058 F96A     	 ldr r1,[r7,#44]
 2082 005a 0622     	 movs r2,#6
 2083 005c FFF7FEFF 	 bl thumb2_memcpy
1219:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Write the Ethernet MAC-Addresses */
1220:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_AUTOIP
1221:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
1222:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #else  /* LWIP_AUTOIP */
1223:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 2084              	 .loc 1 1223 0
 2085 0060 7B69     	 ldr r3,[r7,#20]
 2086 0062 0233     	 adds r3,r3,#2
 2087 0064 1846     	 mov r0,r3
 2088 0066 7968     	 ldr r1,[r7,#4]
 2089 0068 0622     	 movs r2,#6
 2090 006a FFF7FEFF 	 bl thumb2_memcpy
1224:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_AUTOIP */
1225:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 2091              	 .loc 1 1225 0
 2092 006e 7B69     	 ldr r3,[r7,#20]
 2093 0070 0833     	 adds r3,r3,#8
 2094 0072 1846     	 mov r0,r3
 2095 0074 B968     	 ldr r1,[r7,#8]
 2096 0076 0622     	 movs r2,#6
 2097 0078 FFF7FEFF 	 bl thumb2_memcpy
1226:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
1227:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****    * structure packing. */ 
1228:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 2098              	 .loc 1 1228 0
 2099 007c 3B69     	 ldr r3,[r7,#16]
 2100 007e 0E33     	 adds r3,r3,#14
 2101 0080 1846     	 mov r0,r3
 2102 0082 B96A     	 ldr r1,[r7,#40]
 2103 0084 0422     	 movs r2,#4
 2104 0086 FFF7FEFF 	 bl thumb2_memcpy
1229:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 2105              	 .loc 1 1229 0
 2106 008a 3B69     	 ldr r3,[r7,#16]
 2107 008c 1833     	 adds r3,r3,#24
 2108 008e 1846     	 mov r0,r3
 2109 0090 396B     	 ldr r1,[r7,#48]
 2110 0092 0422     	 movs r2,#4
 2111 0094 FFF7FEFF 	 bl thumb2_memcpy
1230:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1231:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 2112              	 .loc 1 1231 0
 2113 0098 3B69     	 ldr r3,[r7,#16]
 2114 009a 0022     	 movs r2,#0
 2115 009c 1A70     	 strb r2,[r3]
 2116 009e 0022     	 movs r2,#0
 2117 00a0 42F00102 	 orr r2,r2,#1
 2118 00a4 5A70     	 strb r2,[r3,#1]
1232:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 2119              	 .loc 1 1232 0
 2120 00a6 3B69     	 ldr r3,[r7,#16]
 2121 00a8 0022     	 movs r2,#0
 2122 00aa 42F00802 	 orr r2,r2,#8
 2123 00ae 9A70     	 strb r2,[r3,#2]
 2124 00b0 0022     	 movs r2,#0
 2125 00b2 DA70     	 strb r2,[r3,#3]
1233:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* set hwlen and protolen */
1234:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr->hwlen = ETHARP_HWADDR_LEN;
 2126              	 .loc 1 1234 0
 2127 00b4 3B69     	 ldr r3,[r7,#16]
 2128 00b6 0622     	 movs r2,#6
 2129 00b8 1A71     	 strb r2,[r3,#4]
1235:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   hdr->protolen = sizeof(ip_addr_t);
 2130              	 .loc 1 1235 0
 2131 00ba 3B69     	 ldr r3,[r7,#16]
 2132 00bc 0422     	 movs r2,#4
 2133 00be 5A71     	 strb r2,[r3,#5]
1236:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1237:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 2134              	 .loc 1 1237 0
 2135 00c0 7B69     	 ldr r3,[r7,#20]
 2136 00c2 0022     	 movs r2,#0
 2137 00c4 42F00802 	 orr r2,r2,#8
 2138 00c8 9A73     	 strb r2,[r3,#14]
 2139 00ca 0022     	 movs r2,#0
 2140 00cc 42F00602 	 orr r2,r2,#6
 2141 00d0 DA73     	 strb r2,[r3,#15]
1238:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* send ARP query */
1239:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   result = netif->linkoutput(netif, p);
 2142              	 .loc 1 1239 0
 2143 00d2 FB68     	 ldr r3,[r7,#12]
 2144 00d4 9B69     	 ldr r3,[r3,#24]
 2145 00d6 F868     	 ldr r0,[r7,#12]
 2146 00d8 B969     	 ldr r1,[r7,#24]
 2147 00da 9847     	 blx r3
 2148 00dc 0346     	 mov r3,r0
 2149 00de FB77     	 strb r3,[r7,#31]
1240:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ETHARP_STATS_INC(etharp.xmit);
1241:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* free ARP query packet */
1242:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   pbuf_free(p);
 2150              	 .loc 1 1242 0
 2151 00e0 B869     	 ldr r0,[r7,#24]
 2152 00e2 FFF7FEFF 	 bl pbuf_free
1243:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   p = NULL;
 2153              	 .loc 1 1243 0
 2154 00e6 0023     	 movs r3,#0
 2155 00e8 BB61     	 str r3,[r7,#24]
1244:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* could not allocate pbuf for ARP request */
1245:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1246:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return result;
 2156              	 .loc 1 1246 0
 2157 00ea FB7F     	 ldrb r3,[r7,#31]
 2158              	.L118:
 2159 00ec 5BB2     	 sxtb r3,r3
1247:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 2160              	 .loc 1 1247 0
 2161 00ee 1846     	 mov r0,r3
 2162 00f0 2037     	 adds r7,r7,#32
 2163              	.LCFI58:
 2164              	 .cfi_def_cfa_offset 8
 2165 00f2 BD46     	 mov sp,r7
 2166              	.LCFI59:
 2167              	 .cfi_def_cfa_register 13
 2168              	 
 2169 00f4 80BD     	 pop {r7,pc}
 2170              	 .cfi_endproc
 2171              	.LFE139:
 2173 00f6 00BF     	 .section .text.etharp_request,"ax",%progbits
 2174              	 .align 2
 2175              	 .global etharp_request
 2176              	 .thumb
 2177              	 .thumb_func
 2179              	etharp_request:
 2180              	.LFB140:
1248:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1249:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
1250:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Send an ARP request packet asking for ipaddr.
1251:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1252:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif the lwip network interface on which to send the request
1253:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param ipaddr the IP address for which to ask
1254:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @return ERR_OK if the request has been sent
1255:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1256:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *         any other err_t on failure
1257:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
1258:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
1259:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** etharp_request(struct netif *netif, ip_addr_t *ipaddr)
1260:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 2181              	 .loc 1 1260 0
 2182              	 .cfi_startproc
 2183              	 
 2184              	 
 2185 0000 90B5     	 push {r4,r7,lr}
 2186              	.LCFI60:
 2187              	 .cfi_def_cfa_offset 12
 2188              	 .cfi_offset 4,-12
 2189              	 .cfi_offset 7,-8
 2190              	 .cfi_offset 14,-4
 2191 0002 87B0     	 sub sp,sp,#28
 2192              	.LCFI61:
 2193              	 .cfi_def_cfa_offset 40
 2194 0004 04AF     	 add r7,sp,#16
 2195              	.LCFI62:
 2196              	 .cfi_def_cfa 7,24
 2197 0006 7860     	 str r0,[r7,#4]
 2198 0008 3960     	 str r1,[r7]
1261:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
1262:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 2199              	 .loc 1 1262 0
 2200 000a 7B68     	 ldr r3,[r7,#4]
 2201 000c 03F12702 	 add r2,r3,#39
1263:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                     (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 2202              	 .loc 1 1263 0
 2203 0010 7B68     	 ldr r3,[r7,#4]
 2204 0012 03F12704 	 add r4,r3,#39
 2205 0016 7B68     	 ldr r3,[r7,#4]
 2206 0018 0433     	 adds r3,r3,#4
1262:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                     (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 2207              	 .loc 1 1262 0
 2208 001a 0093     	 str r3,[sp]
 2209 001c 084B     	 ldr r3,.L121
 2210 001e 0193     	 str r3,[sp,#4]
 2211 0020 3B68     	 ldr r3,[r7]
 2212 0022 0293     	 str r3,[sp,#8]
 2213 0024 0123     	 movs r3,#1
 2214 0026 0393     	 str r3,[sp,#12]
 2215 0028 7868     	 ldr r0,[r7,#4]
 2216 002a 1146     	 mov r1,r2
 2217 002c 054A     	 ldr r2,.L121+4
 2218 002e 2346     	 mov r3,r4
 2219 0030 FFF7FEFF 	 bl etharp_raw
 2220 0034 0346     	 mov r3,r0
1264:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****                     ipaddr, ARP_REQUEST);
1265:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 2221              	 .loc 1 1265 0
 2222 0036 1846     	 mov r0,r3
 2223 0038 0C37     	 adds r7,r7,#12
 2224              	.LCFI63:
 2225              	 .cfi_def_cfa_offset 12
 2226 003a BD46     	 mov sp,r7
 2227              	.LCFI64:
 2228              	 .cfi_def_cfa_register 13
 2229              	 
 2230 003c 90BD     	 pop {r4,r7,pc}
 2231              	.L122:
 2232 003e 00BF     	 .align 2
 2233              	.L121:
 2234 0040 00000000 	 .word ethzero
 2235 0044 00000000 	 .word ethbroadcast
 2236              	 .cfi_endproc
 2237              	.LFE140:
 2239              	 .section .text.ethernet_input,"ax",%progbits
 2240              	 .align 2
 2241              	 .global ethernet_input
 2242              	 .thumb
 2243              	 .thumb_func
 2245              	ethernet_input:
 2246              	.LFB141:
1266:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_ARP */
1267:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1268:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** /**
1269:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * Process received ethernet frames. Using this function instead of directly
1270:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * calling ip_input and passing ARP frames through etharp in ethernetif_input,
1271:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * the ARP cache is protected from concurrent access.
1272:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  *
1273:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param p the recevied packet, p->payload pointing to the ethernet header
1274:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  * @param netif the network interface on which the packet was received
1275:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****  */
1276:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** err_t
1277:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** ethernet_input(struct pbuf *p, struct netif *netif)
1278:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** {
 2247              	 .loc 1 1278 0
 2248              	 .cfi_startproc
 2249              	 
 2250              	 
 2251 0000 80B5     	 push {r7,lr}
 2252              	.LCFI65:
 2253              	 .cfi_def_cfa_offset 8
 2254              	 .cfi_offset 7,-8
 2255              	 .cfi_offset 14,-4
 2256 0002 86B0     	 sub sp,sp,#24
 2257              	.LCFI66:
 2258              	 .cfi_def_cfa_offset 32
 2259 0004 00AF     	 add r7,sp,#0
 2260              	.LCFI67:
 2261              	 .cfi_def_cfa_register 7
 2262 0006 7860     	 str r0,[r7,#4]
 2263 0008 3960     	 str r1,[r7]
1279:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   struct eth_hdr* ethhdr;
1280:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   u16_t type;
1281:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_ARP || ETHARP_SUPPORT_VLAN
1282:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
 2264              	 .loc 1 1282 0
 2265 000a 1023     	 movs r3,#16
 2266 000c FB82     	 strh r3,[r7,#22]
1283:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
1284:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1285:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (p->len <= SIZEOF_ETH_HDR) {
 2267              	 .loc 1 1285 0
 2268 000e 7B68     	 ldr r3,[r7,#4]
 2269 0010 5B89     	 ldrh r3,[r3,#10]
 2270 0012 102B     	 cmp r3,#16
 2271 0014 00D8     	 bhi .L124
1286:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* a packet with only an ethernet header (or less) is not valid for us */
1287:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.proterr);
1288:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
1289:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     goto free_and_return;
 2272              	 .loc 1 1289 0
 2273 0016 66E0     	 b .L125
 2274              	.L124:
1290:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1291:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1292:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* points to packet payload, which starts with an Ethernet header */
1293:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   ethhdr = (struct eth_hdr *)p->payload;
 2275              	 .loc 1 1293 0
 2276 0018 7B68     	 ldr r3,[r7,#4]
 2277 001a 5B68     	 ldr r3,[r3,#4]
 2278 001c 3B61     	 str r3,[r7,#16]
1294:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
1295:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X
1296:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2]
1297:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5]
1298:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
1299:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
1300:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      (unsigned)htons(ethhdr->type)));
1301:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1302:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   type = ethhdr->type;
 2279              	 .loc 1 1302 0
 2280 001e 3B69     	 ldr r3,[r7,#16]
 2281 0020 9A7B     	 ldrb r2,[r3,#14]
 2282 0022 DB7B     	 ldrb r3,[r3,#15]
 2283 0024 1B02     	 lsls r3,r3,#8
 2284 0026 1343     	 orrs r3,r3,r2
 2285 0028 FB81     	 strh r3,[r7,#14]
1303:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_SUPPORT_VLAN
1304:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (type == PP_HTONS(ETHTYPE_VLAN)) {
1305:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
1306:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
1307:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* a packet with only an ethernet/vlan header (or less) is not valid for us */
1308:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.proterr);
1309:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.drop);
1310:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       goto free_and_return;
1311:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1312:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
1313:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #ifdef ETHARP_VLAN_CHECK_FN
1314:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
1315:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #elif defined(ETHARP_VLAN_CHECK)
1316:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
1317:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif
1318:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* silently ignore this packet: not for our VLAN */
1319:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       pbuf_free(p);
1320:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       return ERR_OK;
1321:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1322:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
1323:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     type = vlan->tpid;
1324:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
1325:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1326:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_SUPPORT_VLAN */
1327:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1328:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_ARP_FILTER_NETIF
1329:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
1330:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_ARP_FILTER_NETIF*/
1331:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1332:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   if (ethhdr->dest.addr[0] & 1) {
 2286              	 .loc 1 1332 0
 2287 002a 3B69     	 ldr r3,[r7,#16]
 2288 002c 9B78     	 ldrb r3,[r3,#2]
 2289 002e 03F00103 	 and r3,r3,#1
 2290 0032 002B     	 cmp r3,#0
 2291 0034 24D0     	 beq .L126
1333:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* this might be a multicast or broadcast packet */
1334:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 2292              	 .loc 1 1334 0
 2293 0036 3B69     	 ldr r3,[r7,#16]
 2294 0038 9B78     	 ldrb r3,[r3,#2]
 2295 003a 012B     	 cmp r3,#1
 2296 003c 0FD1     	 bne .L127
1335:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2297              	 .loc 1 1335 0
 2298 003e 3B69     	 ldr r3,[r7,#16]
 2299 0040 DB78     	 ldrb r3,[r3,#3]
 2300 0042 002B     	 cmp r3,#0
 2301 0044 1CD1     	 bne .L126
1336:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****           (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
 2302              	 .loc 1 1336 0 discriminator 1
 2303 0046 3B69     	 ldr r3,[r7,#16]
 2304 0048 1B79     	 ldrb r3,[r3,#4]
1335:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2305              	 .loc 1 1335 0 discriminator 1
 2306 004a 5E2B     	 cmp r3,#94
 2307 004c 18D1     	 bne .L126
1337:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* mark the pbuf as link-layer multicast */
1338:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         p->flags |= PBUF_FLAG_LLMCAST;
 2308              	 .loc 1 1338 0
 2309 004e 7B68     	 ldr r3,[r7,#4]
 2310 0050 5B7B     	 ldrb r3,[r3,#13]
 2311 0052 43F01003 	 orr r3,r3,#16
 2312 0056 DAB2     	 uxtb r2,r3
 2313 0058 7B68     	 ldr r3,[r7,#4]
 2314 005a 5A73     	 strb r2,[r3,#13]
 2315 005c 10E0     	 b .L126
 2316              	.L127:
1339:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1340:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 2317              	 .loc 1 1340 0
 2318 005e 3B69     	 ldr r3,[r7,#16]
 2319 0060 0233     	 adds r3,r3,#2
 2320 0062 1846     	 mov r0,r3
 2321 0064 2449     	 ldr r1,.L137
 2322 0066 0622     	 movs r2,#6
 2323 0068 FFF7FEFF 	 bl memcmp
 2324 006c 0346     	 mov r3,r0
 2325 006e 002B     	 cmp r3,#0
 2326 0070 06D1     	 bne .L126
1341:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* mark the pbuf as link-layer broadcast */
1342:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       p->flags |= PBUF_FLAG_LLBCAST;
 2327              	 .loc 1 1342 0
 2328 0072 7B68     	 ldr r3,[r7,#4]
 2329 0074 5B7B     	 ldrb r3,[r3,#13]
 2330 0076 43F00803 	 orr r3,r3,#8
 2331 007a DAB2     	 uxtb r2,r3
 2332 007c 7B68     	 ldr r3,[r7,#4]
 2333 007e 5A73     	 strb r2,[r3,#13]
 2334              	.L126:
1343:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     }
1344:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1345:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1346:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   switch (type) {
 2335              	 .loc 1 1346 0
 2336 0080 FB89     	 ldrh r3,[r7,#14]
 2337 0082 082B     	 cmp r3,#8
 2338 0084 03D0     	 beq .L130
 2339 0086 B3F5C16F 	 cmp r3,#1544
 2340 008a 1AD0     	 beq .L131
1347:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if LWIP_ARP
1348:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     /* IP packet? */
1349:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     case PP_HTONS(ETHTYPE_IP):
1350:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (!(netif->flags & NETIF_FLAG_ETHARP)) {
1351:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         goto free_and_return;
1352:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1353:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if ETHARP_TRUST_IP_MAC
1354:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* update ARP table */
1355:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       etharp_ip_input(netif, p);
1356:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* ETHARP_TRUST_IP_MAC */
1357:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* skip Ethernet header */
1358:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if(pbuf_header(p, -ip_hdr_offset)) {
1359:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_ASSERT("Can't move over header in packet", 0);
1360:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         goto free_and_return;
1361:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       } else {
1362:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         /* pass to IP layer */
1363:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         ip_input(p, netif);
1364:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1365:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       break;
1366:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       
1367:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     case PP_HTONS(ETHTYPE_ARP):
1368:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       if (!(netif->flags & NETIF_FLAG_ETHARP)) {
1369:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         goto free_and_return;
1370:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
1371:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       /* pass p to ARP module */
1372:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
1373:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       break;
1374:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_ARP */
1375:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #if PPPOE_SUPPORT
1376:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
1377:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       pppoe_disc_input(netif, p);
1378:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       break;
1379:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1380:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
1381:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       pppoe_data_input(netif, p);
1382:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       break;
1383:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* PPPOE_SUPPORT */
1384:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1385:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****     default:
1386:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.proterr);
1387:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       ETHARP_STATS_INC(etharp.drop);
1388:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       goto free_and_return;
 2341              	 .loc 1 1388 0
 2342 008c 2BE0     	 b .L125
 2343              	.L130:
1350:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         goto free_and_return;
 2344              	 .loc 1 1350 0
 2345 008e 3B68     	 ldr r3,[r7]
 2346 0090 93F82D30 	 ldrb r3,[r3,#45]
 2347 0094 03F02003 	 and r3,r3,#32
 2348 0098 002B     	 cmp r3,#0
 2349 009a 00D1     	 bne .L132
1351:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 2350              	 .loc 1 1351 0
 2351 009c 23E0     	 b .L125
 2352              	.L132:
1358:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         LWIP_ASSERT("Can't move over header in packet", 0);
 2353              	 .loc 1 1358 0
 2354 009e FB8A     	 ldrh r3,[r7,#22]
 2355 00a0 5B42     	 negs r3,r3
 2356 00a2 9BB2     	 uxth r3,r3
 2357 00a4 9BB2     	 uxth r3,r3
 2358 00a6 1BB2     	 sxth r3,r3
 2359 00a8 7868     	 ldr r0,[r7,#4]
 2360 00aa 1946     	 mov r1,r3
 2361 00ac FFF7FEFF 	 bl pbuf_header
 2362 00b0 0346     	 mov r3,r0
 2363 00b2 002B     	 cmp r3,#0
 2364 00b4 00D0     	 beq .L133
1360:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       } else {
 2365              	 .loc 1 1360 0
 2366 00b6 16E0     	 b .L125
 2367              	.L133:
1363:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 2368              	 .loc 1 1363 0
 2369 00b8 7868     	 ldr r0,[r7,#4]
 2370 00ba 3968     	 ldr r1,[r7]
 2371 00bc FFF7FEFF 	 bl ip_input
1365:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       
 2372              	 .loc 1 1365 0
 2373 00c0 0FE0     	 b .L134
 2374              	.L131:
1368:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****         goto free_and_return;
 2375              	 .loc 1 1368 0
 2376 00c2 3B68     	 ldr r3,[r7]
 2377 00c4 93F82D30 	 ldrb r3,[r3,#45]
 2378 00c8 03F02003 	 and r3,r3,#32
 2379 00cc 002B     	 cmp r3,#0
 2380 00ce 00D1     	 bne .L135
1369:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       }
 2381              	 .loc 1 1369 0
 2382 00d0 09E0     	 b .L125
 2383              	.L135:
1372:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****       break;
 2384              	 .loc 1 1372 0
 2385 00d2 3B68     	 ldr r3,[r7]
 2386 00d4 2733     	 adds r3,r3,#39
 2387 00d6 3868     	 ldr r0,[r7]
 2388 00d8 1946     	 mov r1,r3
 2389 00da 7A68     	 ldr r2,[r7,#4]
 2390 00dc FFF7FEFF 	 bl etharp_arp_input
1373:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** #endif /* LWIP_ARP */
 2391              	 .loc 1 1373 0
 2392 00e0 00BF     	 nop
 2393              	.L134:
1389:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   }
1390:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1391:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   /* This means the pbuf is freed or consumed,
1392:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****      so the caller doesn't have to free it again */
1393:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return ERR_OK;
 2394              	 .loc 1 1393 0
 2395 00e2 0023     	 movs r3,#0
 2396 00e4 03E0     	 b .L136
 2397              	.L125:
1394:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** 
1395:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** free_and_return:
1396:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   pbuf_free(p);
 2398              	 .loc 1 1396 0
 2399 00e6 7868     	 ldr r0,[r7,#4]
 2400 00e8 FFF7FEFF 	 bl pbuf_free
1397:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c ****   return ERR_OK;
 2401              	 .loc 1 1397 0
 2402 00ec 0023     	 movs r3,#0
 2403              	.L136:
 2404 00ee 5BB2     	 sxtb r3,r3
1398:../Dave/Generated/ETH_LWIP/lwip/netif/etharp.c **** }
 2405              	 .loc 1 1398 0
 2406 00f0 1846     	 mov r0,r3
 2407 00f2 1837     	 adds r7,r7,#24
 2408              	.LCFI68:
 2409              	 .cfi_def_cfa_offset 8
 2410 00f4 BD46     	 mov sp,r7
 2411              	.LCFI69:
 2412              	 .cfi_def_cfa_register 13
 2413              	 
 2414 00f6 80BD     	 pop {r7,pc}
 2415              	.L138:
 2416              	 .align 2
 2417              	.L137:
 2418 00f8 00000000 	 .word ethbroadcast
 2419              	 .cfi_endproc
 2420              	.LFE141:
 2422              	 .text
 2423              	.Letext0:
 2424              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2425              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2426              	 .file 4 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/lwip/../../port/include/arch/cc.h"
 2427              	 .file 5 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/ipv4/lwip/ip_addr.h"
 2428              	 .file 6 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/ipv4/lwip/../../lwip/err.h"
 2429              	 .file 7 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/ipv4/lwip/../../lwip/pbuf.h"
 2430              	 .file 8 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/ipv4/lwip/../../lwip/netif.h"
 2431              	 .file 9 "../Dave/Generated/ETH_LWIP/lwip/netif/../include/netif/etharp.h"
 2432              	 .file 10 "C:/Users/Will/Documents/GitHub/Launch-DAQ/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 etharp.c
    {standard input}:24     .rodata.ethbroadcast:00000000 ethbroadcast
    {standard input}:21     .rodata.ethbroadcast:00000000 $d
    {standard input}:36     .rodata.ethzero:00000000 ethzero
    {standard input}:33     .rodata.ethzero:00000000 $d
    {standard input}:39     .bss.arp_table:00000000 $d
    {standard input}:42     .bss.arp_table:00000000 arp_table
    {standard input}:47     .bss.etharp_cached_entry:00000000 etharp_cached_entry
    {standard input}:48     .bss.etharp_cached_entry:00000000 $d
    {standard input}:50     .text.etharp_free_entry:00000000 $t
    {standard input}:54     .text.etharp_free_entry:00000000 etharp_free_entry
    {standard input}:129    .text.etharp_free_entry:00000060 $d
    {standard input}:134    .text.etharp_tmr:00000000 $t
    {standard input}:139    .text.etharp_tmr:00000000 etharp_tmr
    {standard input}:289    .text.etharp_tmr:000000d8 $d
    {standard input}:294    .text.etharp_find_entry:00000000 $t
    {standard input}:298    .text.etharp_find_entry:00000000 etharp_find_entry
    {standard input}:617    .text.etharp_find_entry:000001e4 $d
    {standard input}:622    .text.etharp_send_ip:00000000 $t
    {standard input}:626    .text.etharp_send_ip:00000000 etharp_send_ip
    {standard input}:693    .text.etharp_update_arp_entry:00000000 $t
    {standard input}:697    .text.etharp_update_arp_entry:00000000 etharp_update_arp_entry
    {standard input}:873    .text.etharp_update_arp_entry:00000118 $d
    {standard input}:878    .text.etharp_cleanup_netif:00000000 $t
    {standard input}:883    .text.etharp_cleanup_netif:00000000 etharp_cleanup_netif
    {standard input}:962    .text.etharp_cleanup_netif:0000005c $d
    {standard input}:967    .text.etharp_find_addr:00000000 $t
    {standard input}:972    .text.etharp_find_addr:00000000 etharp_find_addr
    {standard input}:1059   .text.etharp_find_addr:00000078 $d
    {standard input}:1064   .text.etharp_arp_input:00000000 $t
    {standard input}:1068   .text.etharp_arp_input:00000000 etharp_arp_input
    {standard input}:1318   .text.etharp_output_to_arp_index:00000000 $t
    {standard input}:1322   .text.etharp_output_to_arp_index:00000000 etharp_output_to_arp_index
    {standard input}:2179   .text.etharp_request:00000000 etharp_request
    {standard input}:1428   .text.etharp_output_to_arp_index:00000098 $d
    {standard input}:1433   .text.etharp_output:00000000 $t
    {standard input}:1438   .text.etharp_output:00000000 etharp_output
    {standard input}:1701   .text.etharp_query:00000000 etharp_query
    {standard input}:1689   .text.etharp_output:00000184 $d
    {standard input}:1696   .text.etharp_query:00000000 $t
    {standard input}:2006   .text.etharp_query:000001ec $d
    {standard input}:2012   .text.etharp_raw:00000000 $t
    {standard input}:2016   .text.etharp_raw:00000000 etharp_raw
    {standard input}:2174   .text.etharp_request:00000000 $t
    {standard input}:2234   .text.etharp_request:00000040 $d
    {standard input}:2240   .text.ethernet_input:00000000 $t
    {standard input}:2245   .text.ethernet_input:00000000 ethernet_input
    {standard input}:2418   .text.ethernet_input:000000f8 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pbuf_free
thumb2_memcpy
ip4_addr_isbroadcast
lwip_htons
pbuf_header
pbuf_alloc
pbuf_copy
pbuf_ref
memcmp
ip_input
