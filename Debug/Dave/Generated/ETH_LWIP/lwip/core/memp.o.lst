   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "memp.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .bss.memp_tab,"aw",%nobits
  20              	 .align 2
  23              	memp_tab:
  24 0000 00000000 	 .space 24
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              	 .section .rodata.memp_sizes,"a",%progbits
  26              	 .align 2
  29              	memp_sizes:
  30 0000 1C00     	 .short 28
  31 0002 2400     	 .short 36
  32 0004 1400     	 .short 20
  33 0006 1000     	 .short 16
  34 0008 1000     	 .short 16
  35 000a 1006     	 .short 1552
  36              	 .section .rodata.memp_num,"a",%progbits
  37              	 .align 2
  40              	memp_num:
  41 0000 0400     	 .short 4
  42 0002 0400     	 .short 4
  43 0004 0800     	 .short 8
  44 0006 0700     	 .short 7
  45 0008 1000     	 .short 16
  46 000a 1000     	 .short 16
  47              	 .section .bss.memp_memory,"aw",%nobits
  48              	 .align 2
  51              	memp_memory:
  52 0000 00000000 	 .space 25619
  52      00000000 
  52      00000000 
  52      00000000 
  52      00000000 
  53 6413 00       	 .section .text.memp_init,"ax",%progbits
  54              	 .align 2
  55              	 .global memp_init
  56              	 .thumb
  57              	 .thumb_func
  59              	memp_init:
  60              	.LFB133:
  61              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/core/memp.c"
   1:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Dynamic pool memory manager
   4:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
   5:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * lwIP has dedicated pools for many structures (netconn, protocol control blocks,
   6:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * packet buffers, ...). All these pools are managed here.
   7:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
   8:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
   9:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /*
  10:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  11:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * All rights reserved. 
  12:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 
  13:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Redistribution and use in source and binary forms, with or without modification, 
  14:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * are permitted provided that the following conditions are met:
  15:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
  16:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *    this list of conditions and the following disclaimer.
  18:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *    and/or other materials provided with the distribution.
  21:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 3. The name of the author may not be used to endorse or promote products
  22:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *    derived from this software without specific prior written permission. 
  23:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
  24:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
  25:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  26:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
  27:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
  28:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
  29:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  30:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  31:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
  32:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  33:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * OF SUCH DAMAGE.
  34:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
  35:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * This file is part of the lwIP TCP/IP stack.
  36:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 
  37:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Author: Adam Dunkels <adam@sics.se>
  38:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
  39:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
  40:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  41:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/opt.h"
  42:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  43:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/memp.h"
  44:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/pbuf.h"
  45:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/udp.h"
  46:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/raw.h"
  47:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/tcp_impl.h"
  48:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/ipv4/lwip/igmp.h"
  49:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/api.h"
  50:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/api_msg.h"
  51:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/tcpip.h"
  52:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/sys.h"
  53:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/timers.h"
  54:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/stats.h"
  55:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/netif/etharp.h"
  56:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/ipv4/lwip/ip_frag.h"
  57:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/snmp_structs.h"
  58:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/snmp_msg.h"
  59:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/dns.h"
  60:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/netif/ppp_oe.h"
  61:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  62:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include <string.h>
  63:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  64:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if !MEMP_MEM_MALLOC /* don't build if not configured for use in lwipopts.h */
  65:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  66:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** struct memp {
  67:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *next;
  68:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
  69:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   const char *file;
  70:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   int line;
  71:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
  72:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** };
  73:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
  74:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
  75:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /* if MEMP_OVERFLOW_CHECK is turned on, we reserve some bytes at the beginning
  76:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * and at the end of each element, initialize them as 0xcd and check
  77:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * them later. */
  78:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /* If MEMP_OVERFLOW_CHECK is >= 2, on every call to memp_malloc or memp_free,
  79:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * every single element in each pool is checked!
  80:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * This is VERY SLOW but also very helpful. */
  81:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /* MEMP_SANITY_REGION_BEFORE and MEMP_SANITY_REGION_AFTER can be overridden in
  82:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * lwipopts.h to change the amount reserved for checking. */
  83:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #ifndef MEMP_SANITY_REGION_BEFORE
  84:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE  16
  85:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_BEFORE*/
  86:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE > 0
  87:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE_ALIGNED    LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_BEFORE)
  88:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else
  89:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_BEFORE_ALIGNED    0
  90:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_BEFORE*/
  91:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #ifndef MEMP_SANITY_REGION_AFTER
  92:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER   16
  93:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_AFTER*/
  94:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER > 0
  95:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_AFTER)
  96:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else
  97:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SANITY_REGION_AFTER_ALIGNED     0
  98:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_REGION_AFTER*/
  99:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 100:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /* MEMP_SIZE: save space for struct memp and for sanity check */
 101:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SIZE          (LWIP_MEM_ALIGN_SIZE(sizeof(struct memp)) + MEMP_SANITY_REGION_BEFORE_AL
 102:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x) + MEMP_SANITY_REGION_AFTER_ALIGNED)
 103:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 104:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else /* MEMP_OVERFLOW_CHECK */
 105:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 106:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /* No sanity checks
 107:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * We don't need to preserve the struct memp while not allocated, so we
 108:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * can save a little space and set MEMP_SIZE to 0.
 109:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 110:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_SIZE           0
 111:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
 112:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 113:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 114:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 115:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This array holds the first free element of each pool.
 116:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *  Elements form a linked list. */
 117:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static struct memp *memp_tab[MEMP_MAX];
 118:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 119:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else /* MEMP_MEM_MALLOC */
 120:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 121:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
 122:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 123:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_MEM_MALLOC */
 124:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 125:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This array holds the element sizes of each pool. */
 126:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if !MEM_USE_POOLS && !MEMP_MEM_MALLOC
 127:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static
 128:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 129:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** const u16_t memp_sizes[MEMP_MAX] = {
 130:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  LWIP_MEM_ALIGN_SIZE(size),
 131:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/memp_std.h"
 132:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** };
 133:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 134:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if !MEMP_MEM_MALLOC /* don't build if not configured for use in lwipopts.h */
 135:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 136:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This array holds the number of elements in each pool. */
 137:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static const u16_t memp_num[MEMP_MAX] = {
 138:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  (num),
 139:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/memp_std.h"
 140:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** };
 141:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 142:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This array holds a textual description of each pool. */
 143:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #ifdef LWIP_DEBUG
 144:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static const char *memp_desc[MEMP_MAX] = {
 145:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc)  (desc),
 146:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/memp_std.h"
 147:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** };
 148:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* LWIP_DEBUG */
 149:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 150:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SEPARATE_POOLS
 151:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 152:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This creates each memory pool. These are named memp_memory_XXX_base (where
 153:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * XXX is the name of the pool defined in memp_std.h).
 154:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * To relocate a pool, declare it as extern in cc.h. Example for GCC:
 155:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *   extern u8_t __attribute__((section(".onchip_mem"))) memp_memory_UDP_PCB_base[];
 156:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 157:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc) u8_t memp_memory_ ## name ## _base \
 158:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   [((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))];   
 159:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "lwip/memp_std.h"
 160:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 161:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This array holds the base of each memory pool. */
 162:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static u8_t *const memp_bases[] = { 
 163:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc) memp_memory_ ## name ## _base,   
 164:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "lwip/memp_std.h"
 165:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** };
 166:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 167:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else /* MEMP_SEPARATE_POOLS */
 168:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 169:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /** This is the actual memory used by the pools (all pools in one big block). */
 170:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static u8_t memp_memory[MEM_ALIGNMENT - 1 
 171:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc) + ( (num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size) ) )
 172:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "../include/lwip/memp_std.h"
 173:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** ];
 174:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 175:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SEPARATE_POOLS */
 176:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 177:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_CHECK
 178:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 179:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Check that memp-lists don't form a circle, using "Floyd's cycle-finding algorithm".
 180:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 181:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static int
 182:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_sanity(void)
 183:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 184:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   s16_t i;
 185:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *t, *h;
 186:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 187:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; i++) {
 188:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     t = memp_tab[i];
 189:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     if(t != NULL) {
 190:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       for (h = t->next; (t != NULL) && (h != NULL); t = t->next,
 191:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         h = (((h->next != NULL) && (h->next->next != NULL)) ? h->next->next : NULL)) {
 192:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         if (t == h) {
 193:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****           return 0;
 194:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         }
 195:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       }
 196:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 197:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 198:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   return 1;
 199:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 200:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_CHECK*/
 201:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 202:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if defined(LWIP_DEBUG) && MEMP_STATS
 203:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static const char * memp_overflow_names[] = {
 204:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #define LWIP_MEMPOOL(name,num,size,desc) "/"desc,
 205:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #include "lwip/memp_std.h"
 206:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   };
 207:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 208:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 209:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 210:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Check if a memp element was victim of an overflow
 211:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * (e.g. the restricted area after it has been altered)
 212:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 213:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param p the memp element to check
 214:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param memp_type the pool p comes from
 215:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 216:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static void
 217:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_overflow_check_element_overflow(struct memp *p, u16_t memp_type)
 218:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 219:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u16_t k;
 220:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u8_t *m;
 221:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
 222:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   m = (u8_t*)p + MEMP_SIZE + memp_sizes[memp_type];
 223:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (k = 0; k < MEMP_SANITY_REGION_AFTER_ALIGNED; k++) {
 224:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     if (m[k] != 0xcd) {
 225:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       char errstr[128] = "detected memp overflow in pool ";
 226:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       char digit[] = "0";
 227:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       if(memp_type >= 10) {
 228:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         digit[0] = '0' + (memp_type/10);
 229:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         strcat(errstr, digit);
 230:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       }
 231:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       digit[0] = '0' + (memp_type%10);
 232:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       strcat(errstr, digit);
 233:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if defined(LWIP_DEBUG) && MEMP_STATS
 234:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       strcat(errstr, memp_overflow_names[memp_type]);
 235:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 236:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       LWIP_ASSERT(errstr, 0);
 237:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 238:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 239:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 240:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 241:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 242:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 243:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Check if a memp element was victim of an underflow
 244:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * (e.g. the restricted area before it has been altered)
 245:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 246:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param p the memp element to check
 247:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param memp_type the pool p comes from
 248:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 249:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static void
 250:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_overflow_check_element_underflow(struct memp *p, u16_t memp_type)
 251:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 252:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u16_t k;
 253:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u8_t *m;
 254:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
 255:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
 256:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (k = 0; k < MEMP_SANITY_REGION_BEFORE_ALIGNED; k++) {
 257:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     if (m[k] != 0xcd) {
 258:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       char errstr[128] = "detected memp underflow in pool ";
 259:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       char digit[] = "0";
 260:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       if(memp_type >= 10) {
 261:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         digit[0] = '0' + (memp_type/10);
 262:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         strcat(errstr, digit);
 263:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       }
 264:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       digit[0] = '0' + (memp_type%10);
 265:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       strcat(errstr, digit);
 266:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if defined(LWIP_DEBUG) && MEMP_STATS
 267:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       strcat(errstr, memp_overflow_names[memp_type]);
 268:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 269:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       LWIP_ASSERT(errstr, 0);
 270:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 271:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 272:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 273:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 274:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 275:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 276:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Do an overflow check for all elements in every pool.
 277:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 278:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @see memp_overflow_check_element for a description of the check
 279:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 280:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static void
 281:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_overflow_check_all(void)
 282:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 283:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u16_t i, j;
 284:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *p;
 285:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 286:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   p = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 287:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 288:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     p = p;
 289:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 290:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp_overflow_check_element_overflow(p, i);
 291:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       p = (struct memp*)((u8_t*)p + MEMP_SIZE + memp_sizes[i] + MEMP_SANITY_REGION_AFTER_ALIGNED);
 292:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 293:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 294:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   p = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 295:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 296:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     p = p;
 297:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 298:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp_overflow_check_element_underflow(p, i);
 299:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       p = (struct memp*)((u8_t*)p + MEMP_SIZE + memp_sizes[i] + MEMP_SANITY_REGION_AFTER_ALIGNED);
 300:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 301:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 302:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 303:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 304:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 305:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Initialize the restricted areas of all memp elements in every pool.
 306:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 307:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** static void
 308:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_overflow_init(void)
 309:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 310:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u16_t i, j;
 311:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *p;
 312:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u8_t *m;
 313:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 314:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   p = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 315:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
 316:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     p = p;
 317:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 318:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
 319:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
 320:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memset(m, 0xcd, MEMP_SANITY_REGION_BEFORE_ALIGNED);
 321:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 322:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
 323:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       m = (u8_t*)p + MEMP_SIZE + memp_sizes[i];
 324:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memset(m, 0xcd, MEMP_SANITY_REGION_AFTER_ALIGNED);
 325:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 326:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       p = (struct memp*)((u8_t*)p + MEMP_SIZE + memp_sizes[i] + MEMP_SANITY_REGION_AFTER_ALIGNED);
 327:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 328:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 329:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 330:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 331:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 332:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 333:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Initialize this module.
 334:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * 
 335:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Carves out memp_memory into linked lists for each pool-type.
 336:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 337:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** void
 338:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_init(void)
 339:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
  62              	 .loc 1 339 0
  63              	 .cfi_startproc
  64              	 
  65              	 
  66              	 
  67 0000 80B4     	 push {r7}
  68              	.LCFI0:
  69              	 .cfi_def_cfa_offset 4
  70              	 .cfi_offset 7,-4
  71 0002 83B0     	 sub sp,sp,#12
  72              	.LCFI1:
  73              	 .cfi_def_cfa_offset 16
  74 0004 00AF     	 add r7,sp,#0
  75              	.LCFI2:
  76              	 .cfi_def_cfa_register 7
 340:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *memp;
 341:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   u16_t i, j;
 342:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 343:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
  77              	 .loc 1 343 0
  78 0006 0023     	 movs r3,#0
  79 0008 7B80     	 strh r3,[r7,#2]
  80 000a 02E0     	 b .L2
  81              	.L3:
  82              	 .loc 1 343 0 is_stmt 0 discriminator 3
  83 000c 7B88     	 ldrh r3,[r7,#2]
  84 000e 0133     	 adds r3,r3,#1
  85 0010 7B80     	 strh r3,[r7,#2]
  86              	.L2:
  87              	 .loc 1 343 0 discriminator 1
  88 0012 7B88     	 ldrh r3,[r7,#2]
  89 0014 052B     	 cmp r3,#5
  90 0016 F9D9     	 bls .L3
 344:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_AVAIL(used, i, 0);
 345:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_AVAIL(max, i, 0);
 346:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_AVAIL(err, i, 0);
 347:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 348:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 349:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 350:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if !MEMP_SEPARATE_POOLS
 351:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
  91              	 .loc 1 351 0 is_stmt 1
  92 0018 1B4B     	 ldr r3,.L8
  93 001a 0333     	 adds r3,r3,#3
  94 001c 23F00303 	 bic r3,r3,#3
  95 0020 7B60     	 str r3,[r7,#4]
 352:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* !MEMP_SEPARATE_POOLS */
 353:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   /* for every pool: */
 354:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   for (i = 0; i < MEMP_MAX; ++i) {
  96              	 .loc 1 354 0
  97 0022 0023     	 movs r3,#0
  98 0024 7B80     	 strh r3,[r7,#2]
  99 0026 27E0     	 b .L4
 100              	.L7:
 355:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp_tab[i] = NULL;
 101              	 .loc 1 355 0
 102 0028 7B88     	 ldrh r3,[r7,#2]
 103 002a 184A     	 ldr r2,.L8+4
 104 002c 0021     	 movs r1,#0
 105 002e 42F82310 	 str r1,[r2,r3,lsl#2]
 356:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SEPARATE_POOLS
 357:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp = (struct memp*)memp_bases[i];
 358:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SEPARATE_POOLS */
 359:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     /* create a linked list of memp elements */
 360:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     for (j = 0; j < memp_num[i]; ++j) {
 106              	 .loc 1 360 0
 107 0032 0023     	 movs r3,#0
 108 0034 3B80     	 strh r3,[r7]
 109 0036 15E0     	 b .L5
 110              	.L6:
 361:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp->next = memp_tab[i];
 111              	 .loc 1 361 0 discriminator 3
 112 0038 7B88     	 ldrh r3,[r7,#2]
 113 003a 144A     	 ldr r2,.L8+4
 114 003c 52F82320 	 ldr r2,[r2,r3,lsl#2]
 115 0040 7B68     	 ldr r3,[r7,#4]
 116 0042 1A60     	 str r2,[r3]
 362:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp_tab[i] = memp;
 117              	 .loc 1 362 0 discriminator 3
 118 0044 7B88     	 ldrh r3,[r7,#2]
 119 0046 1149     	 ldr r1,.L8+4
 120 0048 7A68     	 ldr r2,[r7,#4]
 121 004a 41F82320 	 str r2,[r1,r3,lsl#2]
 363:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 122              	 .loc 1 363 0 discriminator 3
 123 004e 7B88     	 ldrh r3,[r7,#2]
 124 0050 0F4A     	 ldr r2,.L8+8
 125 0052 32F81330 	 ldrh r3,[r2,r3,lsl#1]
 126 0056 1A46     	 mov r2,r3
 127 0058 7B68     	 ldr r3,[r7,#4]
 128 005a 1344     	 add r3,r3,r2
 129 005c 7B60     	 str r3,[r7,#4]
 360:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp->next = memp_tab[i];
 130              	 .loc 1 360 0 discriminator 3
 131 005e 3B88     	 ldrh r3,[r7]
 132 0060 0133     	 adds r3,r3,#1
 133 0062 3B80     	 strh r3,[r7]
 134              	.L5:
 360:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       memp->next = memp_tab[i];
 135              	 .loc 1 360 0 is_stmt 0 discriminator 1
 136 0064 7B88     	 ldrh r3,[r7,#2]
 137 0066 0B4A     	 ldr r2,.L8+12
 138 0068 32F81330 	 ldrh r3,[r2,r3,lsl#1]
 139 006c 3A88     	 ldrh r2,[r7]
 140 006e 9A42     	 cmp r2,r3
 141 0070 E2D3     	 bcc .L6
 354:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp_tab[i] = NULL;
 142              	 .loc 1 354 0 is_stmt 1 discriminator 2
 143 0072 7B88     	 ldrh r3,[r7,#2]
 144 0074 0133     	 adds r3,r3,#1
 145 0076 7B80     	 strh r3,[r7,#2]
 146              	.L4:
 354:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp_tab[i] = NULL;
 147              	 .loc 1 354 0 is_stmt 0 discriminator 1
 148 0078 7B88     	 ldrh r3,[r7,#2]
 149 007a 052B     	 cmp r3,#5
 150 007c D4D9     	 bls .L7
 364:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 365:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****         + MEMP_SANITY_REGION_AFTER_ALIGNED
 366:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 367:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****       );
 368:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     }
 369:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 370:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 371:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_init();
 372:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   /* check everything a first time to see if it worked */
 373:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_check_all();
 374:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 375:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 151              	 .loc 1 375 0 is_stmt 1
 152 007e 0C37     	 adds r7,r7,#12
 153              	.LCFI3:
 154              	 .cfi_def_cfa_offset 4
 155 0080 BD46     	 mov sp,r7
 156              	.LCFI4:
 157              	 .cfi_def_cfa_register 13
 158              	 
 159 0082 5DF8047B 	 ldr r7,[sp],#4
 160              	.LCFI5:
 161              	 .cfi_restore 7
 162              	 .cfi_def_cfa_offset 0
 163 0086 7047     	 bx lr
 164              	.L9:
 165              	 .align 2
 166              	.L8:
 167 0088 00000000 	 .word memp_memory
 168 008c 00000000 	 .word memp_tab
 169 0090 00000000 	 .word memp_sizes
 170 0094 00000000 	 .word memp_num
 171              	 .cfi_endproc
 172              	.LFE133:
 174              	 .section .text.memp_malloc,"ax",%progbits
 175              	 .align 2
 176              	 .global memp_malloc
 177              	 .thumb
 178              	 .thumb_func
 180              	memp_malloc:
 181              	.LFB134:
 376:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 377:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 378:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Get an element from a specific pool.
 379:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 380:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param type the pool to get an element from
 381:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 382:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * the debug version has two more parameters:
 383:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param file file name calling this function
 384:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param line number of line where this function is called
 385:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 386:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @return a pointer to the allocated memory or a NULL pointer on error
 387:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 388:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** void *
 389:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if !MEMP_OVERFLOW_CHECK
 390:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_malloc(memp_t type)
 391:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else
 392:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_malloc_fn(memp_t type, const char* file, const int line)
 393:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif
 394:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 182              	 .loc 1 394 0
 183              	 .cfi_startproc
 184              	 
 185              	 
 186              	 
 187 0000 80B4     	 push {r7}
 188              	.LCFI6:
 189              	 .cfi_def_cfa_offset 4
 190              	 .cfi_offset 7,-4
 191 0002 85B0     	 sub sp,sp,#20
 192              	.LCFI7:
 193              	 .cfi_def_cfa_offset 24
 194 0004 00AF     	 add r7,sp,#0
 195              	.LCFI8:
 196              	 .cfi_def_cfa_register 7
 197 0006 0346     	 mov r3,r0
 198 0008 FB71     	 strb r3,[r7,#7]
 395:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *memp;
 396:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 397:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  
 398:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 199              	 .loc 1 398 0
 200 000a FB79     	 ldrb r3,[r7,#7]
 201 000c 052B     	 cmp r3,#5
 202 000e 02D9     	 bls .L11
 203              	 .loc 1 398 0 is_stmt 0 discriminator 1
 204              	
 205 0010 00BE     	 bkpt 0
 206              	
 207              	 .thumb
 208 0012 0023     	 movs r3,#0
 209 0014 0EE0     	 b .L12
 210              	.L11:
 399:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 400:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_PROTECT(old_level);
 401:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK >= 2
 402:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_check_all();
 403:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK >= 2 */
 404:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 405:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp = memp_tab[type];
 211              	 .loc 1 405 0 is_stmt 1
 212 0016 FB79     	 ldrb r3,[r7,#7]
 213 0018 094A     	 ldr r2,.L14
 214 001a 52F82330 	 ldr r3,[r2,r3,lsl#2]
 215 001e FB60     	 str r3,[r7,#12]
 406:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   
 407:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   if (memp != NULL) {
 216              	 .loc 1 407 0
 217 0020 FB68     	 ldr r3,[r7,#12]
 218 0022 002B     	 cmp r3,#0
 219 0024 05D0     	 beq .L13
 408:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp_tab[type] = memp->next;
 220              	 .loc 1 408 0
 221 0026 FB79     	 ldrb r3,[r7,#7]
 222 0028 FA68     	 ldr r2,[r7,#12]
 223 002a 1268     	 ldr r2,[r2]
 224 002c 0449     	 ldr r1,.L14
 225 002e 41F82320 	 str r2,[r1,r3,lsl#2]
 226              	.L13:
 409:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 410:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp->next = NULL;
 411:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp->file = file;
 412:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp->line = line;
 413:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 414:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_INC_USED(used, type);
 415:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     LWIP_ASSERT("memp_malloc: memp properly aligned",
 416:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****                 ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
 417:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
 418:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   } else {
 419:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", me
 420:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     MEMP_STATS_INC(err, type);
 421:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 422:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 423:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_UNPROTECT(old_level);
 424:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 425:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   return memp;
 227              	 .loc 1 425 0
 228 0032 FB68     	 ldr r3,[r7,#12]
 229              	.L12:
 426:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 230              	 .loc 1 426 0
 231 0034 1846     	 mov r0,r3
 232 0036 1437     	 adds r7,r7,#20
 233              	.LCFI9:
 234              	 .cfi_def_cfa_offset 4
 235 0038 BD46     	 mov sp,r7
 236              	.LCFI10:
 237              	 .cfi_def_cfa_register 13
 238              	 
 239 003a 5DF8047B 	 ldr r7,[sp],#4
 240              	.LCFI11:
 241              	 .cfi_restore 7
 242              	 .cfi_def_cfa_offset 0
 243 003e 7047     	 bx lr
 244              	.L15:
 245              	 .align 2
 246              	.L14:
 247 0040 00000000 	 .word memp_tab
 248              	 .cfi_endproc
 249              	.LFE134:
 251              	 .section .text.memp_free,"ax",%progbits
 252              	 .align 2
 253              	 .global memp_free
 254              	 .thumb
 255              	 .thumb_func
 257              	memp_free:
 258              	.LFB135:
 427:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 428:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** /**
 429:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * Put an element back into its pool.
 430:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  *
 431:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param type the pool where to put mem
 432:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  * @param mem the memp element to free
 433:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****  */
 434:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** void
 435:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** memp_free(memp_t type, void *mem)
 436:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** {
 259              	 .loc 1 436 0
 260              	 .cfi_startproc
 261              	 
 262              	 
 263              	 
 264 0000 80B4     	 push {r7}
 265              	.LCFI12:
 266              	 .cfi_def_cfa_offset 4
 267              	 .cfi_offset 7,-4
 268 0002 85B0     	 sub sp,sp,#20
 269              	.LCFI13:
 270              	 .cfi_def_cfa_offset 24
 271 0004 00AF     	 add r7,sp,#0
 272              	.LCFI14:
 273              	 .cfi_def_cfa_register 7
 274 0006 0346     	 mov r3,r0
 275 0008 3960     	 str r1,[r7]
 276 000a FB71     	 strb r3,[r7,#7]
 437:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   struct memp *memp;
 438:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_DECL_PROTECT(old_level);
 439:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 440:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   if (mem == NULL) {
 277              	 .loc 1 440 0
 278 000c 3B68     	 ldr r3,[r7]
 279 000e 002B     	 cmp r3,#0
 280 0010 00D1     	 bne .L17
 441:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****     return;
 281              	 .loc 1 441 0
 282 0012 0CE0     	 b .L16
 283              	.L17:
 442:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   }
 443:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   LWIP_ASSERT("memp_free: mem properly aligned",
 444:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****                 ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
 445:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 446:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
 284              	 .loc 1 446 0
 285 0014 3B68     	 ldr r3,[r7]
 286 0016 FB60     	 str r3,[r7,#12]
 447:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 448:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_PROTECT(old_level);
 449:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK
 450:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_OVERFLOW_CHECK >= 2
 451:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_check_all();
 452:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #else
 453:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_check_element_overflow(memp, type);
 454:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_overflow_check_element_underflow(memp, type);
 455:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK >= 2 */
 456:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_OVERFLOW_CHECK */
 457:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 458:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   MEMP_STATS_DEC(used, type); 
 459:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   
 460:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp->next = memp_tab[type]; 
 287              	 .loc 1 460 0
 288 0018 FB79     	 ldrb r3,[r7,#7]
 289 001a 074A     	 ldr r2,.L19
 290 001c 52F82320 	 ldr r2,[r2,r3,lsl#2]
 291 0020 FB68     	 ldr r3,[r7,#12]
 292 0022 1A60     	 str r2,[r3]
 461:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   memp_tab[type] = memp;
 293              	 .loc 1 461 0
 294 0024 FB79     	 ldrb r3,[r7,#7]
 295 0026 0449     	 ldr r1,.L19
 296 0028 FA68     	 ldr r2,[r7,#12]
 297 002a 41F82320 	 str r2,[r1,r3,lsl#2]
 298              	.L16:
 462:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 463:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #if MEMP_SANITY_CHECK
 464:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   LWIP_ASSERT("memp sanity", memp_sanity());
 465:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** #endif /* MEMP_SANITY_CHECK */
 466:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** 
 467:../Dave/Generated/ETH_LWIP/lwip/core/memp.c ****   SYS_ARCH_UNPROTECT(old_level);
 468:../Dave/Generated/ETH_LWIP/lwip/core/memp.c **** }
 299              	 .loc 1 468 0
 300 002e 1437     	 adds r7,r7,#20
 301              	.LCFI15:
 302              	 .cfi_def_cfa_offset 4
 303 0030 BD46     	 mov sp,r7
 304              	.LCFI16:
 305              	 .cfi_def_cfa_register 13
 306              	 
 307 0032 5DF8047B 	 ldr r7,[sp],#4
 308              	.LCFI17:
 309              	 .cfi_restore 7
 310              	 .cfi_def_cfa_offset 0
 311 0036 7047     	 bx lr
 312              	.L20:
 313              	 .align 2
 314              	.L19:
 315 0038 00000000 	 .word memp_tab
 316              	 .cfi_endproc
 317              	.LFE135:
 319              	 .text
 320              	.Letext0:
 321              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 322              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 323              	 .file 4 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/../../port/include/arch/cc.h"
 324              	 .file 5 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/memp.h"
 325              	 .file 6 "C:/Users/Will/Documents/GitHub/Launch-DAQ/Libraries/CMSIS/Include/cmsis_gcc.h"
 326              	 .file 7 "C:/Users/Will/Documents/GitHub/Launch-DAQ/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 memp.c
    {standard input}:20     .bss.memp_tab:00000000 $d
    {standard input}:23     .bss.memp_tab:00000000 memp_tab
    {standard input}:26     .rodata.memp_sizes:00000000 $d
    {standard input}:29     .rodata.memp_sizes:00000000 memp_sizes
    {standard input}:37     .rodata.memp_num:00000000 $d
    {standard input}:40     .rodata.memp_num:00000000 memp_num
    {standard input}:48     .bss.memp_memory:00000000 $d
    {standard input}:51     .bss.memp_memory:00000000 memp_memory
    {standard input}:54     .text.memp_init:00000000 $t
    {standard input}:59     .text.memp_init:00000000 memp_init
    {standard input}:167    .text.memp_init:00000088 $d
    {standard input}:175    .text.memp_malloc:00000000 $t
    {standard input}:180    .text.memp_malloc:00000000 memp_malloc
    {standard input}:247    .text.memp_malloc:00000040 $d
    {standard input}:252    .text.memp_free:00000000 $t
    {standard input}:257    .text.memp_free:00000000 memp_free
    {standard input}:315    .text.memp_free:00000038 $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
