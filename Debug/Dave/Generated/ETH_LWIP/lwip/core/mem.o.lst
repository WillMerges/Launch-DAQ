   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "mem.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm ram_heap,1620,4
  20              	 .section .bss.ram,"aw",%nobits
  21              	 .align 2
  24              	ram:
  25 0000 00000000 	 .space 4
  26              	 .section .bss.ram_end,"aw",%nobits
  27              	 .align 2
  30              	ram_end:
  31 0000 00000000 	 .space 4
  32              	 .section .bss.lfree,"aw",%nobits
  33              	 .align 2
  36              	lfree:
  37 0000 00000000 	 .space 4
  38              	 .section .text.plug_holes,"ax",%progbits
  39              	 .align 2
  40              	 .thumb
  41              	 .thumb_func
  43              	plug_holes:
  44              	.LFB128:
  45              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/core/mem.c"
   1:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Dynamic memory manager
   4:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
   5:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * This is a lightweight replacement for the standard C library malloc().
   6:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
   7:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * If you want to use the standard C library malloc() instead, define
   8:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * MEM_LIBC_MALLOC to 1 in your lwipopts.h
   9:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  10:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * To let mem_malloc() use pools (prevents fragmentation and is much faster than
  11:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * a heap but might waste some memory), define MEM_USE_POOLS to 1, define
  12:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * MEM_USE_CUSTOM_POOLS to 1 and create a file "lwippools.h" that includes a list
  13:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * of pools like this (more pools can be added between _START and _END):
  14:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  15:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Define three pools with sizes 256, 512, and 1512 bytes
  16:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL_START
  17:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(20, 256)
  18:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(10, 512)
  19:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL(5, 1512)
  20:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_MALLOC_MEMPOOL_END
  21:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
  22:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  23:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /*
  24:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  25:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * All rights reserved.
  26:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  27:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Redistribution and use in source and binary forms, with or without modification,
  28:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * are permitted provided that the following conditions are met:
  29:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  30:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  31:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *    this list of conditions and the following disclaimer.
  32:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  33:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *    this list of conditions and the following disclaimer in the documentation
  34:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *    and/or other materials provided with the distribution.
  35:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * 3. The name of the author may not be used to endorse or promote products
  36:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *    derived from this software without specific prior written permission.
  37:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  38:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  39:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  40:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  41:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  42:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  43:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  44:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  45:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  46:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  47:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * OF SUCH DAMAGE.
  48:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  49:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * This file is part of the lwIP TCP/IP stack.
  50:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  51:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Author: Adam Dunkels <adam@sics.se>
  52:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *         Simon Goldschmidt
  53:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  54:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
  55:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  56:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/opt.h"
  57:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  58:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if !MEM_LIBC_MALLOC /* don't build if not configured for use in lwipopts.h */
  59:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  60:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/def.h"
  61:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/mem.h"
  62:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/sys.h"
  63:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/stats.h"
  64:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include "../include/lwip/err.h"
  65:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  66:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #include <string.h>
  67:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  68:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if MEM_USE_POOLS
  69:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* lwIP head implemented with different sized pools */
  70:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  71:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
  72:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Allocate memory: determine the smallest pool that is big enough
  73:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * to contain an element of 'size' and get an element from that pool.
  74:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
  75:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param size the size in bytes of the memory needed
  76:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @return a pointer to the allocated memory or NULL if the pool is empty
  77:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
  78:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void *
  79:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_malloc(mem_size_t size)
  80:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
  81:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   void *ret;
  82:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct memp_malloc_helper *element;
  83:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   memp_t poolnr;
  84:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t required_size = size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper));
  85:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
  86:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   for (poolnr = MEMP_POOL_FIRST; poolnr <= MEMP_POOL_LAST; poolnr = (memp_t)(poolnr + 1)) {
  87:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if MEM_USE_POOLS_TRY_BIGGER_POOL
  88:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** again:
  89:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* MEM_USE_POOLS_TRY_BIGGER_POOL */
  90:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* is this pool big enough to hold an element of the required size
  91:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****        plus a struct memp_malloc_helper that saves the pool this element came from? */
  92:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (required_size <= memp_sizes[poolnr]) {
  93:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       break;
  94:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
  95:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
  96:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (poolnr > MEMP_POOL_LAST) {
  97:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     LWIP_ASSERT("mem_malloc(): no pool is that big!", 0);
  98:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
  99:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 100:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   element = (struct memp_malloc_helper*)memp_malloc(poolnr);
 101:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (element == NULL) {
 102:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* No need to DEBUGF or ASSERT: This error is already
 103:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****        taken care of in memp.c */
 104:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if MEM_USE_POOLS_TRY_BIGGER_POOL
 105:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /** Try a bigger pool if this one is empty! */
 106:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (poolnr < MEMP_POOL_LAST) {
 107:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       poolnr++;
 108:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       goto again;
 109:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 110:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* MEM_USE_POOLS_TRY_BIGGER_POOL */
 111:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
 112:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 113:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 114:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* save the pool number this element came from */
 115:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   element->poolnr = poolnr;
 116:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* and return a pointer to the memory directly after the struct memp_malloc_helper */
 117:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ret = (u8_t*)element + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper));
 118:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 119:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   return ret;
 120:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 121:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 122:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 123:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Free memory previously allocated by mem_malloc. Loads the pool number
 124:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * and calls memp_free with that pool number to put the element back into
 125:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * its pool
 126:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 127:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param rmem the memory element to free
 128:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 129:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void
 130:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_free(void *rmem)
 131:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 132:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct memp_malloc_helper *hmem;
 133:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 134:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("rmem != NULL", (rmem != NULL));
 135:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("rmem == MEM_ALIGN(rmem)", (rmem == LWIP_MEM_ALIGN(rmem)));
 136:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 137:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* get the original struct memp_malloc_helper */
 138:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   hmem = (struct memp_malloc_helper*)(void*)((u8_t*)rmem - LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_m
 139:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 140:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("hmem != NULL", (hmem != NULL));
 141:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("hmem == MEM_ALIGN(hmem)", (hmem == LWIP_MEM_ALIGN(hmem)));
 142:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("hmem->poolnr < MEMP_MAX", (hmem->poolnr < MEMP_MAX));
 143:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 144:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* and put it in the pool we saved earlier */
 145:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   memp_free(hmem->poolnr, hmem);
 146:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 147:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 148:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #else /* MEM_USE_POOLS */
 149:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* lwIP replacement for your libc malloc() */
 150:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 151:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 152:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * The heap is made up as a list of structs of this type.
 153:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * This does not have to be aligned since for getting its size,
 154:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * we only use the macro SIZEOF_STRUCT_MEM, which automatically alignes.
 155:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 156:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** struct mem {
 157:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /** index (-> ram[next]) of the next struct */
 158:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t next;
 159:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /** index (-> ram[prev]) of the previous struct */
 160:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t prev;
 161:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /** 1: this area is used; 0: this area is unused */
 162:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   u8_t used;
 163:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** };
 164:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 165:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** All allocated blocks will be MIN_SIZE bytes big, at least!
 166:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * MIN_SIZE can be overridden to suit your needs. Smaller values save space,
 167:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * larger values could prevent too small blocks to fragment the RAM too much. */
 168:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #ifndef MIN_SIZE
 169:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define MIN_SIZE             12
 170:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* MIN_SIZE */
 171:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* some alignment macros: we define them here for better source code layout */
 172:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define MIN_SIZE_ALIGNED     LWIP_MEM_ALIGN_SIZE(MIN_SIZE)
 173:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define SIZEOF_STRUCT_MEM    LWIP_MEM_ALIGN_SIZE(sizeof(struct mem))
 174:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define MEM_SIZE_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEM_SIZE)
 175:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 176:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** If you want to relocate the heap to external memory, simply define
 177:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * LWIP_RAM_HEAP_POINTER as a void-pointer to that location.
 178:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * If so, make sure the memory at that location is big enough (see below on
 179:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * how that space is calculated). */
 180:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #ifndef LWIP_RAM_HEAP_POINTER
 181:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** the heap. we need one struct mem at the end and some room for alignment */
 182:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** u8_t ram_heap[MEM_SIZE_ALIGNED + (2*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT];
 183:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_RAM_HEAP_POINTER ram_heap
 184:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_RAM_HEAP_POINTER */
 185:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 186:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** pointer to the heap (ram_heap): for alignment, ram is now a pointer instead of an array */
 187:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static u8_t *ram;
 188:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** the last entry, always unused! */
 189:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static struct mem *ram_end;
 190:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** pointer to the lowest free block, this is used for faster search */
 191:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static struct mem *lfree;
 192:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 193:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /** concurrent access protection */
 194:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if !NO_SYS
 195:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static sys_mutex_t mem_mutex;
 196:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif
 197:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 198:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 199:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 200:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static volatile u8_t mem_free_count;
 201:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 202:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* Allow mem_free from other (e.g. interrupt) context */
 203:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_DECL_PROTECT()  SYS_ARCH_DECL_PROTECT(lev_free)
 204:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_PROTECT()       SYS_ARCH_PROTECT(lev_free)
 205:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_UNPROTECT()     SYS_ARCH_UNPROTECT(lev_free)
 206:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_DECL_PROTECT() SYS_ARCH_DECL_PROTECT(lev_alloc)
 207:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_PROTECT()      SYS_ARCH_PROTECT(lev_alloc)
 208:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_UNPROTECT()    SYS_ARCH_UNPROTECT(lev_alloc)
 209:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 210:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #else /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 211:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 212:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* Protect the heap only by using a semaphore */
 213:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_DECL_PROTECT()
 214:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_PROTECT()    sys_mutex_lock(&mem_mutex)
 215:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_FREE_UNPROTECT()  sys_mutex_unlock(&mem_mutex)
 216:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /* mem_malloc is protected using semaphore AND LWIP_MEM_ALLOC_PROTECT */
 217:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_DECL_PROTECT()
 218:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_PROTECT()
 219:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #define LWIP_MEM_ALLOC_UNPROTECT()
 220:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 221:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 222:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 223:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 224:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 225:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * "Plug holes" by combining adjacent empty struct mems.
 226:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * After this function is through, there should not exist
 227:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * one empty struct mem pointing to another empty struct mem.
 228:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 229:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param mem this points to a struct mem which just has been freed
 230:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @internal this function is only called by mem_free() and mem_trim()
 231:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 232:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * This assumes access to the heap is protected by the calling function
 233:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * already.
 234:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 235:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** static void
 236:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** plug_holes(struct mem *mem)
 237:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
  46              	 .loc 1 237 0
  47              	 .cfi_startproc
  48              	 
  49              	 
  50              	 
  51 0000 80B4     	 push {r7}
  52              	.LCFI0:
  53              	 .cfi_def_cfa_offset 4
  54              	 .cfi_offset 7,-4
  55 0002 85B0     	 sub sp,sp,#20
  56              	.LCFI1:
  57              	 .cfi_def_cfa_offset 24
  58 0004 00AF     	 add r7,sp,#0
  59              	.LCFI2:
  60              	 .cfi_def_cfa_register 7
  61 0006 7860     	 str r0,[r7,#4]
 238:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *nmem;
 239:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *pmem;
 240:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 241:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 242:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 243:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 244:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 245:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* plug hole forward */
 246:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 247:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 248:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   nmem = (struct mem *)(void *)&ram[mem->next];
  62              	 .loc 1 248 0
  63 0008 294B     	 ldr r3,.L6
  64 000a 1B68     	 ldr r3,[r3]
  65 000c 7A68     	 ldr r2,[r7,#4]
  66 000e 1288     	 ldrh r2,[r2]
  67 0010 1344     	 add r3,r3,r2
  68 0012 FB60     	 str r3,[r7,#12]
 249:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  69              	 .loc 1 249 0
  70 0014 7A68     	 ldr r2,[r7,#4]
  71 0016 FB68     	 ldr r3,[r7,#12]
  72 0018 9A42     	 cmp r2,r3
  73 001a 1FD0     	 beq .L2
  74              	 .loc 1 249 0 is_stmt 0 discriminator 1
  75 001c FB68     	 ldr r3,[r7,#12]
  76 001e 1B79     	 ldrb r3,[r3,#4]
  77 0020 002B     	 cmp r3,#0
  78 0022 1BD1     	 bne .L2
  79              	 .loc 1 249 0 discriminator 2
  80 0024 234B     	 ldr r3,.L6+4
  81 0026 1B68     	 ldr r3,[r3]
  82 0028 FA68     	 ldr r2,[r7,#12]
  83 002a 9A42     	 cmp r2,r3
  84 002c 16D0     	 beq .L2
 250:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* if mem->next is unused and not end of ram, combine mem and mem->next */
 251:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (lfree == nmem) {
  85              	 .loc 1 251 0 is_stmt 1
  86 002e 224B     	 ldr r3,.L6+8
  87 0030 1A68     	 ldr r2,[r3]
  88 0032 FB68     	 ldr r3,[r7,#12]
  89 0034 9A42     	 cmp r2,r3
  90 0036 02D1     	 bne .L3
 252:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       lfree = mem;
  91              	 .loc 1 252 0
  92 0038 1F4A     	 ldr r2,.L6+8
  93 003a 7B68     	 ldr r3,[r7,#4]
  94 003c 1360     	 str r3,[r2]
  95              	.L3:
 253:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 254:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem->next = nmem->next;
  96              	 .loc 1 254 0
  97 003e FB68     	 ldr r3,[r7,#12]
  98 0040 1A88     	 ldrh r2,[r3]
  99 0042 7B68     	 ldr r3,[r7,#4]
 100 0044 1A80     	 strh r2,[r3]
 255:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 101              	 .loc 1 255 0
 102 0046 1A4B     	 ldr r3,.L6
 103 0048 1B68     	 ldr r3,[r3]
 104 004a FA68     	 ldr r2,[r7,#12]
 105 004c 1288     	 ldrh r2,[r2]
 106 004e 1344     	 add r3,r3,r2
 107 0050 7A68     	 ldr r2,[r7,#4]
 108 0052 1749     	 ldr r1,.L6
 109 0054 0968     	 ldr r1,[r1]
 110 0056 521A     	 subs r2,r2,r1
 111 0058 92B2     	 uxth r2,r2
 112 005a 5A80     	 strh r2,[r3,#2]
 113              	.L2:
 256:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 257:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 258:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* plug hole backward */
 259:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   pmem = (struct mem *)(void *)&ram[mem->prev];
 114              	 .loc 1 259 0
 115 005c 144B     	 ldr r3,.L6
 116 005e 1B68     	 ldr r3,[r3]
 117 0060 7A68     	 ldr r2,[r7,#4]
 118 0062 5288     	 ldrh r2,[r2,#2]
 119 0064 1344     	 add r3,r3,r2
 120 0066 BB60     	 str r3,[r7,#8]
 260:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (pmem != mem && pmem->used == 0) {
 121              	 .loc 1 260 0
 122 0068 BA68     	 ldr r2,[r7,#8]
 123 006a 7B68     	 ldr r3,[r7,#4]
 124 006c 9A42     	 cmp r2,r3
 125 006e 1AD0     	 beq .L1
 126              	 .loc 1 260 0 is_stmt 0 discriminator 1
 127 0070 BB68     	 ldr r3,[r7,#8]
 128 0072 1B79     	 ldrb r3,[r3,#4]
 129 0074 002B     	 cmp r3,#0
 130 0076 16D1     	 bne .L1
 261:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* if mem->prev is unused, combine mem and mem->prev */
 262:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (lfree == mem) {
 131              	 .loc 1 262 0 is_stmt 1
 132 0078 0F4B     	 ldr r3,.L6+8
 133 007a 1A68     	 ldr r2,[r3]
 134 007c 7B68     	 ldr r3,[r7,#4]
 135 007e 9A42     	 cmp r2,r3
 136 0080 02D1     	 bne .L5
 263:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       lfree = pmem;
 137              	 .loc 1 263 0
 138 0082 0D4A     	 ldr r2,.L6+8
 139 0084 BB68     	 ldr r3,[r7,#8]
 140 0086 1360     	 str r3,[r2]
 141              	.L5:
 264:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 265:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     pmem->next = mem->next;
 142              	 .loc 1 265 0
 143 0088 7B68     	 ldr r3,[r7,#4]
 144 008a 1A88     	 ldrh r2,[r3]
 145 008c BB68     	 ldr r3,[r7,#8]
 146 008e 1A80     	 strh r2,[r3]
 266:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 147              	 .loc 1 266 0
 148 0090 074B     	 ldr r3,.L6
 149 0092 1B68     	 ldr r3,[r3]
 150 0094 7A68     	 ldr r2,[r7,#4]
 151 0096 1288     	 ldrh r2,[r2]
 152 0098 1344     	 add r3,r3,r2
 153 009a BA68     	 ldr r2,[r7,#8]
 154 009c 0449     	 ldr r1,.L6
 155 009e 0968     	 ldr r1,[r1]
 156 00a0 521A     	 subs r2,r2,r1
 157 00a2 92B2     	 uxth r2,r2
 158 00a4 5A80     	 strh r2,[r3,#2]
 159              	.L1:
 267:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 268:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 160              	 .loc 1 268 0
 161 00a6 1437     	 adds r7,r7,#20
 162              	.LCFI3:
 163              	 .cfi_def_cfa_offset 4
 164 00a8 BD46     	 mov sp,r7
 165              	.LCFI4:
 166              	 .cfi_def_cfa_register 13
 167              	 
 168 00aa 5DF8047B 	 ldr r7,[sp],#4
 169              	.LCFI5:
 170              	 .cfi_restore 7
 171              	 .cfi_def_cfa_offset 0
 172 00ae 7047     	 bx lr
 173              	.L7:
 174              	 .align 2
 175              	.L6:
 176 00b0 00000000 	 .word ram
 177 00b4 00000000 	 .word ram_end
 178 00b8 00000000 	 .word lfree
 179              	 .cfi_endproc
 180              	.LFE128:
 182              	 .section .text.mem_init,"ax",%progbits
 183              	 .align 2
 184              	 .global mem_init
 185              	 .thumb
 186              	 .thumb_func
 188              	mem_init:
 189              	.LFB129:
 269:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 270:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 271:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Zero the heap and initialize start, end and lowest-free
 272:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 273:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void
 274:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_init(void)
 275:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 190              	 .loc 1 275 0
 191              	 .cfi_startproc
 192              	 
 193              	 
 194              	 
 195 0000 80B4     	 push {r7}
 196              	.LCFI6:
 197              	 .cfi_def_cfa_offset 4
 198              	 .cfi_offset 7,-4
 199 0002 83B0     	 sub sp,sp,#12
 200              	.LCFI7:
 201              	 .cfi_def_cfa_offset 16
 202 0004 00AF     	 add r7,sp,#0
 203              	.LCFI8:
 204              	 .cfi_def_cfa_register 7
 276:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *mem;
 277:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 278:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("Sanity check alignment",
 279:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
 280:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 281:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* align the heap */
 282:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 205              	 .loc 1 282 0
 206 0006 184B     	 ldr r3,.L9
 207 0008 0333     	 adds r3,r3,#3
 208 000a 23F00303 	 bic r3,r3,#3
 209 000e 1A46     	 mov r2,r3
 210 0010 164B     	 ldr r3,.L9+4
 211 0012 1A60     	 str r2,[r3]
 283:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* initialize the start of the heap */
 284:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem = (struct mem *)(void *)ram;
 212              	 .loc 1 284 0
 213 0014 154B     	 ldr r3,.L9+4
 214 0016 1B68     	 ldr r3,[r3]
 215 0018 7B60     	 str r3,[r7,#4]
 285:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem->next = MEM_SIZE_ALIGNED;
 216              	 .loc 1 285 0
 217 001a 7B68     	 ldr r3,[r7,#4]
 218 001c 4FF4C862 	 mov r2,#1600
 219 0020 1A80     	 strh r2,[r3]
 286:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem->prev = 0;
 220              	 .loc 1 286 0
 221 0022 7B68     	 ldr r3,[r7,#4]
 222 0024 0022     	 movs r2,#0
 223 0026 5A80     	 strh r2,[r3,#2]
 287:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem->used = 0;
 224              	 .loc 1 287 0
 225 0028 7B68     	 ldr r3,[r7,#4]
 226 002a 0022     	 movs r2,#0
 227 002c 1A71     	 strb r2,[r3,#4]
 288:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* initialize the end of the heap */
 289:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 228              	 .loc 1 289 0
 229 002e 0F4B     	 ldr r3,.L9+4
 230 0030 1B68     	 ldr r3,[r3]
 231 0032 03F5C863 	 add r3,r3,#1600
 232 0036 0E4A     	 ldr r2,.L9+8
 233 0038 1360     	 str r3,[r2]
 290:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ram_end->used = 1;
 234              	 .loc 1 290 0
 235 003a 0D4B     	 ldr r3,.L9+8
 236 003c 1B68     	 ldr r3,[r3]
 237 003e 0122     	 movs r2,#1
 238 0040 1A71     	 strb r2,[r3,#4]
 291:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ram_end->next = MEM_SIZE_ALIGNED;
 239              	 .loc 1 291 0
 240 0042 0B4B     	 ldr r3,.L9+8
 241 0044 1B68     	 ldr r3,[r3]
 242 0046 4FF4C862 	 mov r2,#1600
 243 004a 1A80     	 strh r2,[r3]
 292:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ram_end->prev = MEM_SIZE_ALIGNED;
 244              	 .loc 1 292 0
 245 004c 084B     	 ldr r3,.L9+8
 246 004e 1B68     	 ldr r3,[r3]
 247 0050 4FF4C862 	 mov r2,#1600
 248 0054 5A80     	 strh r2,[r3,#2]
 293:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 294:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* initialize the lowest-free pointer to the start of the heap */
 295:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   lfree = (struct mem *)(void *)ram;
 249              	 .loc 1 295 0
 250 0056 054B     	 ldr r3,.L9+4
 251 0058 1B68     	 ldr r3,[r3]
 252 005a 064A     	 ldr r2,.L9+12
 253 005c 1360     	 str r3,[r2]
 296:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 297:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 298:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 299:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 300:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     LWIP_ASSERT("failed to create mem_mutex", 0);
 301:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 302:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 254              	 .loc 1 302 0
 255 005e 0C37     	 adds r7,r7,#12
 256              	.LCFI9:
 257              	 .cfi_def_cfa_offset 4
 258 0060 BD46     	 mov sp,r7
 259              	.LCFI10:
 260              	 .cfi_def_cfa_register 13
 261              	 
 262 0062 5DF8047B 	 ldr r7,[sp],#4
 263              	.LCFI11:
 264              	 .cfi_restore 7
 265              	 .cfi_def_cfa_offset 0
 266 0066 7047     	 bx lr
 267              	.L10:
 268              	 .align 2
 269              	.L9:
 270 0068 00000000 	 .word ram_heap
 271 006c 00000000 	 .word ram
 272 0070 00000000 	 .word ram_end
 273 0074 00000000 	 .word lfree
 274              	 .cfi_endproc
 275              	.LFE129:
 277              	 .section .text.mem_free,"ax",%progbits
 278              	 .align 2
 279              	 .global mem_free
 280              	 .thumb
 281              	 .thumb_func
 283              	mem_free:
 284              	.LFB130:
 303:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 304:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 305:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Put a struct mem back on the heap
 306:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 307:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param rmem is the data portion of a struct mem as returned by a previous
 308:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *             call to mem_malloc()
 309:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 310:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void
 311:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_free(void *rmem)
 312:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 285              	 .loc 1 312 0
 286              	 .cfi_startproc
 287              	 
 288              	 
 289 0000 80B5     	 push {r7,lr}
 290              	.LCFI12:
 291              	 .cfi_def_cfa_offset 8
 292              	 .cfi_offset 7,-8
 293              	 .cfi_offset 14,-4
 294 0002 84B0     	 sub sp,sp,#16
 295              	.LCFI13:
 296              	 .cfi_def_cfa_offset 24
 297 0004 00AF     	 add r7,sp,#0
 298              	.LCFI14:
 299              	 .cfi_def_cfa_register 7
 300 0006 7860     	 str r0,[r7,#4]
 313:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *mem;
 314:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_DECL_PROTECT();
 315:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 316:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (rmem == NULL) {
 301              	 .loc 1 316 0
 302 0008 7B68     	 ldr r3,[r7,#4]
 303 000a 002B     	 cmp r3,#0
 304 000c 00D1     	 bne .L12
 317:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was call
 318:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return;
 305              	 .loc 1 318 0
 306 000e 1BE0     	 b .L11
 307              	.L12:
 319:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 320:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 321:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 322:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 323:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     (u8_t *)rmem < (u8_t *)ram_end);
 324:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 325:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 308              	 .loc 1 325 0
 309 0010 0F4B     	 ldr r3,.L17
 310 0012 1B68     	 ldr r3,[r3]
 311 0014 7A68     	 ldr r2,[r7,#4]
 312 0016 9A42     	 cmp r2,r3
 313 0018 04D3     	 bcc .L14
 314              	 .loc 1 325 0 is_stmt 0 discriminator 1
 315 001a 0E4B     	 ldr r3,.L17+4
 316 001c 1B68     	 ldr r3,[r3]
 317 001e 7A68     	 ldr r2,[r7,#4]
 318 0020 9A42     	 cmp r2,r3
 319 0022 00D3     	 bcc .L15
 320              	.L14:
 326:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_DECL_PROTECT(lev);
 327:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
 328:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* protect mem stats from concurrent access */
 329:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_PROTECT(lev);
 330:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     MEM_STATS_INC(illegal);
 331:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_UNPROTECT(lev);
 332:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return;
 321              	 .loc 1 332 0 is_stmt 1 discriminator 2
 322 0024 10E0     	 b .L11
 323              	.L15:
 333:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 334:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 335:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_PROTECT();
 336:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* Get the corresponding struct mem ... */
 337:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 324              	 .loc 1 337 0
 325 0026 7B68     	 ldr r3,[r7,#4]
 326 0028 083B     	 subs r3,r3,#8
 327 002a FB60     	 str r3,[r7,#12]
 338:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* ... which has to be in a used state ... */
 339:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("mem_free: mem->used", mem->used);
 340:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* ... and is now unused. */
 341:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem->used = 0;
 328              	 .loc 1 341 0
 329 002c FB68     	 ldr r3,[r7,#12]
 330 002e 0022     	 movs r2,#0
 331 0030 1A71     	 strb r2,[r3,#4]
 342:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 343:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (mem < lfree) {
 332              	 .loc 1 343 0
 333 0032 094B     	 ldr r3,.L17+8
 334 0034 1B68     	 ldr r3,[r3]
 335 0036 FA68     	 ldr r2,[r7,#12]
 336 0038 9A42     	 cmp r2,r3
 337 003a 02D2     	 bcs .L16
 344:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* the newly freed struct is now the lowest */
 345:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     lfree = mem;
 338              	 .loc 1 345 0
 339 003c 064A     	 ldr r2,.L17+8
 340 003e FB68     	 ldr r3,[r7,#12]
 341 0040 1360     	 str r3,[r2]
 342              	.L16:
 346:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 347:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 348:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 349:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 350:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* finally, see if prev or next are free also */
 351:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   plug_holes(mem);
 343              	 .loc 1 351 0
 344 0042 F868     	 ldr r0,[r7,#12]
 345 0044 FFF7FEFF 	 bl plug_holes
 346              	.L11:
 352:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 353:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_free_count = 1;
 354:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 355:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_UNPROTECT();
 356:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 347              	 .loc 1 356 0
 348 0048 1037     	 adds r7,r7,#16
 349              	.LCFI15:
 350              	 .cfi_def_cfa_offset 8
 351 004a BD46     	 mov sp,r7
 352              	.LCFI16:
 353              	 .cfi_def_cfa_register 13
 354              	 
 355 004c 80BD     	 pop {r7,pc}
 356              	.L18:
 357 004e 00BF     	 .align 2
 358              	.L17:
 359 0050 00000000 	 .word ram
 360 0054 00000000 	 .word ram_end
 361 0058 00000000 	 .word lfree
 362              	 .cfi_endproc
 363              	.LFE130:
 365              	 .section .text.mem_trim,"ax",%progbits
 366              	 .align 2
 367              	 .global mem_trim
 368              	 .thumb
 369              	 .thumb_func
 371              	mem_trim:
 372              	.LFB131:
 357:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 358:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 359:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Shrink memory returned by mem_malloc().
 360:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 361:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param rmem pointer to memory allocated by mem_malloc the is to be shrinked
 362:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param newsize required size after shrinking (needs to be smaller than or
 363:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *                equal to the previous size)
 364:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @return for compatibility reasons: is always == rmem, at the moment
 365:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *         or NULL if newsize is > old size, in which case rmem is NOT touched
 366:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *         or freed!
 367:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 368:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void *
 369:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_trim(void *rmem, mem_size_t newsize)
 370:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 373              	 .loc 1 370 0
 374              	 .cfi_startproc
 375              	 
 376              	 
 377              	 
 378 0000 80B4     	 push {r7}
 379              	.LCFI17:
 380              	 .cfi_def_cfa_offset 4
 381              	 .cfi_offset 7,-4
 382 0002 87B0     	 sub sp,sp,#28
 383              	.LCFI18:
 384              	 .cfi_def_cfa_offset 32
 385 0004 00AF     	 add r7,sp,#0
 386              	.LCFI19:
 387              	 .cfi_def_cfa_register 7
 388 0006 7860     	 str r0,[r7,#4]
 389 0008 0B46     	 mov r3,r1
 390 000a 7B80     	 strh r3,[r7,#2]
 371:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t size;
 372:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t ptr, ptr2;
 373:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *mem, *mem2;
 374:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
 375:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_DECL_PROTECT();
 376:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 377:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* Expand the size of the allocated memory region so that we can
 378:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      adjust for alignment. */
 379:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 391              	 .loc 1 379 0
 392 000c 7B88     	 ldrh r3,[r7,#2]
 393 000e 0333     	 adds r3,r3,#3
 394 0010 9BB2     	 uxth r3,r3
 395 0012 23F00303 	 bic r3,r3,#3
 396 0016 7B80     	 strh r3,[r7,#2]
 380:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 381:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if(newsize < MIN_SIZE_ALIGNED) {
 397              	 .loc 1 381 0
 398 0018 7B88     	 ldrh r3,[r7,#2]
 399 001a 0B2B     	 cmp r3,#11
 400 001c 01D8     	 bhi .L20
 382:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* every data block must be at least MIN_SIZE_ALIGNED long */
 383:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     newsize = MIN_SIZE_ALIGNED;
 401              	 .loc 1 383 0
 402 001e 0C23     	 movs r3,#12
 403 0020 7B80     	 strh r3,[r7,#2]
 404              	.L20:
 384:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 385:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 386:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (newsize > MEM_SIZE_ALIGNED) {
 405              	 .loc 1 386 0
 406 0022 7B88     	 ldrh r3,[r7,#2]
 407 0024 B3F5C86F 	 cmp r3,#1600
 408 0028 01D9     	 bls .L21
 387:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
 409              	 .loc 1 387 0
 410 002a 0023     	 movs r3,#0
 411 002c 96E0     	 b .L22
 412              	.L21:
 388:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 389:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 390:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 391:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****    (u8_t *)rmem < (u8_t *)ram_end);
 392:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 393:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 413              	 .loc 1 393 0
 414 002e 4E4B     	 ldr r3,.L32
 415 0030 1B68     	 ldr r3,[r3]
 416 0032 7A68     	 ldr r2,[r7,#4]
 417 0034 9A42     	 cmp r2,r3
 418 0036 04D3     	 bcc .L23
 419              	 .loc 1 393 0 is_stmt 0 discriminator 1
 420 0038 4C4B     	 ldr r3,.L32+4
 421 003a 1B68     	 ldr r3,[r3]
 422 003c 7A68     	 ldr r2,[r7,#4]
 423 003e 9A42     	 cmp r2,r3
 424 0040 01D3     	 bcc .L24
 425              	.L23:
 394:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_DECL_PROTECT(lev);
 395:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
 396:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* protect mem stats from concurrent access */
 397:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_PROTECT(lev);
 398:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     MEM_STATS_INC(illegal);
 399:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     SYS_ARCH_UNPROTECT(lev);
 400:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return rmem;
 426              	 .loc 1 400 0 is_stmt 1
 427 0042 7B68     	 ldr r3,[r7,#4]
 428 0044 8AE0     	 b .L22
 429              	.L24:
 401:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 402:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* Get the corresponding struct mem ... */
 403:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 430              	 .loc 1 403 0
 431 0046 7B68     	 ldr r3,[r7,#4]
 432 0048 083B     	 subs r3,r3,#8
 433 004a 7B61     	 str r3,[r7,#20]
 404:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* ... and its offset pointer */
 405:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   ptr = (mem_size_t)((u8_t *)mem - ram);
 434              	 .loc 1 405 0
 435 004c 7B69     	 ldr r3,[r7,#20]
 436 004e 464A     	 ldr r2,.L32
 437 0050 1268     	 ldr r2,[r2]
 438 0052 9B1A     	 subs r3,r3,r2
 439 0054 7B82     	 strh r3,[r7,#18]
 406:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 407:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 440              	 .loc 1 407 0
 441 0056 7B69     	 ldr r3,[r7,#20]
 442 0058 1A88     	 ldrh r2,[r3]
 443 005a 7B8A     	 ldrh r3,[r7,#18]
 444 005c D31A     	 subs r3,r2,r3
 445 005e 9BB2     	 uxth r3,r3
 446 0060 083B     	 subs r3,r3,#8
 447 0062 3B82     	 strh r3,[r7,#16]
 408:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 409:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (newsize > size) {
 448              	 .loc 1 409 0
 449 0064 7A88     	 ldrh r2,[r7,#2]
 450 0066 3B8A     	 ldrh r3,[r7,#16]
 451 0068 9A42     	 cmp r2,r3
 452 006a 01D9     	 bls .L25
 410:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* not supported */
 411:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
 453              	 .loc 1 411 0
 454 006c 0023     	 movs r3,#0
 455 006e 75E0     	 b .L22
 456              	.L25:
 412:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 413:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (newsize == size) {
 457              	 .loc 1 413 0
 458 0070 7A88     	 ldrh r2,[r7,#2]
 459 0072 3B8A     	 ldrh r3,[r7,#16]
 460 0074 9A42     	 cmp r2,r3
 461 0076 01D1     	 bne .L26
 414:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* No change in size, simply return */
 415:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return rmem;
 462              	 .loc 1 415 0
 463 0078 7B68     	 ldr r3,[r7,#4]
 464 007a 6FE0     	 b .L22
 465              	.L26:
 416:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 417:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 418:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 419:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_PROTECT();
 420:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 421:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem2 = (struct mem *)(void *)&ram[mem->next];
 466              	 .loc 1 421 0
 467 007c 3A4B     	 ldr r3,.L32
 468 007e 1B68     	 ldr r3,[r3]
 469 0080 7A69     	 ldr r2,[r7,#20]
 470 0082 1288     	 ldrh r2,[r2]
 471 0084 1344     	 add r3,r3,r2
 472 0086 FB60     	 str r3,[r7,#12]
 422:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if(mem2->used == 0) {
 473              	 .loc 1 422 0
 474 0088 FB68     	 ldr r3,[r7,#12]
 475 008a 1B79     	 ldrb r3,[r3,#4]
 476 008c 002B     	 cmp r3,#0
 477 008e 32D1     	 bne .L27
 478              	.LBB2:
 423:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* The next struct is unused, we can simply move it at little */
 424:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem_size_t next;
 425:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* remember the old next pointer */
 426:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     next = mem2->next;
 479              	 .loc 1 426 0
 480 0090 FB68     	 ldr r3,[r7,#12]
 481 0092 1B88     	 ldrh r3,[r3]
 482 0094 7B81     	 strh r3,[r7,#10]
 427:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* create new struct mem which is moved directly after the shrinked mem */
 428:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 483              	 .loc 1 428 0
 484 0096 7A8A     	 ldrh r2,[r7,#18]
 485 0098 7B88     	 ldrh r3,[r7,#2]
 486 009a 1344     	 add r3,r3,r2
 487 009c 9BB2     	 uxth r3,r3
 488 009e 0833     	 adds r3,r3,#8
 489 00a0 3B81     	 strh r3,[r7,#8]
 429:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (lfree == mem2) {
 490              	 .loc 1 429 0
 491 00a2 334B     	 ldr r3,.L32+8
 492 00a4 1A68     	 ldr r2,[r3]
 493 00a6 FB68     	 ldr r3,[r7,#12]
 494 00a8 9A42     	 cmp r2,r3
 495 00aa 05D1     	 bne .L28
 430:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       lfree = (struct mem *)(void *)&ram[ptr2];
 496              	 .loc 1 430 0
 497 00ac 2E4B     	 ldr r3,.L32
 498 00ae 1A68     	 ldr r2,[r3]
 499 00b0 3B89     	 ldrh r3,[r7,#8]
 500 00b2 1344     	 add r3,r3,r2
 501 00b4 2E4A     	 ldr r2,.L32+8
 502 00b6 1360     	 str r3,[r2]
 503              	.L28:
 431:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 432:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2 = (struct mem *)(void *)&ram[ptr2];
 504              	 .loc 1 432 0
 505 00b8 2B4B     	 ldr r3,.L32
 506 00ba 1A68     	 ldr r2,[r3]
 507 00bc 3B89     	 ldrh r3,[r7,#8]
 508 00be 1344     	 add r3,r3,r2
 509 00c0 FB60     	 str r3,[r7,#12]
 433:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->used = 0;
 510              	 .loc 1 433 0
 511 00c2 FB68     	 ldr r3,[r7,#12]
 512 00c4 0022     	 movs r2,#0
 513 00c6 1A71     	 strb r2,[r3,#4]
 434:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* restore the next pointer */
 435:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->next = next;
 514              	 .loc 1 435 0
 515 00c8 FB68     	 ldr r3,[r7,#12]
 516 00ca 7A89     	 ldrh r2,[r7,#10]
 517 00cc 1A80     	 strh r2,[r3]
 436:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* link it back to mem */
 437:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->prev = ptr;
 518              	 .loc 1 437 0
 519 00ce FB68     	 ldr r3,[r7,#12]
 520 00d0 7A8A     	 ldrh r2,[r7,#18]
 521 00d2 5A80     	 strh r2,[r3,#2]
 438:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* link mem to it */
 439:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem->next = ptr2;
 522              	 .loc 1 439 0
 523 00d4 7B69     	 ldr r3,[r7,#20]
 524 00d6 3A89     	 ldrh r2,[r7,#8]
 525 00d8 1A80     	 strh r2,[r3]
 440:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* last thing to restore linked list: as we have moved mem2,
 441:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
 442:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * the end of the heap */
 443:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (mem2->next != MEM_SIZE_ALIGNED) {
 526              	 .loc 1 443 0
 527 00da FB68     	 ldr r3,[r7,#12]
 528 00dc 1B88     	 ldrh r3,[r3]
 529 00de B3F5C86F 	 cmp r3,#1600
 530 00e2 07D0     	 beq .L29
 444:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 531              	 .loc 1 444 0
 532 00e4 204B     	 ldr r3,.L32
 533 00e6 1B68     	 ldr r3,[r3]
 534 00e8 FA68     	 ldr r2,[r7,#12]
 535 00ea 1288     	 ldrh r2,[r2]
 536 00ec 1344     	 add r3,r3,r2
 537 00ee 3A89     	 ldrh r2,[r7,#8]
 538 00f0 5A80     	 strh r2,[r3,#2]
 539              	.LBE2:
 540 00f2 32E0     	 b .L30
 541              	.L29:
 542 00f4 31E0     	 b .L30
 543              	.L27:
 445:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 446:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     MEM_STATS_DEC_USED(used, (size - newsize));
 447:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* no need to plug holes, we've already done that */
 448:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 544              	 .loc 1 448 0
 545 00f6 7B88     	 ldrh r3,[r7,#2]
 546 00f8 03F11402 	 add r2,r3,#20
 547 00fc 3B8A     	 ldrh r3,[r7,#16]
 548 00fe 9A42     	 cmp r2,r3
 549 0100 2BD8     	 bhi .L30
 449:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* Next struct is used but there's room for another struct mem with
 450:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * at least MIN_SIZE_ALIGNED of data.
 451:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
 452:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
 453:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
 454:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      *       region that couldn't hold data, but when mem->next gets freed,
 455:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      *       the 2 regions would be combined, resulting in more free memory */
 456:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 550              	 .loc 1 456 0
 551 0102 7A8A     	 ldrh r2,[r7,#18]
 552 0104 7B88     	 ldrh r3,[r7,#2]
 553 0106 1344     	 add r3,r3,r2
 554 0108 9BB2     	 uxth r3,r3
 555 010a 0833     	 adds r3,r3,#8
 556 010c 3B81     	 strh r3,[r7,#8]
 457:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2 = (struct mem *)(void *)&ram[ptr2];
 557              	 .loc 1 457 0
 558 010e 164B     	 ldr r3,.L32
 559 0110 1A68     	 ldr r2,[r3]
 560 0112 3B89     	 ldrh r3,[r7,#8]
 561 0114 1344     	 add r3,r3,r2
 562 0116 FB60     	 str r3,[r7,#12]
 458:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (mem2 < lfree) {
 563              	 .loc 1 458 0
 564 0118 154B     	 ldr r3,.L32+8
 565 011a 1B68     	 ldr r3,[r3]
 566 011c FA68     	 ldr r2,[r7,#12]
 567 011e 9A42     	 cmp r2,r3
 568 0120 02D2     	 bcs .L31
 459:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       lfree = mem2;
 569              	 .loc 1 459 0
 570 0122 134A     	 ldr r2,.L32+8
 571 0124 FB68     	 ldr r3,[r7,#12]
 572 0126 1360     	 str r3,[r2]
 573              	.L31:
 460:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 461:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->used = 0;
 574              	 .loc 1 461 0
 575 0128 FB68     	 ldr r3,[r7,#12]
 576 012a 0022     	 movs r2,#0
 577 012c 1A71     	 strb r2,[r3,#4]
 462:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->next = mem->next;
 578              	 .loc 1 462 0
 579 012e 7B69     	 ldr r3,[r7,#20]
 580 0130 1A88     	 ldrh r2,[r3]
 581 0132 FB68     	 ldr r3,[r7,#12]
 582 0134 1A80     	 strh r2,[r3]
 463:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem2->prev = ptr;
 583              	 .loc 1 463 0
 584 0136 FB68     	 ldr r3,[r7,#12]
 585 0138 7A8A     	 ldrh r2,[r7,#18]
 586 013a 5A80     	 strh r2,[r3,#2]
 464:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     mem->next = ptr2;
 587              	 .loc 1 464 0
 588 013c 7B69     	 ldr r3,[r7,#20]
 589 013e 3A89     	 ldrh r2,[r7,#8]
 590 0140 1A80     	 strh r2,[r3]
 465:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     if (mem2->next != MEM_SIZE_ALIGNED) {
 591              	 .loc 1 465 0
 592 0142 FB68     	 ldr r3,[r7,#12]
 593 0144 1B88     	 ldrh r3,[r3]
 594 0146 B3F5C86F 	 cmp r3,#1600
 595 014a 06D0     	 beq .L30
 466:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 596              	 .loc 1 466 0
 597 014c 064B     	 ldr r3,.L32
 598 014e 1B68     	 ldr r3,[r3]
 599 0150 FA68     	 ldr r2,[r7,#12]
 600 0152 1288     	 ldrh r2,[r2]
 601 0154 1344     	 add r3,r3,r2
 602 0156 3A89     	 ldrh r2,[r7,#8]
 603 0158 5A80     	 strh r2,[r3,#2]
 604              	.L30:
 467:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 468:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     MEM_STATS_DEC_USED(used, (size - newsize));
 469:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* the original mem->next is used, so no need to plug holes! */
 470:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 471:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* else {
 472:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     next struct mem is used but size between mem and mem2 is not big enough
 473:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     to create another struct mem
 474:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     -> don't do anyhting. 
 475:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     -> the remaining space stays unused since it is too small
 476:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   } */
 477:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 478:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_free_count = 1;
 479:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 480:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_FREE_UNPROTECT();
 481:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   return rmem;
 605              	 .loc 1 481 0
 606 015a 7B68     	 ldr r3,[r7,#4]
 607              	.L22:
 482:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 608              	 .loc 1 482 0
 609 015c 1846     	 mov r0,r3
 610 015e 1C37     	 adds r7,r7,#28
 611              	.LCFI20:
 612              	 .cfi_def_cfa_offset 4
 613 0160 BD46     	 mov sp,r7
 614              	.LCFI21:
 615              	 .cfi_def_cfa_register 13
 616              	 
 617 0162 5DF8047B 	 ldr r7,[sp],#4
 618              	.LCFI22:
 619              	 .cfi_restore 7
 620              	 .cfi_def_cfa_offset 0
 621 0166 7047     	 bx lr
 622              	.L33:
 623              	 .align 2
 624              	.L32:
 625 0168 00000000 	 .word ram
 626 016c 00000000 	 .word ram_end
 627 0170 00000000 	 .word lfree
 628              	 .cfi_endproc
 629              	.LFE131:
 631              	 .section .text.mem_malloc,"ax",%progbits
 632              	 .align 2
 633              	 .global mem_malloc
 634              	 .thumb
 635              	 .thumb_func
 637              	mem_malloc:
 638              	.LFB132:
 483:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 484:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 485:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Adam's mem_malloc() plus solution for bug #17922
 486:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Allocate a block of memory with a minimum of 'size' bytes.
 487:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 488:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param size is the minimum size of the requested block in bytes.
 489:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @return pointer to allocated memory or NULL if no free memory was found.
 490:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 491:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 492:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 493:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void *
 494:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_malloc(mem_size_t size)
 495:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 639              	 .loc 1 495 0
 640              	 .cfi_startproc
 641              	 
 642              	 
 643              	 
 644 0000 80B4     	 push {r7}
 645              	.LCFI23:
 646              	 .cfi_def_cfa_offset 4
 647              	 .cfi_offset 7,-4
 648 0002 89B0     	 sub sp,sp,#36
 649              	.LCFI24:
 650              	 .cfi_def_cfa_offset 40
 651 0004 00AF     	 add r7,sp,#0
 652              	.LCFI25:
 653              	 .cfi_def_cfa_register 7
 654 0006 0346     	 mov r3,r0
 655 0008 FB80     	 strh r3,[r7,#6]
 496:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   mem_size_t ptr, ptr2;
 497:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   struct mem *mem, *mem2;
 498:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 499:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   u8_t local_mem_free_count = 0;
 500:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 501:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_ALLOC_DECL_PROTECT();
 502:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 503:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (size == 0) {
 656              	 .loc 1 503 0
 657 000a FB88     	 ldrh r3,[r7,#6]
 658 000c 002B     	 cmp r3,#0
 659 000e 01D1     	 bne .L35
 504:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
 660              	 .loc 1 504 0
 661 0010 0023     	 movs r3,#0
 662 0012 8CE0     	 b .L36
 663              	.L35:
 505:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 506:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 507:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* Expand the size of the allocated memory region so that we can
 508:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      adjust for alignment. */
 509:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   size = LWIP_MEM_ALIGN_SIZE(size);
 664              	 .loc 1 509 0
 665 0014 FB88     	 ldrh r3,[r7,#6]
 666 0016 0333     	 adds r3,r3,#3
 667 0018 9BB2     	 uxth r3,r3
 668 001a 23F00303 	 bic r3,r3,#3
 669 001e FB80     	 strh r3,[r7,#6]
 510:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 511:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if(size < MIN_SIZE_ALIGNED) {
 670              	 .loc 1 511 0
 671 0020 FB88     	 ldrh r3,[r7,#6]
 672 0022 0B2B     	 cmp r3,#11
 673 0024 01D8     	 bhi .L37
 512:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* every data block must be at least MIN_SIZE_ALIGNED long */
 513:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     size = MIN_SIZE_ALIGNED;
 674              	 .loc 1 513 0
 675 0026 0C23     	 movs r3,#12
 676 0028 FB80     	 strh r3,[r7,#6]
 677              	.L37:
 514:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 515:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 516:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (size > MEM_SIZE_ALIGNED) {
 678              	 .loc 1 516 0
 679 002a FB88     	 ldrh r3,[r7,#6]
 680 002c B3F5C86F 	 cmp r3,#1600
 681 0030 01D9     	 bls .L38
 517:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     return NULL;
 682              	 .loc 1 517 0
 683 0032 0023     	 movs r3,#0
 684 0034 7BE0     	 b .L36
 685              	.L38:
 518:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 519:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 520:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* protect the heap from concurrent access */
 521:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   sys_mutex_lock(&mem_mutex);
 522:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_ALLOC_PROTECT();
 523:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 524:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* run as long as a mem_free disturbed mem_malloc or mem_trim */
 525:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   do {
 526:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     local_mem_free_count = 0;
 527:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 528:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 529:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* Scan through the heap searching for a free block that is big enough,
 530:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      * beginning with the lowest free block.
 531:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****      */
 532:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 686              	 .loc 1 532 0
 687 0036 414B     	 ldr r3,.L49
 688 0038 1B68     	 ldr r3,[r3]
 689 003a 1A46     	 mov r2,r3
 690 003c 404B     	 ldr r3,.L49+4
 691 003e 1B68     	 ldr r3,[r3]
 692 0040 D31A     	 subs r3,r2,r3
 693 0042 FB83     	 strh r3,[r7,#30]
 694 0044 6CE0     	 b .L39
 695              	.L48:
 533:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****          ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 534:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       mem = (struct mem *)(void *)&ram[ptr];
 696              	 .loc 1 534 0
 697 0046 3E4B     	 ldr r3,.L49+4
 698 0048 1A68     	 ldr r2,[r3]
 699 004a FB8B     	 ldrh r3,[r7,#30]
 700 004c 1344     	 add r3,r3,r2
 701 004e 7B61     	 str r3,[r7,#20]
 535:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 536:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       mem_free_count = 0;
 537:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       LWIP_MEM_ALLOC_UNPROTECT();
 538:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       /* allow mem_free or mem_trim to run */
 539:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       LWIP_MEM_ALLOC_PROTECT();
 540:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       if (mem_free_count != 0) {
 541:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         /* If mem_free or mem_trim have run, we have to restart since they
 542:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            could have altered our current struct mem. */
 543:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         local_mem_free_count = 1;
 544:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         break;
 545:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       }
 546:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 547:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 548:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       if ((!mem->used) &&
 702              	 .loc 1 548 0
 703 0050 7B69     	 ldr r3,[r7,#20]
 704 0052 1B79     	 ldrb r3,[r3,#4]
 705 0054 002B     	 cmp r3,#0
 706 0056 5DD1     	 bne .L40
 549:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 707              	 .loc 1 549 0 discriminator 1
 708 0058 7B69     	 ldr r3,[r7,#20]
 709 005a 1B88     	 ldrh r3,[r3]
 710 005c 1A46     	 mov r2,r3
 711 005e FB8B     	 ldrh r3,[r7,#30]
 712 0060 D31A     	 subs r3,r2,r3
 713 0062 A3F10802 	 sub r2,r3,#8
 714 0066 FB88     	 ldrh r3,[r7,#6]
 548:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 715              	 .loc 1 548 0 discriminator 1
 716 0068 9A42     	 cmp r2,r3
 717 006a 53D3     	 bcc .L40
 550:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         /* mem is not used and at least perfect fit is possible:
 551:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****          * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
 552:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 553:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 718              	 .loc 1 553 0
 719 006c 7B69     	 ldr r3,[r7,#20]
 720 006e 1B88     	 ldrh r3,[r3]
 721 0070 1A46     	 mov r2,r3
 722 0072 FB8B     	 ldrh r3,[r7,#30]
 723 0074 D31A     	 subs r3,r2,r3
 724 0076 A3F10802 	 sub r2,r3,#8
 725 007a FB88     	 ldrh r3,[r7,#6]
 726 007c 1433     	 adds r3,r3,#20
 727 007e 9A42     	 cmp r2,r3
 728 0080 27D3     	 bcc .L41
 554:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containin
 555:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
 556:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * -> split large block, create empty remainder,
 557:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
 558:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
 559:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * struct mem would fit in but no data between mem2 and mem2->next
 560:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
 561:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            *       region that couldn't hold data, but when mem->next gets freed,
 562:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            *       the 2 regions would be combined, resulting in more free memory
 563:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            */
 564:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 729              	 .loc 1 564 0
 730 0082 FA8B     	 ldrh r2,[r7,#30]
 731 0084 FB88     	 ldrh r3,[r7,#6]
 732 0086 1344     	 add r3,r3,r2
 733 0088 9BB2     	 uxth r3,r3
 734 008a 0833     	 adds r3,r3,#8
 735 008c 7B82     	 strh r3,[r7,#18]
 565:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           /* create mem2 struct */
 566:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem2 = (struct mem *)(void *)&ram[ptr2];
 736              	 .loc 1 566 0
 737 008e 2C4B     	 ldr r3,.L49+4
 738 0090 1A68     	 ldr r2,[r3]
 739 0092 7B8A     	 ldrh r3,[r7,#18]
 740 0094 1344     	 add r3,r3,r2
 741 0096 FB60     	 str r3,[r7,#12]
 567:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem2->used = 0;
 742              	 .loc 1 567 0
 743 0098 FB68     	 ldr r3,[r7,#12]
 744 009a 0022     	 movs r2,#0
 745 009c 1A71     	 strb r2,[r3,#4]
 568:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem2->next = mem->next;
 746              	 .loc 1 568 0
 747 009e 7B69     	 ldr r3,[r7,#20]
 748 00a0 1A88     	 ldrh r2,[r3]
 749 00a2 FB68     	 ldr r3,[r7,#12]
 750 00a4 1A80     	 strh r2,[r3]
 569:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem2->prev = ptr;
 751              	 .loc 1 569 0
 752 00a6 FB68     	 ldr r3,[r7,#12]
 753 00a8 FA8B     	 ldrh r2,[r7,#30]
 754 00aa 5A80     	 strh r2,[r3,#2]
 570:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           /* and insert it between mem and mem->next */
 571:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem->next = ptr2;
 755              	 .loc 1 571 0
 756 00ac 7B69     	 ldr r3,[r7,#20]
 757 00ae 7A8A     	 ldrh r2,[r7,#18]
 758 00b0 1A80     	 strh r2,[r3]
 572:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem->used = 1;
 759              	 .loc 1 572 0
 760 00b2 7B69     	 ldr r3,[r7,#20]
 761 00b4 0122     	 movs r2,#1
 762 00b6 1A71     	 strb r2,[r3,#4]
 573:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 574:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           if (mem2->next != MEM_SIZE_ALIGNED) {
 763              	 .loc 1 574 0
 764 00b8 FB68     	 ldr r3,[r7,#12]
 765 00ba 1B88     	 ldrh r3,[r3]
 766 00bc B3F5C86F 	 cmp r3,#1600
 767 00c0 0AD0     	 beq .L43
 575:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 768              	 .loc 1 575 0
 769 00c2 1F4B     	 ldr r3,.L49+4
 770 00c4 1B68     	 ldr r3,[r3]
 771 00c6 FA68     	 ldr r2,[r7,#12]
 772 00c8 1288     	 ldrh r2,[r2]
 773 00ca 1344     	 add r3,r3,r2
 774 00cc 7A8A     	 ldrh r2,[r7,#18]
 775 00ce 5A80     	 strh r2,[r3,#2]
 776 00d0 02E0     	 b .L43
 777              	.L41:
 576:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           }
 577:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 578:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         } else {
 579:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
 580:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * be used at this point: if not we have 2 unused structs in a row, plug_holes should hav
 581:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * take care of this).
 582:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * -> near fit or excact fit: do not split, no mem2 creation
 583:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * also can't move mem->next directly behind mem, since mem->next
 584:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            * will always be used at this point!
 585:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****            */
 586:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           mem->used = 1;
 778              	 .loc 1 586 0
 779 00d2 7B69     	 ldr r3,[r7,#20]
 780 00d4 0122     	 movs r2,#1
 781 00d6 1A71     	 strb r2,[r3,#4]
 782              	.L43:
 587:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 588:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         }
 589:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 590:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** mem_malloc_adjust_lfree:
 591:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 592:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         if (mem == lfree) {
 783              	 .loc 1 592 0
 784 00d8 184B     	 ldr r3,.L49
 785 00da 1B68     	 ldr r3,[r3]
 786 00dc 7A69     	 ldr r2,[r7,#20]
 787 00de 9A42     	 cmp r2,r3
 788 00e0 15D1     	 bne .L44
 789              	.LBB3:
 593:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           struct mem *cur = lfree;
 790              	 .loc 1 593 0
 791 00e2 164B     	 ldr r3,.L49
 792 00e4 1B68     	 ldr r3,[r3]
 793 00e6 BB61     	 str r3,[r7,#24]
 594:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           /* Find next free block after mem and update lowest free pointer */
 595:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           while (cur->used && cur != ram_end) {
 794              	 .loc 1 595 0
 795 00e8 05E0     	 b .L45
 796              	.L47:
 596:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 597:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             mem_free_count = 0;
 598:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             LWIP_MEM_ALLOC_UNPROTECT();
 599:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             /* prevent high interrupt latency... */
 600:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             LWIP_MEM_ALLOC_PROTECT();
 601:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             if (mem_free_count != 0) {
 602:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****               /* If mem_free or mem_trim have run, we have to restart since they
 603:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****                  could have altered our current struct mem or lfree. */
 604:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****               goto mem_malloc_adjust_lfree;
 605:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             }
 606:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 607:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****             cur = (struct mem *)(void *)&ram[cur->next];
 797              	 .loc 1 607 0
 798 00ea 154B     	 ldr r3,.L49+4
 799 00ec 1B68     	 ldr r3,[r3]
 800 00ee BA69     	 ldr r2,[r7,#24]
 801 00f0 1288     	 ldrh r2,[r2]
 802 00f2 1344     	 add r3,r3,r2
 803 00f4 BB61     	 str r3,[r7,#24]
 804              	.L45:
 595:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 805              	 .loc 1 595 0
 806 00f6 BB69     	 ldr r3,[r7,#24]
 807 00f8 1B79     	 ldrb r3,[r3,#4]
 808 00fa 002B     	 cmp r3,#0
 809 00fc 04D0     	 beq .L46
 595:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 810              	 .loc 1 595 0 is_stmt 0 discriminator 1
 811 00fe 114B     	 ldr r3,.L49+8
 812 0100 1B68     	 ldr r3,[r3]
 813 0102 BA69     	 ldr r2,[r7,#24]
 814 0104 9A42     	 cmp r2,r3
 815 0106 F0D1     	 bne .L47
 816              	.L46:
 608:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           }
 609:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           lfree = cur;
 817              	 .loc 1 609 0 is_stmt 1
 818 0108 0C4A     	 ldr r2,.L49
 819 010a BB69     	 ldr r3,[r7,#24]
 820 010c 1360     	 str r3,[r2]
 821              	.L44:
 822              	.LBE3:
 610:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 611:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         }
 612:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         LWIP_MEM_ALLOC_UNPROTECT();
 613:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         sys_mutex_unlock(&mem_mutex);
 614:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 615:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****          (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
 616:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 617:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****          ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
 618:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         LWIP_ASSERT("mem_malloc: sanity check alignment",
 619:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****           (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
 620:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 621:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****         return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 823              	 .loc 1 621 0
 824 010e 7B69     	 ldr r3,[r7,#20]
 825 0110 0833     	 adds r3,r3,#8
 826 0112 0CE0     	 b .L36
 827              	.L40:
 533:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       mem = (struct mem *)(void *)&ram[ptr];
 828              	 .loc 1 533 0
 829 0114 0A4B     	 ldr r3,.L49+4
 830 0116 1A68     	 ldr r2,[r3]
 831 0118 FB8B     	 ldrh r3,[r7,#30]
 832 011a 1344     	 add r3,r3,r2
 833 011c 1B88     	 ldrh r3,[r3]
 834 011e FB83     	 strh r3,[r7,#30]
 835              	.L39:
 532:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****          ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 836              	 .loc 1 532 0 discriminator 1
 837 0120 FA8B     	 ldrh r2,[r7,#30]
 838 0122 FB88     	 ldrh r3,[r7,#6]
 839 0124 C3F5C863 	 rsb r3,r3,#1600
 840 0128 9A42     	 cmp r2,r3
 841 012a 8CDB     	 blt .L48
 622:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****       }
 623:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     }
 624:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
 625:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* if we got interrupted by a mem_free, try again */
 626:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   } while(local_mem_free_count != 0);
 627:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
 628:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n
 629:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   MEM_STATS_INC(err);
 630:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   LWIP_MEM_ALLOC_UNPROTECT();
 631:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   sys_mutex_unlock(&mem_mutex);
 632:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   return NULL;
 842              	 .loc 1 632 0
 843 012c 0023     	 movs r3,#0
 844              	.L36:
 633:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 845              	 .loc 1 633 0
 846 012e 1846     	 mov r0,r3
 847 0130 2437     	 adds r7,r7,#36
 848              	.LCFI26:
 849              	 .cfi_def_cfa_offset 4
 850 0132 BD46     	 mov sp,r7
 851              	.LCFI27:
 852              	 .cfi_def_cfa_register 13
 853              	 
 854 0134 5DF8047B 	 ldr r7,[sp],#4
 855              	.LCFI28:
 856              	 .cfi_restore 7
 857              	 .cfi_def_cfa_offset 0
 858 0138 7047     	 bx lr
 859              	.L50:
 860 013a 00BF     	 .align 2
 861              	.L49:
 862 013c 00000000 	 .word lfree
 863 0140 00000000 	 .word ram
 864 0144 00000000 	 .word ram_end
 865              	 .cfi_endproc
 866              	.LFE132:
 868              	 .section .text.mem_calloc,"ax",%progbits
 869              	 .align 2
 870              	 .global mem_calloc
 871              	 .thumb
 872              	 .thumb_func
 874              	mem_calloc:
 875              	.LFB133:
 634:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 635:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** #endif /* MEM_USE_POOLS */
 636:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** /**
 637:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * Contiguously allocates enough space for count objects that are size bytes
 638:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * of memory each and returns a pointer to the allocated memory.
 639:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 640:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * The allocated memory is filled with bytes of value zero.
 641:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  *
 642:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param count number of objects to allocate
 643:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @param size size of the objects to allocate
 644:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  * @return pointer to allocated memory / NULL pointer if there is an error
 645:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****  */
 646:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** void *mem_calloc(mem_size_t count, mem_size_t size)
 647:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** {
 876              	 .loc 1 647 0
 877              	 .cfi_startproc
 878              	 
 879              	 
 880 0000 80B5     	 push {r7,lr}
 881              	.LCFI29:
 882              	 .cfi_def_cfa_offset 8
 883              	 .cfi_offset 7,-8
 884              	 .cfi_offset 14,-4
 885 0002 84B0     	 sub sp,sp,#16
 886              	.LCFI30:
 887              	 .cfi_def_cfa_offset 24
 888 0004 00AF     	 add r7,sp,#0
 889              	.LCFI31:
 890              	 .cfi_def_cfa_register 7
 891 0006 0346     	 mov r3,r0
 892 0008 0A46     	 mov r2,r1
 893 000a FB80     	 strh r3,[r7,#6]
 894 000c 1346     	 mov r3,r2
 895 000e BB80     	 strh r3,[r7,#4]
 648:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   void *p;
 649:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** 
 650:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   /* allocate 'count' objects of size 'size' */
 651:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   p = mem_malloc(count * size);
 896              	 .loc 1 651 0
 897 0010 FA88     	 ldrh r2,[r7,#6]
 898 0012 BB88     	 ldrh r3,[r7,#4]
 899 0014 12FB03F3 	 smulbb r3,r2,r3
 900 0018 9BB2     	 uxth r3,r3
 901 001a 1846     	 mov r0,r3
 902 001c FFF7FEFF 	 bl mem_malloc
 903 0020 F860     	 str r0,[r7,#12]
 652:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   if (p) {
 904              	 .loc 1 652 0
 905 0022 FB68     	 ldr r3,[r7,#12]
 906 0024 002B     	 cmp r3,#0
 907 0026 08D0     	 beq .L52
 653:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     /* zero the memory */
 654:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****     memset(p, 0, count * size);
 908              	 .loc 1 654 0
 909 0028 FB88     	 ldrh r3,[r7,#6]
 910 002a BA88     	 ldrh r2,[r7,#4]
 911 002c 02FB03F3 	 mul r3,r2,r3
 912 0030 F868     	 ldr r0,[r7,#12]
 913 0032 0021     	 movs r1,#0
 914 0034 1A46     	 mov r2,r3
 915 0036 FFF7FEFF 	 bl memset
 916              	.L52:
 655:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   }
 656:../Dave/Generated/ETH_LWIP/lwip/core/mem.c ****   return p;
 917              	 .loc 1 656 0
 918 003a FB68     	 ldr r3,[r7,#12]
 657:../Dave/Generated/ETH_LWIP/lwip/core/mem.c **** }
 919              	 .loc 1 657 0
 920 003c 1846     	 mov r0,r3
 921 003e 1037     	 adds r7,r7,#16
 922              	.LCFI32:
 923              	 .cfi_def_cfa_offset 8
 924 0040 BD46     	 mov sp,r7
 925              	.LCFI33:
 926              	 .cfi_def_cfa_register 13
 927              	 
 928 0042 80BD     	 pop {r7,pc}
 929              	 .cfi_endproc
 930              	.LFE133:
 932              	 .text
 933              	.Letext0:
 934              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 935              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 936              	 .file 4 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/../../port/include/arch/cc.h"
 937              	 .file 5 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/mem.h"
 938              	 .file 6 "C:/Users/Will/Documents/GitHub/Launch-DAQ/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mem.c
                            *COM*:00000654 ram_heap
    {standard input}:21     .bss.ram:00000000 $d
    {standard input}:24     .bss.ram:00000000 ram
    {standard input}:27     .bss.ram_end:00000000 $d
    {standard input}:30     .bss.ram_end:00000000 ram_end
    {standard input}:33     .bss.lfree:00000000 $d
    {standard input}:36     .bss.lfree:00000000 lfree
    {standard input}:39     .text.plug_holes:00000000 $t
    {standard input}:43     .text.plug_holes:00000000 plug_holes
    {standard input}:176    .text.plug_holes:000000b0 $d
    {standard input}:183    .text.mem_init:00000000 $t
    {standard input}:188    .text.mem_init:00000000 mem_init
    {standard input}:270    .text.mem_init:00000068 $d
    {standard input}:278    .text.mem_free:00000000 $t
    {standard input}:283    .text.mem_free:00000000 mem_free
    {standard input}:359    .text.mem_free:00000050 $d
    {standard input}:366    .text.mem_trim:00000000 $t
    {standard input}:371    .text.mem_trim:00000000 mem_trim
    {standard input}:625    .text.mem_trim:00000168 $d
    {standard input}:632    .text.mem_malloc:00000000 $t
    {standard input}:637    .text.mem_malloc:00000000 mem_malloc
    {standard input}:862    .text.mem_malloc:0000013c $d
    {standard input}:869    .text.mem_calloc:00000000 $t
    {standard input}:874    .text.mem_calloc:00000000 mem_calloc
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memset
