   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "raw.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .bss.raw_pcbs,"aw",%nobits
  20              	 .align 2
  23              	raw_pcbs:
  24 0000 00000000 	 .space 4
  25              	 .section .text.raw_input,"ax",%progbits
  26              	 .align 2
  27              	 .global raw_input
  28              	 .thumb
  29              	 .thumb_func
  31              	raw_input:
  32              	.LFB128:
  33              	 .file 1 "../Dave/Generated/ETH_LWIP/lwip/core/raw.c"
   1:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
   2:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @file
   3:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Implementation of raw protocol PCBs for low-level handling of
   4:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * different types of protocols besides (or overriding) those
   5:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * already available in lwIP.
   6:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
   7:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
   8:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
   9:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /*
  10:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  11:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * All rights reserved.
  12:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  13:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Redistribution and use in source and binary forms, with or without modification,
  14:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * are permitted provided that the following conditions are met:
  15:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  16:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *    this list of conditions and the following disclaimer.
  18:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *    and/or other materials provided with the distribution.
  21:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * 3. The name of the author may not be used to endorse or promote products
  22:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *    derived from this software without specific prior written permission.
  23:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  24:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  25:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  26:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  27:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  28:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  29:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  30:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  31:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  32:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  33:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * OF SUCH DAMAGE.
  34:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  35:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * This file is part of the lwIP TCP/IP stack.
  36:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  37:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Author: Adam Dunkels <adam@sics.se>
  38:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  39:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
  40:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  41:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/opt.h"
  42:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  43:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #if LWIP_RAW /* don't build if not configured for use in lwipopts.h */
  44:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  45:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/def.h"
  46:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/memp.h"
  47:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/ipv4/lwip/ip_addr.h"
  48:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/netif.h"
  49:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/raw.h"
  50:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../include/lwip/stats.h"
  51:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include "../port/include/arch/perf.h"
  52:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  53:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #include <string.h>
  54:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  55:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /** The list of RAW PCBs */
  56:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** static struct raw_pcb *raw_pcbs;
  57:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  58:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
  59:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Determine if in incoming IP packet is covered by a RAW PCB
  60:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * and if so, pass it to a user-provided receive callback function.
  61:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  62:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Given an incoming IP datagram (as a chain of pbufs) this function
  63:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * finds a corresponding RAW PCB and calls the corresponding receive
  64:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * callback function.
  65:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  66:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param p pbuf to be demultiplexed to a RAW PCB.
  67:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param inp network interface on which the datagram was received.
  68:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return - 1 if the packet has been eaten by a RAW PCB receive
  69:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *           callback function. The caller MAY NOT not reference the
  70:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *           packet any longer, and MAY NOT call pbuf_free().
  71:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return - 0 if packet is not eaten (pbuf is still referenced by the
  72:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *           caller).
  73:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
  74:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
  75:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** u8_t
  76:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_input(struct pbuf *p, struct netif *inp)
  77:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
  34              	 .loc 1 77 0
  35              	 .cfi_startproc
  36              	 
  37              	 
  38 0000 90B5     	 push {r4,r7,lr}
  39              	.LCFI0:
  40              	 .cfi_def_cfa_offset 12
  41              	 .cfi_offset 4,-12
  42              	 .cfi_offset 7,-8
  43              	 .cfi_offset 14,-4
  44 0002 89B0     	 sub sp,sp,#36
  45              	.LCFI1:
  46              	 .cfi_def_cfa_offset 48
  47 0004 00AF     	 add r7,sp,#0
  48              	.LCFI2:
  49              	 .cfi_def_cfa_register 7
  50 0006 7860     	 str r0,[r7,#4]
  51 0008 3960     	 str r1,[r7]
  78:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct raw_pcb *pcb, *prev;
  79:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct ip_hdr *iphdr;
  80:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   s16_t proto;
  81:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   u8_t eaten = 0;
  52              	 .loc 1 81 0
  53 000a 0023     	 movs r3,#0
  54 000c FB75     	 strb r3,[r7,#23]
  82:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  83:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   LWIP_UNUSED_ARG(inp);
  84:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  85:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   iphdr = (struct ip_hdr *)p->payload;
  55              	 .loc 1 85 0
  56 000e 7B68     	 ldr r3,[r7,#4]
  57 0010 5B68     	 ldr r3,[r3,#4]
  58 0012 3B61     	 str r3,[r7,#16]
  86:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   proto = IPH_PROTO(iphdr);
  59              	 .loc 1 86 0
  60 0014 3B69     	 ldr r3,[r7,#16]
  61 0016 5B7A     	 ldrb r3,[r3,#9]
  62 0018 FB81     	 strh r3,[r7,#14]
  87:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
  88:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   prev = NULL;
  63              	 .loc 1 88 0
  64 001a 0023     	 movs r3,#0
  65 001c BB61     	 str r3,[r7,#24]
  89:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   pcb = raw_pcbs;
  66              	 .loc 1 89 0
  67 001e 254B     	 ldr r3,.L8
  68 0020 1B68     	 ldr r3,[r3]
  69 0022 FB61     	 str r3,[r7,#28]
  90:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* loop through all raw pcbs until the packet is eaten by one */
  91:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* this allows multiple pcbs to match against the packet by design */
  92:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   while ((eaten == 0) && (pcb != NULL)) {
  70              	 .loc 1 92 0
  71 0024 3AE0     	 b .L2
  72              	.L6:
  93:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if ((pcb->protocol == proto) &&
  73              	 .loc 1 93 0
  74 0026 FB69     	 ldr r3,[r7,#28]
  75 0028 1B7C     	 ldrb r3,[r3,#16]
  76 002a 1A46     	 mov r2,r3
  77 002c B7F90E30 	 ldrsh r3,[r7,#14]
  78 0030 9A42     	 cmp r2,r3
  79 0032 2ED1     	 bne .L3
  94:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         (ip_addr_isany(&pcb->local_ip) ||
  80              	 .loc 1 94 0 discriminator 1
  81 0034 FB69     	 ldr r3,[r7,#28]
  93:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if ((pcb->protocol == proto) &&
  82              	 .loc 1 93 0 discriminator 1
  83 0036 002B     	 cmp r3,#0
  84 0038 09D0     	 beq .L4
  85              	 .loc 1 94 0
  86 003a FB69     	 ldr r3,[r7,#28]
  87 003c 1B68     	 ldr r3,[r3]
  88 003e 002B     	 cmp r3,#0
  89 0040 05D0     	 beq .L4
  95:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****          ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
  90              	 .loc 1 95 0 discriminator 1
  91 0042 FB69     	 ldr r3,[r7,#28]
  92 0044 1A68     	 ldr r2,[r3]
  93 0046 1C4B     	 ldr r3,.L8+4
  94 0048 1B68     	 ldr r3,[r3]
  94:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         (ip_addr_isany(&pcb->local_ip) ||
  95              	 .loc 1 94 0 discriminator 1
  96 004a 9A42     	 cmp r2,r3
  97 004c 21D1     	 bne .L3
  98              	.L4:
  96:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #if IP_SOF_BROADCAST_RECV
  97:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* broadcast filter? */
  98:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
  99:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #endif /* IP_SOF_BROADCAST_RECV */
 100:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       {
 101:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         /* receive callback function available? */
 102:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         if (pcb->recv != NULL) {
  99              	 .loc 1 102 0
 100 004e FB69     	 ldr r3,[r7,#28]
 101 0050 5B69     	 ldr r3,[r3,#20]
 102 0052 002B     	 cmp r3,#0
 103 0054 1DD0     	 beq .L3
 103:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****           /* the receive callback function did not eat the packet? */
 104:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****           if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 104              	 .loc 1 104 0
 105 0056 FB69     	 ldr r3,[r7,#28]
 106 0058 5C69     	 ldr r4,[r3,#20]
 107 005a FB69     	 ldr r3,[r7,#28]
 108 005c 9B69     	 ldr r3,[r3,#24]
 109 005e 1846     	 mov r0,r3
 110 0060 F969     	 ldr r1,[r7,#28]
 111 0062 7A68     	 ldr r2,[r7,#4]
 112 0064 154B     	 ldr r3,.L8+8
 113 0066 A047     	 blx r4
 114 0068 0346     	 mov r3,r0
 115 006a 002B     	 cmp r3,#0
 116 006c 11D0     	 beq .L3
 105:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             /* receive function ate the packet */
 106:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             p = NULL;
 117              	 .loc 1 106 0
 118 006e 0023     	 movs r3,#0
 119 0070 7B60     	 str r3,[r7,#4]
 107:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             eaten = 1;
 120              	 .loc 1 107 0
 121 0072 0123     	 movs r3,#1
 122 0074 FB75     	 strb r3,[r7,#23]
 108:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             if (prev != NULL) {
 123              	 .loc 1 108 0
 124 0076 BB69     	 ldr r3,[r7,#24]
 125 0078 002B     	 cmp r3,#0
 126 007a 0AD0     	 beq .L3
 109:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             /* move the pcb to the front of raw_pcbs so that is
 110:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****                found faster next time */
 111:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****               prev->next = pcb->next;
 127              	 .loc 1 111 0
 128 007c FB69     	 ldr r3,[r7,#28]
 129 007e DA68     	 ldr r2,[r3,#12]
 130 0080 BB69     	 ldr r3,[r7,#24]
 131 0082 DA60     	 str r2,[r3,#12]
 112:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****               pcb->next = raw_pcbs;
 132              	 .loc 1 112 0
 133 0084 0B4B     	 ldr r3,.L8
 134 0086 1A68     	 ldr r2,[r3]
 135 0088 FB69     	 ldr r3,[r7,#28]
 136 008a DA60     	 str r2,[r3,#12]
 113:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****               raw_pcbs = pcb;
 137              	 .loc 1 113 0
 138 008c 094A     	 ldr r2,.L8
 139 008e FB69     	 ldr r3,[r7,#28]
 140 0090 1360     	 str r3,[r2]
 141              	.L3:
 114:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****             }
 115:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****           }
 116:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         }
 117:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         /* no receive callback function was set for this raw PCB */
 118:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       }
 119:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* drop the packet */
 120:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 121:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     prev = pcb;
 142              	 .loc 1 121 0
 143 0092 FB69     	 ldr r3,[r7,#28]
 144 0094 BB61     	 str r3,[r7,#24]
 122:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     pcb = pcb->next;
 145              	 .loc 1 122 0
 146 0096 FB69     	 ldr r3,[r7,#28]
 147 0098 DB68     	 ldr r3,[r3,#12]
 148 009a FB61     	 str r3,[r7,#28]
 149              	.L2:
  92:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if ((pcb->protocol == proto) &&
 150              	 .loc 1 92 0
 151 009c FB7D     	 ldrb r3,[r7,#23]
 152 009e 002B     	 cmp r3,#0
 153 00a0 02D1     	 bne .L5
  92:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if ((pcb->protocol == proto) &&
 154              	 .loc 1 92 0 is_stmt 0 discriminator 1
 155 00a2 FB69     	 ldr r3,[r7,#28]
 156 00a4 002B     	 cmp r3,#0
 157 00a6 BED1     	 bne .L6
 158              	.L5:
 123:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 124:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return eaten;
 159              	 .loc 1 124 0 is_stmt 1
 160 00a8 FB7D     	 ldrb r3,[r7,#23]
 125:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 161              	 .loc 1 125 0
 162 00aa 1846     	 mov r0,r3
 163 00ac 2437     	 adds r7,r7,#36
 164              	.LCFI3:
 165              	 .cfi_def_cfa_offset 12
 166 00ae BD46     	 mov sp,r7
 167              	.LCFI4:
 168              	 .cfi_def_cfa_register 13
 169              	 
 170 00b0 90BD     	 pop {r4,r7,pc}
 171              	.L9:
 172 00b2 00BF     	 .align 2
 173              	.L8:
 174 00b4 00000000 	 .word raw_pcbs
 175 00b8 00000000 	 .word current_iphdr_dest
 176 00bc 00000000 	 .word current_iphdr_src
 177              	 .cfi_endproc
 178              	.LFE128:
 180              	 .section .text.raw_bind,"ax",%progbits
 181              	 .align 2
 182              	 .global raw_bind
 183              	 .thumb
 184              	 .thumb_func
 186              	raw_bind:
 187              	.LFB129:
 126:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 127:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 128:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Bind a RAW PCB.
 129:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 130:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param pcb RAW PCB to be bound with a local address ipaddr.
 131:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 132:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * bind to all local interfaces.
 133:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 134:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return lwIP error code.
 135:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * - ERR_OK. Successful. No error occured.
 136:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * - ERR_USE. The specified IP address is already bound to by
 137:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * another RAW PCB.
 138:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 139:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @see raw_disconnect()
 140:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 141:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** err_t
 142:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
 143:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 188              	 .loc 1 143 0
 189              	 .cfi_startproc
 190              	 
 191              	 
 192              	 
 193 0000 80B4     	 push {r7}
 194              	.LCFI5:
 195              	 .cfi_def_cfa_offset 4
 196              	 .cfi_offset 7,-4
 197 0002 83B0     	 sub sp,sp,#12
 198              	.LCFI6:
 199              	 .cfi_def_cfa_offset 16
 200 0004 00AF     	 add r7,sp,#0
 201              	.LCFI7:
 202              	 .cfi_def_cfa_register 7
 203 0006 7860     	 str r0,[r7,#4]
 204 0008 3960     	 str r1,[r7]
 144:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   ip_addr_set(&pcb->local_ip, ipaddr);
 205              	 .loc 1 144 0
 206 000a 3B68     	 ldr r3,[r7]
 207 000c 002B     	 cmp r3,#0
 208 000e 02D0     	 beq .L11
 209              	 .loc 1 144 0 is_stmt 0 discriminator 1
 210 0010 3B68     	 ldr r3,[r7]
 211 0012 1B68     	 ldr r3,[r3]
 212 0014 00E0     	 b .L12
 213              	.L11:
 214              	 .loc 1 144 0 discriminator 2
 215 0016 0023     	 movs r3,#0
 216              	.L12:
 217              	 .loc 1 144 0 discriminator 4
 218 0018 7A68     	 ldr r2,[r7,#4]
 219 001a 1360     	 str r3,[r2]
 145:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return ERR_OK;
 220              	 .loc 1 145 0 is_stmt 1 discriminator 4
 221 001c 0023     	 movs r3,#0
 222 001e 5BB2     	 sxtb r3,r3
 146:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 223              	 .loc 1 146 0 discriminator 4
 224 0020 1846     	 mov r0,r3
 225 0022 0C37     	 adds r7,r7,#12
 226              	.LCFI8:
 227              	 .cfi_def_cfa_offset 4
 228 0024 BD46     	 mov sp,r7
 229              	.LCFI9:
 230              	 .cfi_def_cfa_register 13
 231              	 
 232 0026 5DF8047B 	 ldr r7,[sp],#4
 233              	.LCFI10:
 234              	 .cfi_restore 7
 235              	 .cfi_def_cfa_offset 0
 236 002a 7047     	 bx lr
 237              	 .cfi_endproc
 238              	.LFE129:
 240              	 .section .text.raw_connect,"ax",%progbits
 241              	 .align 2
 242              	 .global raw_connect
 243              	 .thumb
 244              	 .thumb_func
 246              	raw_connect:
 247              	.LFB130:
 147:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 148:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 149:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Connect an RAW PCB. This function is required by upper layers
 150:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * of lwip. Using the raw api you could use raw_sendto() instead
 151:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 152:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * This will associate the RAW PCB with the remote address.
 153:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 154:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param pcb RAW PCB to be connected with remote address ipaddr and port.
 155:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param ipaddr remote IP address to connect with.
 156:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 157:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return lwIP error code
 158:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 159:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @see raw_disconnect() and raw_sendto()
 160:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 161:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** err_t
 162:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
 163:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 248              	 .loc 1 163 0
 249              	 .cfi_startproc
 250              	 
 251              	 
 252              	 
 253 0000 80B4     	 push {r7}
 254              	.LCFI11:
 255              	 .cfi_def_cfa_offset 4
 256              	 .cfi_offset 7,-4
 257 0002 83B0     	 sub sp,sp,#12
 258              	.LCFI12:
 259              	 .cfi_def_cfa_offset 16
 260 0004 00AF     	 add r7,sp,#0
 261              	.LCFI13:
 262              	 .cfi_def_cfa_register 7
 263 0006 7860     	 str r0,[r7,#4]
 264 0008 3960     	 str r1,[r7]
 164:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   ip_addr_set(&pcb->remote_ip, ipaddr);
 265              	 .loc 1 164 0
 266 000a 3B68     	 ldr r3,[r7]
 267 000c 002B     	 cmp r3,#0
 268 000e 02D0     	 beq .L15
 269              	 .loc 1 164 0 is_stmt 0 discriminator 1
 270 0010 3B68     	 ldr r3,[r7]
 271 0012 1B68     	 ldr r3,[r3]
 272 0014 00E0     	 b .L16
 273              	.L15:
 274              	 .loc 1 164 0 discriminator 2
 275 0016 0023     	 movs r3,#0
 276              	.L16:
 277              	 .loc 1 164 0 discriminator 4
 278 0018 7A68     	 ldr r2,[r7,#4]
 279 001a 5360     	 str r3,[r2,#4]
 165:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return ERR_OK;
 280              	 .loc 1 165 0 is_stmt 1 discriminator 4
 281 001c 0023     	 movs r3,#0
 282 001e 5BB2     	 sxtb r3,r3
 166:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 283              	 .loc 1 166 0 discriminator 4
 284 0020 1846     	 mov r0,r3
 285 0022 0C37     	 adds r7,r7,#12
 286              	.LCFI14:
 287              	 .cfi_def_cfa_offset 4
 288 0024 BD46     	 mov sp,r7
 289              	.LCFI15:
 290              	 .cfi_def_cfa_register 13
 291              	 
 292 0026 5DF8047B 	 ldr r7,[sp],#4
 293              	.LCFI16:
 294              	 .cfi_restore 7
 295              	 .cfi_def_cfa_offset 0
 296 002a 7047     	 bx lr
 297              	 .cfi_endproc
 298              	.LFE130:
 300              	 .section .text.raw_recv,"ax",%progbits
 301              	 .align 2
 302              	 .global raw_recv
 303              	 .thumb
 304              	 .thumb_func
 306              	raw_recv:
 307              	.LFB131:
 167:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 168:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 169:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 170:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Set the callback function for received packets that match the
 171:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * raw PCB's protocol and binding. 
 172:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * 
 173:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * The callback function MUST either
 174:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * - eat the packet by calling pbuf_free() and returning non-zero. The
 175:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *   packet will not be passed to other raw PCBs or other protocol layers.
 176:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * - not free the packet, and return zero. The packet will be matched
 177:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *   against further PCBs and/or forwarded to another protocol layers.
 178:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * 
 179:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return non-zero if the packet was free()d, zero if the packet remains
 180:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * available for others.
 181:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 182:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** void
 183:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
 184:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 308              	 .loc 1 184 0
 309              	 .cfi_startproc
 310              	 
 311              	 
 312              	 
 313 0000 80B4     	 push {r7}
 314              	.LCFI17:
 315              	 .cfi_def_cfa_offset 4
 316              	 .cfi_offset 7,-4
 317 0002 85B0     	 sub sp,sp,#20
 318              	.LCFI18:
 319              	 .cfi_def_cfa_offset 24
 320 0004 00AF     	 add r7,sp,#0
 321              	.LCFI19:
 322              	 .cfi_def_cfa_register 7
 323 0006 F860     	 str r0,[r7,#12]
 324 0008 B960     	 str r1,[r7,#8]
 325 000a 7A60     	 str r2,[r7,#4]
 185:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* remember recv() callback and user data */
 186:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   pcb->recv = recv;
 326              	 .loc 1 186 0
 327 000c FB68     	 ldr r3,[r7,#12]
 328 000e BA68     	 ldr r2,[r7,#8]
 329 0010 5A61     	 str r2,[r3,#20]
 187:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   pcb->recv_arg = recv_arg;
 330              	 .loc 1 187 0
 331 0012 FB68     	 ldr r3,[r7,#12]
 332 0014 7A68     	 ldr r2,[r7,#4]
 333 0016 9A61     	 str r2,[r3,#24]
 188:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 334              	 .loc 1 188 0
 335 0018 1437     	 adds r7,r7,#20
 336              	.LCFI20:
 337              	 .cfi_def_cfa_offset 4
 338 001a BD46     	 mov sp,r7
 339              	.LCFI21:
 340              	 .cfi_def_cfa_register 13
 341              	 
 342 001c 5DF8047B 	 ldr r7,[sp],#4
 343              	.LCFI22:
 344              	 .cfi_restore 7
 345              	 .cfi_def_cfa_offset 0
 346 0020 7047     	 bx lr
 347              	 .cfi_endproc
 348              	.LFE131:
 350 0022 00BF     	 .section .text.raw_sendto,"ax",%progbits
 351              	 .align 2
 352              	 .global raw_sendto
 353              	 .thumb
 354              	 .thumb_func
 356              	raw_sendto:
 357              	.LFB132:
 189:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 190:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 191:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Send the raw IP packet to the given address. Note that actually you cannot
 192:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * modify the IP headers (this is inconsistent with the receive callback where
 193:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * you actually get the IP headers), you can only specify the IP payload here.
 194:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * It requires some more changes in lwIP. (there will be a raw_send() function
 195:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * then.)
 196:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 197:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param pcb the raw pcb which to send
 198:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param p the IP payload to send
 199:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param ipaddr the destination address of the IP packet
 200:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 201:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 202:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** err_t
 203:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
 204:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 358              	 .loc 1 204 0
 359              	 .cfi_startproc
 360              	 
 361              	 
 362 0000 90B5     	 push {r4,r7,lr}
 363              	.LCFI23:
 364              	 .cfi_def_cfa_offset 12
 365              	 .cfi_offset 4,-12
 366              	 .cfi_offset 7,-8
 367              	 .cfi_offset 14,-4
 368 0002 8DB0     	 sub sp,sp,#52
 369              	.LCFI24:
 370              	 .cfi_def_cfa_offset 64
 371 0004 04AF     	 add r7,sp,#16
 372              	.LCFI25:
 373              	 .cfi_def_cfa 7,48
 374 0006 F860     	 str r0,[r7,#12]
 375 0008 B960     	 str r1,[r7,#8]
 376 000a 7A60     	 str r2,[r7,#4]
 205:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   err_t err;
 206:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct netif *netif;
 207:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   ip_addr_t *src_ip;
 208:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct pbuf *q; /* q will be sent down the stack */
 209:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   
 210:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
 211:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   
 212:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* not enough space to add an IP header to first pbuf in given p chain? */
 213:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (pbuf_header(p, IP_HLEN)) {
 377              	 .loc 1 213 0
 378 000c B868     	 ldr r0,[r7,#8]
 379 000e 1421     	 movs r1,#20
 380 0010 FFF7FEFF 	 bl pbuf_header
 381 0014 0346     	 mov r3,r0
 382 0016 002B     	 cmp r3,#0
 383 0018 13D0     	 beq .L20
 214:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* allocate header in new pbuf */
 215:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 384              	 .loc 1 215 0
 385 001a 0120     	 movs r0,#1
 386 001c 0021     	 movs r1,#0
 387 001e 0022     	 movs r2,#0
 388 0020 FFF7FEFF 	 bl pbuf_alloc
 389 0024 B861     	 str r0,[r7,#24]
 216:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* new header pbuf could not be allocated? */
 217:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if (q == NULL) {
 390              	 .loc 1 217 0
 391 0026 BB69     	 ldr r3,[r7,#24]
 392 0028 002B     	 cmp r3,#0
 393 002a 01D1     	 bne .L21
 218:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allo
 219:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       return ERR_MEM;
 394              	 .loc 1 219 0
 395 002c FF23     	 movs r3,#255
 396 002e 4BE0     	 b .L22
 397              	.L21:
 220:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 221:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if (p->tot_len != 0) {
 398              	 .loc 1 221 0
 399 0030 BB68     	 ldr r3,[r7,#8]
 400 0032 1B89     	 ldrh r3,[r3,#8]
 401 0034 002B     	 cmp r3,#0
 402 0036 10D0     	 beq .L24
 222:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* chain header q in front of given pbuf p */
 223:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       pbuf_chain(q, p);
 403              	 .loc 1 223 0
 404 0038 B869     	 ldr r0,[r7,#24]
 405 003a B968     	 ldr r1,[r7,#8]
 406 003c FFF7FEFF 	 bl pbuf_chain
 407 0040 0BE0     	 b .L24
 408              	.L20:
 224:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 225:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* { first pbuf q points to header pbuf } */
 226:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (
 227:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }  else {
 228:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* first pbuf q equals given pbuf */
 229:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     q = p;
 409              	 .loc 1 229 0
 410 0042 BB68     	 ldr r3,[r7,#8]
 411 0044 BB61     	 str r3,[r7,#24]
 230:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if(pbuf_header(q, -IP_HLEN)) {
 412              	 .loc 1 230 0
 413 0046 B869     	 ldr r0,[r7,#24]
 414 0048 6FF01301 	 mvn r1,#19
 415 004c FFF7FEFF 	 bl pbuf_header
 416 0050 0346     	 mov r3,r0
 417 0052 002B     	 cmp r3,#0
 418 0054 01D0     	 beq .L24
 231:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       LWIP_ASSERT("Can't restore header we just removed!", 0);
 232:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       return ERR_MEM;
 419              	 .loc 1 232 0
 420 0056 FF23     	 movs r3,#255
 421 0058 36E0     	 b .L22
 422              	.L24:
 233:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 234:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 235:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 236:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if ((netif = ip_route(ipaddr)) == NULL) {
 423              	 .loc 1 236 0
 424 005a 7868     	 ldr r0,[r7,#4]
 425 005c FFF7FEFF 	 bl ip_route
 426 0060 7861     	 str r0,[r7,#20]
 427 0062 7B69     	 ldr r3,[r7,#20]
 428 0064 002B     	 cmp r3,#0
 429 0066 08D1     	 bne .L25
 237:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U
 238:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
 239:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* free any temporary header pbuf allocated by pbuf_header() */
 240:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if (q != p) {
 430              	 .loc 1 240 0
 431 0068 BA69     	 ldr r2,[r7,#24]
 432 006a BB68     	 ldr r3,[r7,#8]
 433 006c 9A42     	 cmp r2,r3
 434 006e 02D0     	 beq .L26
 241:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       pbuf_free(q);
 435              	 .loc 1 241 0
 436 0070 B869     	 ldr r0,[r7,#24]
 437 0072 FFF7FEFF 	 bl pbuf_free
 438              	.L26:
 242:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 243:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     return ERR_RTE;
 439              	 .loc 1 243 0
 440 0076 FC23     	 movs r3,#252
 441 0078 26E0     	 b .L22
 442              	.L25:
 244:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 245:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 246:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #if IP_SOF_BROADCAST
 247:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* broadcast filter? */
 248:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
 249:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb 
 250:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* free any temporary header pbuf allocated by pbuf_header() */
 251:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     if (q != p) {
 252:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       pbuf_free(q);
 253:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 254:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     return ERR_VAL;
 255:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 256:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** #endif /* IP_SOF_BROADCAST */
 257:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 258:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (ip_addr_isany(&pcb->local_ip)) {
 443              	 .loc 1 258 0
 444 007a FB68     	 ldr r3,[r7,#12]
 445 007c 002B     	 cmp r3,#0
 446 007e 03D0     	 beq .L27
 447              	 .loc 1 258 0 is_stmt 0 discriminator 1
 448 0080 FB68     	 ldr r3,[r7,#12]
 449 0082 1B68     	 ldr r3,[r3]
 450 0084 002B     	 cmp r3,#0
 451 0086 03D1     	 bne .L28
 452              	.L27:
 259:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* use outgoing network interface IP address as source address */
 260:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     src_ip = &(netif->ip_addr);
 453              	 .loc 1 260 0 is_stmt 1
 454 0088 7B69     	 ldr r3,[r7,#20]
 455 008a 0433     	 adds r3,r3,#4
 456 008c FB61     	 str r3,[r7,#28]
 457 008e 01E0     	 b .L29
 458              	.L28:
 261:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   } else {
 262:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* use RAW PCB local IP address as source address */
 263:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     src_ip = &(pcb->local_ip);
 459              	 .loc 1 263 0
 460 0090 FB68     	 ldr r3,[r7,#12]
 461 0092 FB61     	 str r3,[r7,#28]
 462              	.L29:
 264:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 265:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 266:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 267:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 463              	 .loc 1 267 0
 464 0094 FB68     	 ldr r3,[r7,#12]
 465 0096 9C7A     	 ldrb r4,[r3,#10]
 466 0098 FB68     	 ldr r3,[r7,#12]
 467 009a 5A7A     	 ldrb r2,[r3,#9]
 468 009c FB68     	 ldr r3,[r7,#12]
 469 009e 1B7C     	 ldrb r3,[r3,#16]
 470 00a0 0092     	 str r2,[sp]
 471 00a2 0193     	 str r3,[sp,#4]
 472 00a4 7B69     	 ldr r3,[r7,#20]
 473 00a6 0293     	 str r3,[sp,#8]
 474 00a8 B869     	 ldr r0,[r7,#24]
 475 00aa F969     	 ldr r1,[r7,#28]
 476 00ac 7A68     	 ldr r2,[r7,#4]
 477 00ae 2346     	 mov r3,r4
 478 00b0 FFF7FEFF 	 bl ip_output_if
 479 00b4 0346     	 mov r3,r0
 480 00b6 FB74     	 strb r3,[r7,#19]
 268:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   NETIF_SET_HWADDRHINT(netif, NULL);
 269:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 270:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* did we chain a header earlier? */
 271:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (q != p) {
 481              	 .loc 1 271 0
 482 00b8 BA69     	 ldr r2,[r7,#24]
 483 00ba BB68     	 ldr r3,[r7,#8]
 484 00bc 9A42     	 cmp r2,r3
 485 00be 02D0     	 beq .L30
 272:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* free the header */
 273:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     pbuf_free(q);
 486              	 .loc 1 273 0
 487 00c0 B869     	 ldr r0,[r7,#24]
 488 00c2 FFF7FEFF 	 bl pbuf_free
 489              	.L30:
 274:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 275:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return err;
 490              	 .loc 1 275 0
 491 00c6 FB7C     	 ldrb r3,[r7,#19]
 492              	.L22:
 493 00c8 5BB2     	 sxtb r3,r3
 276:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 494              	 .loc 1 276 0
 495 00ca 1846     	 mov r0,r3
 496 00cc 2437     	 adds r7,r7,#36
 497              	.LCFI26:
 498              	 .cfi_def_cfa_offset 12
 499 00ce BD46     	 mov sp,r7
 500              	.LCFI27:
 501              	 .cfi_def_cfa_register 13
 502              	 
 503 00d0 90BD     	 pop {r4,r7,pc}
 504              	 .cfi_endproc
 505              	.LFE132:
 507 00d2 00BF     	 .section .text.raw_send,"ax",%progbits
 508              	 .align 2
 509              	 .global raw_send
 510              	 .thumb
 511              	 .thumb_func
 513              	raw_send:
 514              	.LFB133:
 277:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 278:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 279:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Send the raw IP packet to the address given by raw_connect()
 280:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 281:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param pcb the raw pcb which to send
 282:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param p the IP payload to send
 283:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 284:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 285:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** err_t
 286:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_send(struct raw_pcb *pcb, struct pbuf *p)
 287:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 515              	 .loc 1 287 0
 516              	 .cfi_startproc
 517              	 
 518              	 
 519 0000 80B5     	 push {r7,lr}
 520              	.LCFI28:
 521              	 .cfi_def_cfa_offset 8
 522              	 .cfi_offset 7,-8
 523              	 .cfi_offset 14,-4
 524 0002 82B0     	 sub sp,sp,#8
 525              	.LCFI29:
 526              	 .cfi_def_cfa_offset 16
 527 0004 00AF     	 add r7,sp,#0
 528              	.LCFI30:
 529              	 .cfi_def_cfa_register 7
 530 0006 7860     	 str r0,[r7,#4]
 531 0008 3960     	 str r1,[r7]
 288:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return raw_sendto(pcb, p, &pcb->remote_ip);
 532              	 .loc 1 288 0
 533 000a 7B68     	 ldr r3,[r7,#4]
 534 000c 0433     	 adds r3,r3,#4
 535 000e 7868     	 ldr r0,[r7,#4]
 536 0010 3968     	 ldr r1,[r7]
 537 0012 1A46     	 mov r2,r3
 538 0014 FFF7FEFF 	 bl raw_sendto
 539 0018 0346     	 mov r3,r0
 289:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 540              	 .loc 1 289 0
 541 001a 1846     	 mov r0,r3
 542 001c 0837     	 adds r7,r7,#8
 543              	.LCFI31:
 544              	 .cfi_def_cfa_offset 8
 545 001e BD46     	 mov sp,r7
 546              	.LCFI32:
 547              	 .cfi_def_cfa_register 13
 548              	 
 549 0020 80BD     	 pop {r7,pc}
 550              	 .cfi_endproc
 551              	.LFE133:
 553 0022 00BF     	 .section .text.raw_remove,"ax",%progbits
 554              	 .align 2
 555              	 .global raw_remove
 556              	 .thumb
 557              	 .thumb_func
 559              	raw_remove:
 560              	.LFB134:
 290:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 291:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 292:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Remove an RAW PCB.
 293:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 294:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param pcb RAW PCB to be removed. The PCB is removed from the list of
 295:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * RAW PCB's and the data structure is freed from memory.
 296:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 297:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @see raw_new()
 298:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 299:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** void
 300:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_remove(struct raw_pcb *pcb)
 301:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 561              	 .loc 1 301 0
 562              	 .cfi_startproc
 563              	 
 564              	 
 565 0000 80B5     	 push {r7,lr}
 566              	.LCFI33:
 567              	 .cfi_def_cfa_offset 8
 568              	 .cfi_offset 7,-8
 569              	 .cfi_offset 14,-4
 570 0002 84B0     	 sub sp,sp,#16
 571              	.LCFI34:
 572              	 .cfi_def_cfa_offset 24
 573 0004 00AF     	 add r7,sp,#0
 574              	.LCFI35:
 575              	 .cfi_def_cfa_register 7
 576 0006 7860     	 str r0,[r7,#4]
 302:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct raw_pcb *pcb2;
 303:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* pcb to be removed is first in list? */
 304:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (raw_pcbs == pcb) {
 577              	 .loc 1 304 0
 578 0008 144B     	 ldr r3,.L39
 579 000a 1A68     	 ldr r2,[r3]
 580 000c 7B68     	 ldr r3,[r7,#4]
 581 000e 9A42     	 cmp r2,r3
 582 0010 05D1     	 bne .L34
 305:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* make list start at 2nd pcb */
 306:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     raw_pcbs = raw_pcbs->next;
 583              	 .loc 1 306 0
 584 0012 124B     	 ldr r3,.L39
 585 0014 1B68     	 ldr r3,[r3]
 586 0016 DB68     	 ldr r3,[r3,#12]
 587 0018 104A     	 ldr r2,.L39
 588 001a 1360     	 str r3,[r2]
 589 001c 16E0     	 b .L35
 590              	.L34:
 307:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* pcb not 1st in list */
 308:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   } else {
 309:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 591              	 .loc 1 309 0
 592 001e 0F4B     	 ldr r3,.L39
 593 0020 1B68     	 ldr r3,[r3]
 594 0022 FB60     	 str r3,[r7,#12]
 595 0024 0FE0     	 b .L36
 596              	.L38:
 310:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* find pcb in raw_pcbs list */
 311:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       if (pcb2->next != NULL && pcb2->next == pcb) {
 597              	 .loc 1 311 0
 598 0026 FB68     	 ldr r3,[r7,#12]
 599 0028 DB68     	 ldr r3,[r3,#12]
 600 002a 002B     	 cmp r3,#0
 601 002c 08D0     	 beq .L37
 602              	 .loc 1 311 0 is_stmt 0 discriminator 1
 603 002e FB68     	 ldr r3,[r7,#12]
 604 0030 DA68     	 ldr r2,[r3,#12]
 605 0032 7B68     	 ldr r3,[r7,#4]
 606 0034 9A42     	 cmp r2,r3
 607 0036 03D1     	 bne .L37
 312:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         /* remove pcb from list */
 313:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****         pcb2->next = pcb->next;
 608              	 .loc 1 313 0 is_stmt 1
 609 0038 7B68     	 ldr r3,[r7,#4]
 610 003a DA68     	 ldr r2,[r3,#12]
 611 003c FB68     	 ldr r3,[r7,#12]
 612 003e DA60     	 str r2,[r3,#12]
 613              	.L37:
 309:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* find pcb in raw_pcbs list */
 614              	 .loc 1 309 0 discriminator 2
 615 0040 FB68     	 ldr r3,[r7,#12]
 616 0042 DB68     	 ldr r3,[r3,#12]
 617 0044 FB60     	 str r3,[r7,#12]
 618              	.L36:
 309:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       /* find pcb in raw_pcbs list */
 619              	 .loc 1 309 0 is_stmt 0 discriminator 1
 620 0046 FB68     	 ldr r3,[r7,#12]
 621 0048 002B     	 cmp r3,#0
 622 004a ECD1     	 bne .L38
 623              	.L35:
 314:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****       }
 315:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     }
 316:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 317:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   memp_free(MEMP_RAW_PCB, pcb);
 624              	 .loc 1 317 0 is_stmt 1
 625 004c 0020     	 movs r0,#0
 626 004e 7968     	 ldr r1,[r7,#4]
 627 0050 FFF7FEFF 	 bl memp_free
 318:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 628              	 .loc 1 318 0
 629 0054 1037     	 adds r7,r7,#16
 630              	.LCFI36:
 631              	 .cfi_def_cfa_offset 8
 632 0056 BD46     	 mov sp,r7
 633              	.LCFI37:
 634              	 .cfi_def_cfa_register 13
 635              	 
 636 0058 80BD     	 pop {r7,pc}
 637              	.L40:
 638 005a 00BF     	 .align 2
 639              	.L39:
 640 005c 00000000 	 .word raw_pcbs
 641              	 .cfi_endproc
 642              	.LFE134:
 644              	 .section .text.raw_new,"ax",%progbits
 645              	 .align 2
 646              	 .global raw_new
 647              	 .thumb
 648              	 .thumb_func
 650              	raw_new:
 651              	.LFB135:
 319:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 320:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** /**
 321:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * Create a RAW PCB.
 322:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 323:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @return The RAW PCB which was created. NULL if the PCB data structure
 324:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * could not be allocated.
 325:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 326:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 327:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  *
 328:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  * @see raw_remove()
 329:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****  */
 330:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** struct raw_pcb *
 331:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** raw_new(u8_t proto)
 332:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** {
 652              	 .loc 1 332 0
 653              	 .cfi_startproc
 654              	 
 655              	 
 656 0000 80B5     	 push {r7,lr}
 657              	.LCFI38:
 658              	 .cfi_def_cfa_offset 8
 659              	 .cfi_offset 7,-8
 660              	 .cfi_offset 14,-4
 661 0002 84B0     	 sub sp,sp,#16
 662              	.LCFI39:
 663              	 .cfi_def_cfa_offset 24
 664 0004 00AF     	 add r7,sp,#0
 665              	.LCFI40:
 666              	 .cfi_def_cfa_register 7
 667 0006 0346     	 mov r3,r0
 668 0008 FB71     	 strb r3,[r7,#7]
 333:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   struct raw_pcb *pcb;
 334:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 335:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
 336:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** 
 337:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 669              	 .loc 1 337 0
 670 000a 0020     	 movs r0,#0
 671 000c FFF7FEFF 	 bl memp_malloc
 672 0010 F860     	 str r0,[r7,#12]
 338:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   /* could allocate RAW PCB? */
 339:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   if (pcb != NULL) {
 673              	 .loc 1 339 0
 674 0012 FB68     	 ldr r3,[r7,#12]
 675 0014 002B     	 cmp r3,#0
 676 0016 11D0     	 beq .L42
 340:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     /* initialize PCB to all zeroes */
 341:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     memset(pcb, 0, sizeof(struct raw_pcb));
 677              	 .loc 1 341 0
 678 0018 F868     	 ldr r0,[r7,#12]
 679 001a 0021     	 movs r1,#0
 680 001c 1C22     	 movs r2,#28
 681 001e FFF7FEFF 	 bl memset
 342:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     pcb->protocol = proto;
 682              	 .loc 1 342 0
 683 0022 FB68     	 ldr r3,[r7,#12]
 684 0024 FA79     	 ldrb r2,[r7,#7]
 685 0026 1A74     	 strb r2,[r3,#16]
 343:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     pcb->ttl = RAW_TTL;
 686              	 .loc 1 343 0
 687 0028 FB68     	 ldr r3,[r7,#12]
 688 002a FF22     	 movs r2,#255
 689 002c 9A72     	 strb r2,[r3,#10]
 344:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     pcb->next = raw_pcbs;
 690              	 .loc 1 344 0
 691 002e 064B     	 ldr r3,.L44
 692 0030 1A68     	 ldr r2,[r3]
 693 0032 FB68     	 ldr r3,[r7,#12]
 694 0034 DA60     	 str r2,[r3,#12]
 345:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****     raw_pcbs = pcb;
 695              	 .loc 1 345 0
 696 0036 044A     	 ldr r2,.L44
 697 0038 FB68     	 ldr r3,[r7,#12]
 698 003a 1360     	 str r3,[r2]
 699              	.L42:
 346:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   }
 347:../Dave/Generated/ETH_LWIP/lwip/core/raw.c ****   return pcb;
 700              	 .loc 1 347 0
 701 003c FB68     	 ldr r3,[r7,#12]
 348:../Dave/Generated/ETH_LWIP/lwip/core/raw.c **** }
 702              	 .loc 1 348 0
 703 003e 1846     	 mov r0,r3
 704 0040 1037     	 adds r7,r7,#16
 705              	.LCFI41:
 706              	 .cfi_def_cfa_offset 8
 707 0042 BD46     	 mov sp,r7
 708              	.LCFI42:
 709              	 .cfi_def_cfa_register 13
 710              	 
 711 0044 80BD     	 pop {r7,pc}
 712              	.L45:
 713 0046 00BF     	 .align 2
 714              	.L44:
 715 0048 00000000 	 .word raw_pcbs
 716              	 .cfi_endproc
 717              	.LFE135:
 719              	 .text
 720              	.Letext0:
 721              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 722              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 723              	 .file 4 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/../../port/include/arch/cc.h"
 724              	 .file 5 "../Dave/Generated/ETH_LWIP/lwip/core/../include/ipv4/lwip/ip_addr.h"
 725              	 .file 6 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/err.h"
 726              	 .file 7 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/memp.h"
 727              	 .file 8 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/pbuf.h"
 728              	 .file 9 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/netif.h"
 729              	 .file 10 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/../ipv4/lwip/ip.h"
 730              	 .file 11 "../Dave/Generated/ETH_LWIP/lwip/core/../include/lwip/raw.h"
 731              	 .file 12 "C:/Users/Will/Documents/GitHub/Launch-DAQ/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 raw.c
    {standard input}:20     .bss.raw_pcbs:00000000 $d
    {standard input}:23     .bss.raw_pcbs:00000000 raw_pcbs
    {standard input}:26     .text.raw_input:00000000 $t
    {standard input}:31     .text.raw_input:00000000 raw_input
    {standard input}:174    .text.raw_input:000000b4 $d
    {standard input}:181    .text.raw_bind:00000000 $t
    {standard input}:186    .text.raw_bind:00000000 raw_bind
    {standard input}:241    .text.raw_connect:00000000 $t
    {standard input}:246    .text.raw_connect:00000000 raw_connect
    {standard input}:301    .text.raw_recv:00000000 $t
    {standard input}:306    .text.raw_recv:00000000 raw_recv
    {standard input}:351    .text.raw_sendto:00000000 $t
    {standard input}:356    .text.raw_sendto:00000000 raw_sendto
    {standard input}:508    .text.raw_send:00000000 $t
    {standard input}:513    .text.raw_send:00000000 raw_send
    {standard input}:554    .text.raw_remove:00000000 $t
    {standard input}:559    .text.raw_remove:00000000 raw_remove
    {standard input}:640    .text.raw_remove:0000005c $d
    {standard input}:645    .text.raw_new:00000000 $t
    {standard input}:650    .text.raw_new:00000000 raw_new
    {standard input}:715    .text.raw_new:00000048 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
current_iphdr_dest
current_iphdr_src
pbuf_header
pbuf_alloc
pbuf_chain
ip_route
pbuf_free
ip_output_if
memp_free
memp_malloc
memset
